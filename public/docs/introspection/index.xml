<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>自省 on 君宝的笔记</title>
    <link>http://localhost:1313/docs/introspection/</link>
    <description>Recent content in 自省 on 君宝的笔记</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <atom:link href="http://localhost:1313/docs/introspection/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java 线程池</title>
      <link>http://localhost:1313/docs/introspection/thread-pool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/introspection/thread-pool/</guid>
      <description>&lt;p&gt;在 Java 中使用线程池（如 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;）时，理解其参数非常关键，这些参数直接影响线程的&lt;strong&gt;性能&lt;/strong&gt;、&lt;strong&gt;可扩展性&lt;/strong&gt;和&lt;strong&gt;稳定性&lt;/strong&gt;。下面详细介绍 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 构造函数的各个参数及其作用：&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-构造函数定义&#34;&gt;&#xD;&#xA;  🧱 构造函数定义&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%ae%9a%e4%b9%89&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ThreadPoolExecutor&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; corePoolSize,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; maximumPoolSize,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; keepAliveTime,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TimeUnit unit,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    BlockingQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Runnable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; workQueue,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ThreadFactory threadFactory,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    RejectedExecutionHandler handler&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-参数详细说明&#34;&gt;&#xD;&#xA;  📌 参数详细说明&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%e5%8f%82%e6%95%b0%e8%af%a6%e7%bb%86%e8%af%b4%e6%98%8e&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;参数&lt;/th&gt;&#xA;          &lt;th&gt;类型&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;corePoolSize&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;核心线程数，线程池中&lt;strong&gt;始终保留&lt;/strong&gt;的线程数，即使它们空闲也不会被销毁（除非设置了 &lt;code&gt;allowCoreThreadTimeOut(true)&lt;/code&gt;）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;线程池中&lt;strong&gt;允许的最大线程数&lt;/strong&gt;，当任务过多并且队列满了时才会创建超过 core 数量的线程&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;keepAliveTime&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;long&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;非核心线程空闲多久会被销毁；如果设置了 &lt;code&gt;allowCoreThreadTimeOut(true)&lt;/code&gt;，核心线程也会使用此超时&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;unit&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;TimeUnit&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;上述 keepAliveTime 的单位，例如 &lt;code&gt;TimeUnit.SECONDS&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;workQueue&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;BlockingQueue&amp;lt;Runnable&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;用来缓存等待执行的任务的队列，例如 &lt;code&gt;ArrayBlockingQueue&lt;/code&gt;, &lt;code&gt;LinkedBlockingQueue&lt;/code&gt;, &lt;code&gt;SynchronousQueue&lt;/code&gt; 等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;threadFactory&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;ThreadFactory&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;自定义线程创建方式，例如设置线程名、是否为 daemon 等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;handler&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;RejectedExecutionHandler&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;拒绝策略，当线程池和队列都满时用来处理新提交的任务&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-工作机制简述&#34;&gt;&#xD;&#xA;  🎯 工作机制简述&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6%e7%ae%80%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;当一个任务提交到线程池时：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java.util.concurrent 包</title>
      <link>http://localhost:1313/docs/introspection/juc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/introspection/juc/</guid>
      <description>&lt;p&gt;Java 中的 &lt;strong&gt;JUC（java.util.concurrent）&lt;/strong&gt; 是并发编程的核心包，提供了大量强大、高性能的工具类来简化线程操作和并发控制。&lt;/p&gt;&#xA;&lt;p&gt;下面是对 JUC 中&lt;strong&gt;最常用类和接口的详细分类与解析&lt;/strong&gt;，帮助你构建对 Java 并发编程的完整认识。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-一juc-核心模块总览&#34;&gt;&#xD;&#xA;  🌳 一、JUC 核心模块总览&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%e4%b8%80juc-%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97%e6%80%bb%e8%a7%88&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;java.util.concurrent.*&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── Executor 框架（线程池）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── 同步器（Locks、CountDownLatch、Semaphore、CyclicBarrier）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── 并发集合（ConcurrentHashMap、CopyOnWriteArrayList 等）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── 原子变量（AtomicXXX）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── Fork/Join 框架&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── CompletableFuture、Future&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── ScheduledExecutor、BlockingQueue 等&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-二executor-框架线程池相关&#34;&gt;&#xD;&#xA;  🚀 二、Executor 框架（线程池相关）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%e4%ba%8cexecutor-%e6%a1%86%e6%9e%b6%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9b%b8%e5%85%b3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类/接口&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;最基础的接口，只有一个方法 &lt;code&gt;execute(Runnable)&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;提供 &lt;code&gt;submit()&lt;/code&gt;、&lt;code&gt;shutdown()&lt;/code&gt; 等高级控制&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;可自定义线程池参数的核心实现类&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;支持定时或周期任务执行&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;Executors&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;工厂类，提供常用线程池的创建方法（如 &lt;code&gt;newFixedThreadPool()&lt;/code&gt;）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;-推荐使用方式&#34;&gt;&#xD;&#xA;  ☑️ 推荐使用方式&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%e6%8e%a8%e8%8d%90%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;避免 &lt;code&gt;Executors.newXxx()&lt;/code&gt; 静态方法，建议自己构造 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ExecutorService pool &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ThreadPoolExecutor(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    4, 8, 60, TimeUnit.&lt;span style=&#34;color:#a6e22e&#34;&gt;SECONDS&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; LinkedBlockingQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;(100)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-三同步器lock信号量栅栏等&#34;&gt;&#xD;&#xA;  🧱 三、同步器（Lock、信号量、栅栏等）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%e4%b8%89%e5%90%8c%e6%ad%a5%e5%99%a8lock%e4%bf%a1%e5%8f%b7%e9%87%8f%e6%a0%85%e6%a0%8f%e7%ad%89&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;1-lockcondition&#34;&gt;&#xD;&#xA;  1. Lock/Condition&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-lockcondition&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类/接口&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;比 &lt;code&gt;synchronized&lt;/code&gt; 更灵活，支持中断、非阻塞获取&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;可重入锁，支持公平/非公平锁&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;读写分离，提高并发性&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;类似 &lt;code&gt;Object.wait/notify&lt;/code&gt;，配合 Lock 使用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;示例：&lt;/p&gt;</description>
    </item>
    <item>
      <title>OpenTelemetry 全链路追踪</title>
      <link>http://localhost:1313/docs/introspection/trace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/introspection/trace/</guid>
      <description>&lt;p&gt;在微服务架构中使用 OpenTelemetry 实现全链路追踪是提升可 observability（可观测性）和系统可维护性的关键步骤。以下是一些最佳实践，涵盖从设计、实现到部署运维的完整视角。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-一opentelemetry-简介&#34;&gt;&#xD;&#xA;  🌐 一、OpenTelemetry 简介&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%e4%b8%80opentelemetry-%e7%ae%80%e4%bb%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;OpenTelemetry 是由 CNCF（Cloud Native Computing Foundation）托管的开放标准，支持 &lt;strong&gt;分布式追踪（Tracing）&lt;/strong&gt;、&lt;strong&gt;指标（Metrics）&lt;/strong&gt; 和 &lt;strong&gt;日志（Logs）&lt;/strong&gt; 的采集与导出。它支持多语言，能够将数据导出至多种后端（如 Jaeger、Prometheus、Grafana Tempo、Datadog、Zipkin 等）。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-二全链路追踪的核心概念&#34;&gt;&#xD;&#xA;  📦 二、全链路追踪的核心概念&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%e4%ba%8c%e5%85%a8%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Trace（追踪）&lt;/strong&gt;：一次完整的调用链（如用户下单请求）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Span（跨度）&lt;/strong&gt;：调用链中的单个操作（如订单服务调用库存服务）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Context（上下文）&lt;/strong&gt;：跨服务传递 trace 的元信息（如 trace id）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-三在微服务架构中使用-opentelemetry-的最佳实践&#34;&gt;&#xD;&#xA;  🔧 三、在微服务架构中使用 OpenTelemetry 的最佳实践&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-%e4%b8%89%e5%9c%a8%e5%be%ae%e6%9c%8d%e5%8a%a1%e6%9e%b6%e6%9e%84%e4%b8%ad%e4%bd%bf%e7%94%a8-opentelemetry-%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;-1-统一规范和自动化接入&#34;&gt;&#xD;&#xA;  ✅ 1. &lt;strong&gt;统一规范和自动化接入&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-1-%e7%bb%9f%e4%b8%80%e8%a7%84%e8%8c%83%e5%92%8c%e8%87%aa%e5%8a%a8%e5%8c%96%e6%8e%a5%e5%85%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;选择统一的 SDK 版本&lt;/strong&gt;：所有服务使用相同版本的 OpenTelemetry SDK。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;使用自动注入的方式接入 HTTP / gRPC 框架&lt;/strong&gt;：例如 Spring Boot + Spring Cloud Sleuth，Python FastAPI + OpenTelemetry middleware，Go + OpenTelemetry HTTP 插件。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;尽量避免手动创建 span，使用封装的 middleware 或框架支持&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-2-统一上下文传递context-propagation&#34;&gt;&#xD;&#xA;  🔗 2. &lt;strong&gt;统一上下文传递（Context Propagation）&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-2-%e7%bb%9f%e4%b8%80%e4%b8%8a%e4%b8%8b%e6%96%87%e4%bc%a0%e9%80%92context-propagation&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用标准协议（如 W3C Trace Context）传递 trace 上下文。&lt;/li&gt;&#xA;&lt;li&gt;在所有服务间调用（REST/gRPC/Kafka/NATS）时，显式或自动传递 &lt;code&gt;traceparent&lt;/code&gt;、&lt;code&gt;baggage&lt;/code&gt; 等 headers。&lt;/li&gt;&#xA;&lt;li&gt;确保所有服务的网关、API 层、异步消息系统都能正确传递 trace context。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-3-选择合适的后端exporter&#34;&gt;&#xD;&#xA;  📤 3. &lt;strong&gt;选择合适的后端（Exporter）&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#-3-%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e5%90%8e%e7%ab%afexporter&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;常见导出目标：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

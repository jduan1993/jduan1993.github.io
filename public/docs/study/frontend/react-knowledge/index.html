<!DOCTYPE html>
<html lang="zh" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="This is an extensive list covering almost every aspect of React development! I&rsquo;ll provide concise, effective answers for each, suitable for an interview context. Remember to personalize these answers with your own project examples and specific experiences to make them more impactful.


  💡 React 核心基础
  #



  React 的核心原理是什么？
  #

React 的核心原理是声明式 UI 和组件化。我们通过声明式地描述 UI 应该长什么样（给定状态），React 会负责更新 UI 以匹配这个声明。它将 UI 拆分成独立、可复用的组件，每个组件管理自己的状态并渲染特定的 UI 片段。通过虚拟 DOM 和 Diff 算法，React 高效地更新真实 DOM，只修改必要的部分，从而提升性能。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/study/frontend/react-knowledge/">
  <meta property="og:site_name" content="君宝的笔记">
  <meta property="og:title" content="React 知识">
  <meta property="og:description" content="This is an extensive list covering almost every aspect of React development! I’ll provide concise, effective answers for each, suitable for an interview context. Remember to personalize these answers with your own project examples and specific experiences to make them more impactful.
💡 React 核心基础#React 的核心原理是什么？#React 的核心原理是声明式 UI 和组件化。我们通过声明式地描述 UI 应该长什么样（给定状态），React 会负责更新 UI 以匹配这个声明。它将 UI 拆分成独立、可复用的组件，每个组件管理自己的状态并渲染特定的 UI 片段。通过虚拟 DOM 和 Diff 算法，React 高效地更新真实 DOM，只修改必要的部分，从而提升性能。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:modified_time" content="2025-06-24T15:30:39+08:00">
<title>React 知识 | 君宝的笔记</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/study/frontend/react-knowledge/">
<link rel="stylesheet" href="/book.min.06d84d78247e572aefdb64432e406e1f78a9ead4ef25479efa82ff79bd6c0873.css" integrity="sha256-BthNeCR&#43;Vyrv22RDLkBuH3ip6tTvJUee&#43;oL/eb1sCHM=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/zh.search.min.98d6c76cea8c5502ec7a8445029c9a9d96569cca23e2fea85075ca9276555d02.js" integrity="sha256-mNbHbOqMVQLseoRFApyanZZWnMoj4v6oUHXKknZVXQI=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>君宝的笔记</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-51faac69e5e901597a0480b538fe5e9e" class="toggle" checked />
    <label for="section-51faac69e5e901597a0480b538fe5e9e" class="flex justify-between">
      <a role="button" class="">学习资料</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-582da456f48414d663a4153b7d734ed6" class="toggle"  />
    <label for="section-582da456f48414d663a4153b7d734ed6" class="flex justify-between">
      <a role="button" class="">安全</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/security/replay-attack/" class="">重放攻击</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-407d2f8dd9410e8eef358914dd8c0dc2" class="toggle"  />
    <label for="section-407d2f8dd9410e8eef358914dd8c0dc2" class="flex justify-between">
      <a role="button" class="">缓存</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/cache/solution/" class="">方案</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e8dd3e3cc6bf1cd4a7414fff39582ee8" class="toggle"  />
    <label for="section-e8dd3e3cc6bf1cd4a7414fff39582ee8" class="flex justify-between">
      <a role="button" class="">基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/base/python/" class="">Python 基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/base/saga-best-practices/" class="">Saga 模式最佳实践</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/base/algorithm/" class="">算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/base/license-comparison/" class="">主流许可证对比</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-57eec37e4d3dd0c268dbeb31bc61d4b1" class="toggle" checked />
    <label for="section-57eec37e4d3dd0c268dbeb31bc61d4b1" class="flex justify-between">
      <a role="button" class="">前端</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/frontend/react-knowledge/" class="active">React 知识</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70d792a755054f6bbbb3adad5db99041" class="toggle"  />
    <label for="section-70d792a755054f6bbbb3adad5db99041" class="flex justify-between">
      <a role="button" class="">数据库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/database/postgresql-mysql/" class="">PostgreSQL vs MySQL (InnoDB) 选型</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3ba9e8b376ea48d5beb815b520fdce5d" class="toggle"  />
    <label for="section-3ba9e8b376ea48d5beb815b520fdce5d" class="flex justify-between">
      <a role="button" class="">网络</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/network/http-comparison/" class="">HTTP 协议各版本比较</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/network/rtt/" class="">往返时间（Round Trip Time）</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a1d7a3583cdff606ffe4820acf270df1" class="toggle"  />
    <label for="section-a1d7a3583cdff606ffe4820acf270df1" class="flex justify-between">
      <a role="button" class="">系统设计</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/system-design/" class="">系统设计</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/doctolib-tips/" class="">Doctolib 大纲</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/doctolib-system-design/" class="">Doctolib 系统设计</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/rpc/" class="">RPC 框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/high-availability/" class="">高可用性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/cache-consistency/" class="">缓存一致性</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-92f7d13098d747ba4906005529a0358a" class="toggle"  />
    <label for="section-92f7d13098d747ba4906005529a0358a" class="flex justify-between">
      <a role="button" class="">中间件</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>Kafka</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/middleware/kafka/exactly-once/" class="">Kafka Exactly-Once</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/middleware/kafka/microservices-comm/" class="">微服务通信</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/middleware/netty/" class="">Netty 详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <span>OAuth2</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/middleware/oauth2/auth-code/" class="">授权码模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-6711a471a1458349986928f5c4b580ef" class="toggle"  />
    <label for="section-6711a471a1458349986928f5c4b580ef" class="flex justify-between">
      <a role="button" class="">自省</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/introspection/thread-pool/" class="">Java 线程池</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/introspection/juc/" class="">Java.util.concurrent 包</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/introspection/trace/" class="">OpenTelemetry 全链路追踪</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-06148cf0da5a87ffda4f34920eae5a83" class="toggle"  />
    <label for="section-06148cf0da5a87ffda4f34920eae5a83" class="flex justify-between">
      <a href="/docs/example/" class="">Example Site</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/" class="">Table of Contents</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/with-toc/" class="">With ToC</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/without-toc/" class="">Without ToC</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-dcab297e11de79eb42396c59d3314623" class="toggle"  />
    <label for="section-dcab297e11de79eb42396c59d3314623" class="flex justify-between">
      <a role="button" class="">Collapsed</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/collapsed/3rd-level/" class="">3rd Level</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/collapsed/3rd-level/4th-level/" class="">4th Level</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/introduction/" class="">介绍</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-25b4439e87cf8c09de5a8727ce755d08" class="toggle"  />
    <label for="section-25b4439e87cf8c09de5a8727ce755d08" class="flex justify-between">
      <a role="button" class="">Shortcodes</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/buttons/" class="">Buttons</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/columns/" class="">Columns</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/details/" class="">Details</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/hints/" class="">Hints</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/mermaid/" class="">Mermaid</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/tabs/" class="">Tabs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/katex/" class="">KaTeX</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>










  
<ul>
  
  <li>
    <a href="https://github.com/jduan1993"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>React 知识</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <meta name="referrer" content="no-referrer-when-downgrade">

  
  <aside class="hidden clearfix">
    
  
<style>
    .no-marker::marker {
        content: none;
    }
</style>
<li class="no-marker"><a href="#React%20%e7%9f%a5%e8%af%86">React 知识</a></li>
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#-react-核心基础">💡 React 核心基础</a>
          <ul>
            <li><a href="#react-的核心原理是什么">React 的核心原理是什么？</a></li>
            <li><a href="#什么是虚拟-dom它怎么提升性能">什么是虚拟 DOM？它怎么提升性能？</a></li>
            <li><a href="#react-组件有哪些函数组件-vs-类组件区别">React 组件有哪些？函数组件 vs 类组件区别？</a></li>
            <li><a href="#什么是-jsx它如何被处理">什么是 JSX？它如何被处理？</a></li>
            <li><a href="#react-中的状态和-props-有什么区别">React 中的状态和 props 有什么区别？</a></li>
            <li><a href="#key-的作用是什么为什么不能用-index">key 的作用是什么？为什么不能用 index？</a></li>
            <li><a href="#什么是受控组件和非受控组件">什么是受控组件和非受控组件？</a></li>
          </ul>
        </li>
        <li><a href="#-hooks">⚙️ Hooks</a>
          <ul>
            <li><a href="#usestate-和-useeffect-的用法与注意事项">useState 和 useEffect 的用法与注意事项？</a></li>
            <li><a href="#如何模拟-componentdidmount--didupdate--willunmount">如何模拟 componentDidMount / DidUpdate / WillUnmount？</a></li>
            <li><a href="#useeffect-依赖数组为什么不能随便省略">useEffect 依赖数组为什么不能随便省略？</a></li>
            <li><a href="#如何用-useref-实现防抖或保存旧状态">如何用 useRef 实现防抖或保存旧状态？</a></li>
            <li><a href="#usecallback-vs-usememo-区别">useCallback vs useMemo 区别？</a></li>
            <li><a href="#自定义-hook-怎么写实际项目中写过哪些">自定义 Hook 怎么写？实际项目中写过哪些？</a></li>
          </ul>
        </li>
        <li><a href="#-性能优化与架构">🚀 性能优化与架构</a>
          <ul>
            <li><a href="#react-中有哪些性能优化方法">React 中有哪些性能优化方法？</a></li>
            <li><a href="#什么是虚拟化virtualization用过哪些库">什么是虚拟化（virtualization）？用过哪些库？</a></li>
            <li><a href="#如何避免子组件重复渲染">如何避免子组件重复渲染？</a></li>
            <li><a href="#什么是代码分割code-splitting">什么是代码分割（Code Splitting）？</a></li>
            <li><a href="#组件懒加载如何实现reactlazy-vs-动态导入">组件懒加载如何实现？React.lazy vs 动态导入</a></li>
          </ul>
        </li>
        <li><a href="#-状态管理">🔄 状态管理</a>
          <ul>
            <li><a href="#你项目中如何管理组件间状态">你项目中如何管理组件间状态？</a></li>
            <li><a href="#redux-工作原理">Redux 工作原理？</a></li>
            <li><a href="#usecontext-有哪些适用场景能替代-redux-吗">useContext 有哪些适用场景？能替代 Redux 吗？</a></li>
            <li><a href="#redux-中-thunk--saga-的作用">Redux 中 thunk / saga 的作用？</a></li>
            <li><a href="#zustandrecoiljotai-用过吗优缺点">Zustand、Recoil、Jotai 用过吗？优缺点？</a></li>
          </ul>
        </li>
        <li><a href="#-异步与网络请求">🌐 异步与网络请求</a>
          <ul>
            <li><a href="#react-中如何发送异步请求">React 中如何发送异步请求？</a></li>
            <li><a href="#怎么处理加载中错误和取消请求">怎么处理加载中、错误和取消请求？</a></li>
            <li><a href="#项目中如何做接口缓存--分页加载">项目中如何做接口缓存 / 分页加载？</a></li>
            <li><a href="#用过-react-query-吗核心特性">用过 react-query 吗？核心特性？</a></li>
          </ul>
        </li>
        <li><a href="#-组件通信与复用">📦 组件通信与复用</a>
          <ul>
            <li><a href="#父子组件如何通信兄弟组件怎么通信">父子组件如何通信？兄弟组件怎么通信？</a></li>
            <li><a href="#什么是高阶组件hoc">什么是高阶组件（HOC）？</a></li>
            <li><a href="#什么是-render-props-模式">什么是 render props 模式？</a></li>
            <li><a href="#组件复用有哪些方式你实际项目怎么做的">组件复用有哪些方式？你实际项目怎么做的？</a></li>
            <li><a href="#什么是组合优于继承react-如何体现">什么是组合优于继承？React 如何体现？</a></li>
          </ul>
        </li>
        <li><a href="#-路由与表单">📄 路由与表单</a>
          <ul>
            <li><a href="#react-router-的核心原理">React Router 的核心原理？</a></li>
            <li><a href="#路由懒加载怎么做">路由懒加载怎么做？</a></li>
            <li><a href="#表单库你用过哪些formik--react-hook-form">表单库你用过哪些？Formik / React Hook Form？</a></li>
            <li><a href="#表单校验是怎么实现的">表单校验是怎么实现的？</a></li>
          </ul>
        </li>
        <li><a href="#-测试与工具链">🧪 测试与工具链</a>
          <ul>
            <li><a href="#如何对-react-组件进行单元测试">如何对 React 组件进行单元测试？</a></li>
            <li><a href="#jestreact-testing-library-用过吗">jest、react-testing-library 用过吗？</a></li>
            <li><a href="#用什么工具调试-react-应用">用什么工具调试 React 应用？</a></li>
            <li><a href="#webpack--vite-配置你了解吗">Webpack / Vite 配置你了解吗？</a></li>
            <li><a href="#webpack-传统打包工具"><strong>Webpack (传统打包工具)</strong></a></li>
            <li><a href="#vite-新一代构建工具"><strong>Vite (新一代构建工具)</strong></a></li>
          </ul>
        </li>
        <li><a href="#-项目实战经验">🛠️ 项目实战经验</a>
          <ul>
            <li><a href="#描述你做过的一个复杂-react-项目">描述你做过的一个复杂 React 项目？</a></li>
            <li><a href="#项目中遇到过哪些性能问题怎么解决的">项目中遇到过哪些性能问题？怎么解决的？</a></li>
            <li><a href="#你是如何组织组件结构和模块的">你是如何组织组件结构和模块的？</a></li>
            <li><a href="#在-react-项目中做过哪些抽象封装">在 React 项目中做过哪些抽象/封装？</a></li>
            <li><a href="#和后端如何对接有没有封装请求库">和后端如何对接？有没有封装请求库？</a></li>
          </ul>
        </li>
        <li><a href="#-进阶与框架原理">🧠 进阶与框架原理</a>
          <ul>
            <li><a href="#react-中-setstate-是同步还是异步的为什么">React 中 setState 是同步还是异步的？为什么？</a></li>
            <li><a href="#什么是调和reconciliation">什么是调和（Reconciliation）？</a></li>
            <li><a href="#fiber-架构解决了什么问题">Fiber 架构解决了什么问题？</a></li>
            <li><a href="#concurrent-mode-和-suspense-知道多少">Concurrent Mode 和 Suspense 知道多少？</a></li>
            <li><a href="#react-18-引入了哪些新特性">React 18 引入了哪些新特性？</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1 id="React 知识">
    React 知识
    <a class="anchor" href="#React%20%e7%9f%a5%e8%af%86">#</a>
  </h1>
  
  <div><a class="flex align-center" href="https://github.com/jduan1993/jduan1993.github.io/commit/c29164a052168171a61a7da777fc7a2880e57b3b" title='最后修改者 jduan1993 | 六月 24, 2025' target="_blank" rel="noopener">
    <img src="/svg/calendar.svg" class="book-icon" alt="" />
    <span>六月 24, 2025</span>
    </a>
  </div>
  
  


  

  


  <div class="book-post-content"><p>This is an extensive list covering almost every aspect of React development! I&rsquo;ll provide concise, effective answers for each, suitable for an interview context. Remember to <strong>personalize these answers with your own project examples and specific experiences</strong> to make them more impactful.</p>
<hr>
<h2 id="-react-核心基础">
  💡 React 核心基础
  <a class="anchor" href="#-react-%e6%a0%b8%e5%bf%83%e5%9f%ba%e7%a1%80">#</a>
</h2>
<hr>
<h3 id="react-的核心原理是什么">
  React 的核心原理是什么？
  <a class="anchor" href="#react-%e7%9a%84%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88">#</a>
</h3>
<p>React 的核心原理是<strong>声明式 UI 和组件化</strong>。我们通过声明式地描述 UI 应该长什么样（给定状态），React 会负责更新 UI 以匹配这个声明。它将 UI 拆分成独立、可复用的组件，每个组件管理自己的状态并渲染特定的 UI 片段。通过<strong>虚拟 DOM 和 Diff 算法</strong>，React 高效地更新真实 DOM，只修改必要的部分，从而提升性能。</p>
<h3 id="什么是虚拟-dom它怎么提升性能">
  什么是虚拟 DOM？它怎么提升性能？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%99%9a%e6%8b%9f-dom%e5%ae%83%e6%80%8e%e4%b9%88%e6%8f%90%e5%8d%87%e6%80%a7%e8%83%bd">#</a>
</h3>
<p><strong>虚拟 DOM (Virtual DOM)</strong> 是一个轻量级的 JavaScript 对象树，它是真实 DOM 结构的一个内存表示。当组件状态发生变化时，React 会先创建一个新的虚拟 DOM 树，然后将新旧两棵虚拟 DOM 树进行 <strong>Diff 算法</strong>比较，找出两者之间的最小差异。最后，React 只将这些<strong>差异应用到真实的 DOM 上</strong>，而不是重新渲染整个页面。</p>
<p>虚拟 DOM 提升性能体现在：</p>
<ol>
<li><strong>减少直接操作真实 DOM 的次数：</strong> 真实 DOM 操作非常昂贵，虚拟 DOM 允许批量更新。</li>
<li><strong>最小化 DOM 操作范围：</strong> Diff 算法确保只更新发生变化的最小部分，避免不必要的重绘和回流。</li>
<li><strong>跨平台能力：</strong> 虚拟 DOM 不依赖于特定的渲染环境，使其能用于 Native、WebGL 等。</li>
</ol>
<h3 id="react-组件有哪些函数组件-vs-类组件区别">
  React 组件有哪些？函数组件 vs 类组件区别？
  <a class="anchor" href="#react-%e7%bb%84%e4%bb%b6%e6%9c%89%e5%93%aa%e4%ba%9b%e5%87%bd%e6%95%b0%e7%bb%84%e4%bb%b6-vs-%e7%b1%bb%e7%bb%84%e4%bb%b6%e5%8c%ba%e5%88%ab">#</a>
</h3>
<p>React 组件主要有<strong>函数组件 (Functional Components)</strong> 和 <strong>类组件 (Class Components)</strong>。</p>
<p><strong>函数组件 vs 类组件区别：</strong></p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特点</th>
          <th style="text-align: left">函数组件 (Hooks 之前)</th>
          <th style="text-align: left">函数组件 (Hooks 之后)</th>
          <th style="text-align: left">类组件</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>定义</strong></td>
          <td style="text-align: left">纯函数，接收 <code>props</code> 返回 JSX</td>
          <td style="text-align: left">纯函数，接收 <code>props</code> 返回 JSX</td>
          <td style="text-align: left">ES6 Class，继承 <code>React.Component</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>状态</strong></td>
          <td style="text-align: left">无状态 (Stateless)</td>
          <td style="text-align: left">通过 <strong><code>useState</code> Hook</strong> 管理状态</td>
          <td style="text-align: left">通过 <code>this.state</code> 和 <code>this.setState</code> 管理</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>生命周期</strong></td>
          <td style="text-align: left">无生命周期方法</td>
          <td style="text-align: left">通过 <strong><code>useEffect</code> Hook</strong> 模拟生命周期方法</td>
          <td style="text-align: left">拥有 <code>componentDidMount</code> 等完整生命周期方法</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>this</strong></td>
          <td style="text-align: left">无 <code>this</code> (箭头函数除外)</td>
          <td style="text-align: left">无 <code>this</code></td>
          <td style="text-align: left">存在 <code>this</code>，需要处理 <code>this</code> 绑定</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>性能</strong></td>
          <td style="text-align: left">理论上更轻量，潜在性能优化（如自动记忆化）</td>
          <td style="text-align: left">理论上更轻量，配合 <code>useCallback</code>/<code>useMemo</code> 优化</td>
          <td style="text-align: left">相对重，优化需 <code>shouldComponentUpdate</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>代码风格</strong></td>
          <td style="text-align: left">更简洁，易于测试和理解</td>
          <td style="text-align: left">更简洁，易于测试和理解</td>
          <td style="text-align: left">相对繁琐，需要编写更多样板代码</td>
      </tr>
  </tbody>
</table>
<p><strong>推荐：</strong> 在 React 16.8 引入 Hooks 后，<strong>函数组件成为主流</strong>，因为它们提供了同样的功能，同时代码更简洁、可读性更高，且更容易进行逻辑复用（自定义 Hook）。</p>
<h3 id="什么是-jsx它如何被处理">
  什么是 JSX？它如何被处理？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-jsx%e5%ae%83%e5%a6%82%e4%bd%95%e8%a2%ab%e5%a4%84%e7%90%86">#</a>
</h3>
<p><strong>JSX (JavaScript XML)</strong> 是一种 JavaScript 的语法扩展，它允许我们在 JavaScript 代码中编写类似 HTML 的结构。它并不是真正的 HTML，而是 React 提供的一种<strong>语法糖</strong>，用于描述 UI 的结构和组件之间的关系。</p>
<p><strong>JSX 的处理过程：</strong>
JSX 不会被浏览器直接识别。它会被 <strong>Babel 等转译工具</strong>编译成普通的 JavaScript 函数调用。例如：
<code>&lt;h1&gt;Hello, {name}!&lt;/h1&gt;</code> 会被编译成 <code>React.createElement('h1', null, 'Hello, ', name, '!');</code>
这些 <code>React.createElement</code> 调用会返回一个 JavaScript 对象（即 <strong>React 元素</strong>），描述了 UI 结构。React 再根据这些 React 元素构建虚拟 DOM。</p>
<h3 id="react-中的状态和-props-有什么区别">
  React 中的状态和 props 有什么区别？
  <a class="anchor" href="#react-%e4%b8%ad%e7%9a%84%e7%8a%b6%e6%80%81%e5%92%8c-props-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#</a>
</h3>
<p><strong>Props (Properties)</strong> 和 <strong>State (状态)</strong> 是 React 组件中用于存储数据并驱动 UI 更新的两个核心概念，但它们有本质区别：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特点</th>
          <th style="text-align: left">Props</th>
          <th style="text-align: left">State</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>所有者</strong></td>
          <td style="text-align: left">由父组件传递给子组件</td>
          <td style="text-align: left">组件自身管理</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>可变性</strong></td>
          <td style="text-align: left"><strong>不可变 (Immutable)</strong>：子组件不能直接修改父组件传递的 props</td>
          <td style="text-align: left"><strong>可变 (Mutable)</strong>：组件内部可以更新自己的 state</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>传递方式</strong></td>
          <td style="text-align: left">作为参数传递给组件</td>
          <td style="text-align: left">通过 <code>useState</code> (函数组件) 或 <code>this.setState</code> (类组件) 更新</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>目的</strong></td>
          <td style="text-align: left">用于组件间通信，配置组件外观和行为</td>
          <td style="text-align: left">存储组件内部随时间变化的数据，驱动自身 UI 更新</td>
      </tr>
  </tbody>
</table>
<h3 id="key-的作用是什么为什么不能用-index">
  key 的作用是什么？为什么不能用 index？
  <a class="anchor" href="#key-%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e7%94%a8-index">#</a>
</h3>
<p>在 React 渲染列表时，<strong><code>key</code> 是用于唯一标识列表中每个元素的特殊字符串属性。</strong> 它的主要作用是帮助 React <strong>高效地识别哪些元素发生了变化、被添加或被移除</strong>。</p>
<p><strong><code>key</code> 的工作原理：</strong>
当列表重新渲染时，React 会使用 <code>key</code> 来匹配旧列表中的元素和新列表中的元素。如果 <code>key</code> 相同，React 就认为它们是同一个组件/元素，会尝试复用它并只更新其内部属性；如果 <code>key</code> 不同，则会销毁旧组件并创建新组件。</p>
<p><strong>为什么不能用 <code>index</code> 作为 <code>key</code>？</strong>
当列表项的顺序可能会改变、新增或删除时，使用数组索引 (index) 作为 <code>key</code> 会导致问题：</p>
<ol>
<li><strong>性能问题：</strong> 当列表中间的某个元素被删除或插入时，后续元素的索引会发生变化。React 会错误地认为这些元素是新的，从而销用旧元素并重新创建新元素，导致不必要的 DOM 操作，影响性能。</li>
<li><strong>状态错乱：</strong> 如果列表项内部有自己的状态（如输入框的 value），使用 <code>index</code> 作为 <code>key</code> 可能会导致状态混淆。例如，删除中间项后，原先排在后面的元素会“接替”前面元素的索引，可能错误地继承了前面元素的状态。</li>
</ol>
<p><strong>最佳实践：</strong> 始终使用<strong>稳定且唯一</strong>的 <code>key</code>，通常是数据项本身的唯一 ID（如数据库 ID）。只有当列表是静态的、永不改变顺序和内容的，才考虑使用 <code>index</code> 作为 <code>key</code>，但通常不推荐。</p>
<h3 id="什么是受控组件和非受控组件">
  什么是受控组件和非受控组件？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%97%e6%8e%a7%e7%bb%84%e4%bb%b6%e5%92%8c%e9%9d%9e%e5%8f%97%e6%8e%a7%e7%bb%84%e4%bb%b6">#</a>
</h3>
<p>这两个概念主要用于 <strong>表单元素</strong> 的处理。</p>
<ul>
<li>
<p><strong>受控组件 (Controlled Components)：</strong></p>
<ul>
<li><strong>定义：</strong> 表单元素的值由 React <strong>组件的状态 (State)</strong> 来控制。每次输入框的值发生变化时，都会通过 <code>onChange</code> 事件更新组件的状态，然后状态的改变再反映到输入框上。</li>
<li><strong>特点：</strong>
<ul>
<li>表单数据由 React 组件管理，值完全同步。</li>
<li>更易于实现即时校验、条件禁用、格式化输入等功能。</li>
<li>代码相对更复杂一些，因为需要为每个输入框维护状态和 <code>onChange</code> 处理函数。</li>
</ul>
</li>
<li><strong>例子：</strong> <code>&lt;input type=&quot;text&quot; value={this.state.name} onChange={this.handleChange} /&gt;</code></li>
</ul>
</li>
<li>
<p><strong>非受控组件 (Uncontrolled Components)：</strong></p>
<ul>
<li><strong>定义：</strong> 表单元素的值不由 React 组件的状态控制，而是由 <strong>DOM 自身</strong>来管理。通常通过 <code>ref</code> 来直接访问 DOM 元素并获取其值。</li>
<li><strong>特点：</strong>
<ul>
<li>表单数据由 DOM 自身管理。</li>
<li>更接近传统的 HTML 表单行为。</li>
<li>代码相对简单，因为不需要维护大量状态。</li>
<li>但在复杂交互场景下，控制能力较弱。</li>
</ul>
</li>
<li><strong>例子：</strong> <code>&lt;input type=&quot;text&quot; ref={inputRef} /&gt;</code>，然后通过 <code>inputRef.current.value</code> 获取值。</li>
</ul>
</li>
</ul>
<p><strong>选择：</strong> 大多数情况下，<strong>受控组件</strong>更常用，因为它提供了更强大的控制能力和更清晰的数据流。非受控组件适用于一些简单的场景，或者需要集成非 React 的 DOM 库时。</p>
<hr>
<h2 id="-hooks">
  ⚙️ Hooks
  <a class="anchor" href="#-hooks">#</a>
</h2>
<hr>
<h3 id="usestate-和-useeffect-的用法与注意事项">
  useState 和 useEffect 的用法与注意事项？
  <a class="anchor" href="#usestate-%e5%92%8c-useeffect-%e7%9a%84%e7%94%a8%e6%b3%95%e4%b8%8e%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">#</a>
</h3>
<p><strong>1. <code>useState</code>：</strong></p>
<ul>
<li><strong>用法：</strong> ```javascript
const [state, setState] = useState(initialState);
<pre tabindex="0"><code>* `state`: 当前的状态值。
* `setState`: 更新状态的函数。
* `initialState`: 状态的初始值，可以是基本类型，也可以是函数（用于延迟初始化或复杂计算）。
</code></pre></li>
<li><strong>注意事项：</strong>
<ul>
<li><strong>不可变更新：</strong> <code>setState</code> 是异步的，并且应该始终用新值替换旧值，而不是直接修改旧值（即不可变更新）。例如，更新数组或对象时，应创建新数组/对象：<code>setArray([...array, newItem])</code> 或 <code>setObject({...object, key: value})</code>。</li>
<li><strong>函数式更新：</strong> 当新状态依赖于旧状态时，传入一个函数给 <code>setState</code> 更安全，可以避免闭包陷阱：<code>setCount(prevCount =&gt; prevCount + 1)</code>。</li>
<li><strong>批处理 (Batching)：</strong> 在 React 18 之前，<code>setState</code> 在事件处理函数中是批量更新的，在异步代码中是同步的。React 18 开始，所有 <code>setState</code> 调用默认都是批量更新的（自动批处理），无论是在事件处理函数中还是异步代码中，进一步提升性能。</li>
</ul>
</li>
</ul>
<p><strong>2. <code>useEffect</code>：</strong></p>
<ul>
<li><strong>用法：</strong> 用于处理组件的副作用 (side effects)，如数据获取、订阅、手动改变 DOM、定时器等。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 副作用代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 清理函数 (可选)，在组件卸载或依赖项改变前执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>}, [<span style="color:#a6e22e">dependencies</span>]); <span style="color:#75715e">// 依赖数组 (可选)
</span></span></span></code></pre></div></li>
<li><strong>注意事项：</strong>
<ul>
<li><strong>执行时机：</strong> <code>useEffect</code> 在每次渲染后（包括初次渲染和更新）执行，但会在浏览器完成布局和绘制之后。</li>
<li><strong>清理函数：</strong> 返回的函数用于清理副作用，例如取消订阅、清除定时器、移除事件监听。它会在组件卸载时或下次 <code>useEffect</code> 执行前（依赖项变化时）执行。</li>
<li><strong>依赖数组：</strong>
<ul>
<li><strong>空数组 <code>[]</code>：</strong> 副作用只在组件<strong>挂载时执行一次</strong>，清理函数在组件<strong>卸载时执行</strong>。模拟 <code>componentDidMount</code> 和 <code>componentWillUnmount</code>。</li>
<li><strong>无依赖数组：</strong> 副作用在每次组件<strong>渲染后都执行</strong>。慎用，可能导致性能问题。</li>
<li><strong>有依赖项 <code>[dep1, dep2]</code>：</strong> 副作用在<strong>依赖项发生变化时</strong>执行，清理函数在下次依赖项变化前或组件卸载时执行。模拟 <code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</li>
</ul>
</li>
<li><strong>闭包问题：</strong> 如果 <code>useEffect</code> 内部使用了组件外部的变量或函数，但没有将其包含在依赖数组中，可能会导致使用到旧的变量值，产生难以调试的 bug。</li>
</ul>
</li>
</ul>
<h3 id="如何模拟-componentdidmount--didupdate--willunmount">
  如何模拟 componentDidMount / DidUpdate / WillUnmount？
  <a class="anchor" href="#%e5%a6%82%e4%bd%95%e6%a8%a1%e6%8b%9f-componentdidmount--didupdate--willunmount">#</a>
</h3>
<ul>
<li><strong><code>componentDidMount</code>：</strong> 使用 <strong><code>useEffect</code>，并传入一个空数组作为依赖项</strong>。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;组件已挂载，只执行一次&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 数据请求、订阅等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}, []);
</span></span></code></pre></div></li>
<li><strong><code>componentDidUpdate</code>：</strong> 使用 <strong><code>useEffect</code>，并传入包含所有需要监听变化的依赖项</strong>。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;组件已更新，或者 count/name 改变了&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当 count 或 name 改变时执行逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}, [<span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">name</span>]);
</span></span></code></pre></div></li>
<li><strong><code>componentWillUnmount</code>：</strong> 使用 <strong><code>useEffect</code>，并在回调函数中返回一个清理函数</strong>。当依赖数组为空时，清理函数只在组件卸载时执行。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">timer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">setInterval</span>(() =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;定时器运行中...&#39;</span>);
</span></span><span style="display:flex;"><span>    }, <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">clearInterval</span>(<span style="color:#a6e22e">timer</span>); <span style="color:#75715e">// 在组件卸载时清除定时器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;组件即将卸载，清理工作已完成&#39;</span>);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}, []);
</span></span></code></pre></div></li>
</ul>
<h3 id="useeffect-依赖数组为什么不能随便省略">
  useEffect 依赖数组为什么不能随便省略？
  <a class="anchor" href="#useeffect-%e4%be%9d%e8%b5%96%e6%95%b0%e7%bb%84%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e9%9a%8f%e4%be%bf%e7%9c%81%e7%95%a5">#</a>
</h3>
<p><code>useEffect</code> 的依赖数组用于告诉 React 何时重新运行副作用函数。<strong>如果省略依赖数组（即不传第二个参数），<code>useEffect</code> 会在每次组件渲染后都执行，这通常会导致性能问题和逻辑错误</strong>，因为副作用可能会不必要地频繁运行。</p>
<p><strong>更重要的是，如果副作用函数内部使用了组件状态、props 或函数，但没有将它们列在依赖数组中，就会导致“闭包陷阱”：</strong>
副作用函数会捕获到首次渲染时的旧值，即使这些值在后续渲染中已经更新。这可能导致：</p>
<ul>
<li>使用过期的数据进行计算。</li>
<li>订阅或监听了旧的事件源。</li>
<li>内存泄漏（清理函数可能没有正确地清理掉旧的资源）。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Counter</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">setCount</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 错误：省略了依赖数组，effect 会使用第一次渲染时的 count = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 导致每次点击按钮，log 都会是 0，而不是最新的 count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Count is:&#39;</span>, <span style="color:#a6e22e">count</span>); <span style="color:#75715e">// 永远是 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }); <span style="color:#75715e">// ❌ 缺少依赖数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 正确：明确告诉 React 依赖 count，当 count 变化时重新执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Count is:&#39;</span>, <span style="color:#a6e22e">count</span>); <span style="color:#75715e">// 显示最新的 count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }, [<span style="color:#a6e22e">count</span>]); <span style="color:#75715e">// ✅ 包含了依赖项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{() =&gt; <span style="color:#a6e22e">setCount</span>(<span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)}<span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Increment</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/button&gt;;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>结论：</strong> 严格遵循 <code>useEffect</code> 的依赖项规则是避免各种难以调试的 bug 和性能问题的关键。</p>
<h3 id="如何用-useref-实现防抖或保存旧状态">
  如何用 useRef 实现防抖或保存旧状态？
  <a class="anchor" href="#%e5%a6%82%e4%bd%95%e7%94%a8-useref-%e5%ae%9e%e7%8e%b0%e9%98%b2%e6%8a%96%e6%88%96%e4%bf%9d%e5%ad%98%e6%97%a7%e7%8a%b6%e6%80%81">#</a>
</h3>
<p><strong>1. 用 <code>useRef</code> 实现防抖 (Debounce)：</strong>
<code>useRef</code> 可以用来存储一个在多次渲染之间持久存在的可变值，而不会引起组件重新渲染。这使其非常适合存储定时器 ID，以便在后续渲染中清除它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span>, { <span style="color:#a6e22e">useRef</span>, <span style="color:#a6e22e">useEffect</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DebouncedInput</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">setValue</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#e6db74">&#39;&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">timerRef</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useRef</span>(<span style="color:#66d9ef">null</span>); <span style="color:#75715e">// 存储定时器ID的ref
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 清理函数，在每次 effect 执行前和组件卸载时清除定时器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">timerRef</span>.<span style="color:#a6e22e">current</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">clearTimeout</span>(<span style="color:#a6e22e">timerRef</span>.<span style="color:#a6e22e">current</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>  }, []); <span style="color:#75715e">// 空数组，确保只在挂载和卸载时处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleChange</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">e</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">inputValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setValue</span>(<span style="color:#a6e22e">inputValue</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 清除上次的定时器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">timerRef</span>.<span style="color:#a6e22e">current</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">clearTimeout</span>(<span style="color:#a6e22e">timerRef</span>.<span style="color:#a6e22e">current</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置新的定时器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">timerRef</span>.<span style="color:#a6e22e">current</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Debounced value:&#39;</span>, <span style="color:#a6e22e">inputValue</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 在这里执行实际的搜索或API调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }, <span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">input</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text&#34;</span> <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">value</span>} <span style="color:#a6e22e">onChange</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">handleChange</span>} <span style="color:#a6e22e">placeholder</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Type to debounce...&#34;</span> <span style="color:#f92672">/&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>2. 用 <code>useRef</code> 保存旧状态：</strong>
<code>useRef</code> 也可以用来保存上一次渲染时的状态值，因为 <code>ref.current</code> 在渲染之间是持久的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span>, { <span style="color:#a6e22e">useState</span>, <span style="color:#a6e22e">useEffect</span>, <span style="color:#a6e22e">useRef</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">PreviousValueDisplay</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">setCount</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">prevCountRef</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useRef</span>(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 初始化ref来存储旧值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 在每次渲染后，将当前 count 存储到 ref 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">prevCountRef</span>.<span style="color:#a6e22e">current</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>  }); <span style="color:#75715e">// 没有依赖数组，每次渲染后都执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">prevCount</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">prevCountRef</span>.<span style="color:#a6e22e">current</span>; <span style="color:#75715e">// 获取上一次渲染时的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Current</span> <span style="color:#a6e22e">Count</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">count</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/p&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Previous</span> <span style="color:#a6e22e">Count</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">prevCount</span>}<span style="color:#f92672">&lt;</span><span style="color:#e6db74">/p&gt; {/</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">这里的</span> <span style="color:#a6e22e">prevCount</span> <span style="color:#a6e22e">是上一次渲染的</span> <span style="color:#a6e22e">count</span> <span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">/}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{() =&gt; <span style="color:#a6e22e">setCount</span>(<span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)}<span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Increment</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/button&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在 React 16.8+ 中，使用 <code>useRef</code> 是保存跨渲染周期可变值的标准方式。</p>
<h3 id="usecallback-vs-usememo-区别">
  useCallback vs useMemo 区别？
  <a class="anchor" href="#usecallback-vs-usememo-%e5%8c%ba%e5%88%ab">#</a>
</h3>
<p><code>useCallback</code> 和 <code>useMemo</code> 都是 React Hooks，用于<strong>性能优化</strong>，通过<strong>记忆化 (memoization)</strong> 避免不必要的计算和渲染。</p>
<ul>
<li>
<p><strong><code>useCallback</code>：</strong></p>
<ul>
<li><strong>目的：</strong> <strong>记忆化一个函数</strong>，返回一个被记忆化的回调函数。</li>
<li><strong>语法：</strong> <code>const memoizedCallback = useCallback(() =&gt; { /* ... */ }, [dependencies]);</code></li>
<li><strong>作用：</strong> 当依赖项数组中的值没有发生变化时，<code>useCallback</code> 会返回上次渲染时创建的函数实例。这对于将函数作为 <code>props</code> 传递给子组件（特别是使用了 <code>React.memo</code> 优化的子组件）非常有用，可以防止子组件不必要的重新渲染。</li>
<li><strong>使用场景：</strong> 传递给子组件的回调函数、<code>useEffect</code> 的依赖项（当函数本身是 <code>useEffect</code> 的依赖时）。</li>
</ul>
</li>
<li>
<p><strong><code>useMemo</code>：</strong></p>
<ul>
<li><strong>目的：</strong> <strong>记忆化一个值</strong>（可以是任何类型的值，包括一个 JSX 片段、一个对象、一个计算结果等），返回一个被记忆化的值。</li>
<li><strong>语法：</strong> <code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</code></li>
<li><strong>作用：</strong> 当依赖项数组中的值没有发生变化时，<code>useMemo</code> 会返回上次计算得到的值，避免重复执行昂贵的计算。</li>
<li><strong>使用场景：</strong> 昂贵的计算结果、派生状态、复杂的 JSX 渲染、传递给子组件的复杂对象。</li>
</ul>
</li>
</ul>
<p><strong>总结区别：</strong></p>
<ul>
<li><strong><code>useCallback</code> 记忆的是一个</strong>函数**。</li>
<li><strong><code>useMemo</code> 记忆的是一个</strong>值**。</li>
</ul>
<p><strong>例子：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span>, { <span style="color:#a6e22e">useState</span>, <span style="color:#a6e22e">useCallback</span>, <span style="color:#a6e22e">useMemo</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 子组件，假设它被 React.memo 优化，只有 props 改变时才渲染
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ChildComponent</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">React</span>.<span style="color:#a6e22e">memo</span>(({ <span style="color:#a6e22e">onClick</span>, <span style="color:#a6e22e">data</span> }) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;ChildComponent re-rendered&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">onClick</span>}<span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Click</span> <span style="color:#a6e22e">me</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/button&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span>{<span style="color:#a6e22e">data</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/p&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ParentComponent</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">setCount</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">setName</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#e6db74">&#39;Alice&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 使用 useCallback 记忆函数：只有当 count 改变时，handleClick 才重新创建
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleClick</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useCallback</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setCount</span>(<span style="color:#a6e22e">c</span> =&gt; <span style="color:#a6e22e">c</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }, [<span style="color:#a6e22e">count</span>]); <span style="color:#75715e">// 如果 count 是依赖项，当 count 变化时，handleClick 会被重新创建
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 使用 useMemo 记忆值：只有当 name 改变时，expensiveData 才重新计算
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">expensiveData</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useMemo</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Calculating expensive data...&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`Hello, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">! The count is </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">count</span><span style="color:#e6db74">}</span><span style="color:#e6db74">.`</span>;
</span></span><span style="display:flex;"><span>  }, [<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">count</span>]); <span style="color:#75715e">// 如果 name 或 count 改变，expensiveData 会重新计算
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Count</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">count</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/p&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">input</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text&#34;</span> <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">name</span>} <span style="color:#a6e22e">onChange</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">e</span> =&gt; <span style="color:#a6e22e">setName</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">value</span>)} <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>      {<span style="color:#75715e">/* 即使 ParentComponent 重新渲染，如果 handleClick 没有变，ChildComponent 也不会渲染 */</span>}
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">ChildComponent</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">handleClick</span>} <span style="color:#a6e22e">data</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">expensiveData</span>} <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="自定义-hook-怎么写实际项目中写过哪些">
  自定义 Hook 怎么写？实际项目中写过哪些？
  <a class="anchor" href="#%e8%87%aa%e5%ae%9a%e4%b9%89-hook-%e6%80%8e%e4%b9%88%e5%86%99%e5%ae%9e%e9%99%85%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%86%99%e8%bf%87%e5%93%aa%e4%ba%9b">#</a>
</h3>
<p><strong>自定义 Hook</strong> 是一种将组件逻辑抽取出来并<strong>在函数组件之间共享</strong>的机制。它本质上是一个 JavaScript 函数，其名称约定以 <code>use</code> 开头，并且可以在其中调用其他 Hook（如 <code>useState</code>, <code>useEffect</code>, <code>useRef</code> 等）。</p>
<p><strong>怎么写？</strong></p>
<ol>
<li><strong>创建一个 JavaScript 函数：</strong> 名称以 <code>use</code> 开头（这是 React 的约定，用于让 Linter 识别并遵循 Hook 规则）。</li>
<li><strong>在函数内部使用其他 Hook：</strong> 例如 <code>useState</code> 来管理内部状态，<code>useEffect</code> 来处理副作用等。</li>
<li><strong>返回需要共享的状态和方法：</strong> 可以返回一个数组、对象或任何值。</li>
</ol>
<p><strong>示例：<code>useToggle</code></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">useState</span>, <span style="color:#a6e22e">useCallback</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">useToggle</span>(<span style="color:#a6e22e">initialValue</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">setValue</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#a6e22e">initialValue</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">toggle</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useCallback</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setValue</span>(<span style="color:#a6e22e">prevValue</span> =&gt; <span style="color:#f92672">!</span><span style="color:#a6e22e">prevValue</span>);
</span></span><span style="display:flex;"><span>  }, []); <span style="color:#75715e">// 依赖项为空数组，确保 toggle 函数引用不变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">toggle</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如何使用：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// function MyComponent() {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   const [isOn, toggle] = useToggle(false);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   return &lt;button onClick={toggle}&gt;{isOn ? &#39;On&#39; : &#39;Off&#39;}&lt;/button&gt;;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// }
</span></span></span></code></pre></div><p><strong>实际项目中写过哪些？</strong>
（这里你需要根据你自己的项目经验来回答，下面是常见的一些例子）</p>
<ul>
<li><strong><code>useLocalStorage</code> / <code>useSessionStorage</code>：</strong> 用于将状态与浏览器本地存储同步。</li>
<li><strong><code>useDebounce</code> / <code>useThrottle</code>：</strong> 用于对输入、滚动等事件进行防抖/节流处理。</li>
<li><strong><code>usePrevious</code>：</strong> 用于获取上一次渲染时的某个状态或 prop 的值。</li>
<li><strong><code>useForm</code> / <code>useFormValidation</code>：</strong> 封装表单的状态管理、校验逻辑。</li>
<li><strong><code>useClickOutside</code>：</strong> 检测元素外部点击事件，常用于实现下拉菜单或弹窗的点击外部关闭功能。</li>
<li><strong><code>useFetch</code> / <code>useApi</code>：</strong> 封装数据请求逻辑，包括加载状态、错误处理、取消请求、缓存等。</li>
<li><strong><code>useIntersectionObserver</code>：</strong> 用于实现图片懒加载、无限滚动等。</li>
<li><strong><code>useClipboard</code>：</strong> 复制内容到剪贴板。</li>
</ul>
<p><strong>自定义 Hook 的好处：</strong></p>
<ul>
<li><strong>逻辑复用：</strong> 避免在不同组件中重复编写相同的状态逻辑。</li>
<li><strong>关注点分离：</strong> 将状态逻辑从 UI 渲染中分离，使组件更专注于渲染。</li>
<li><strong>提高可读性：</strong> 组件代码更简洁，易于理解。</li>
<li><strong>易于测试：</strong> 独立的逻辑更容易进行单元测试。</li>
</ul>
<hr>
<h2 id="-性能优化与架构">
  🚀 性能优化与架构
  <a class="anchor" href="#-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e4%b8%8e%e6%9e%b6%e6%9e%84">#</a>
</h2>
<hr>
<h3 id="react-中有哪些性能优化方法">
  React 中有哪些性能优化方法？
  <a class="anchor" href="#react-%e4%b8%ad%e6%9c%89%e5%93%aa%e4%ba%9b%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%96%b9%e6%b3%95">#</a>
</h3>
<p>React 性能优化是一个综合性的课题，涉及多个层面：</p>
<ol>
<li>
<p><strong>减少不必要的重新渲染 (Re-renders)：</strong></p>
<ul>
<li><strong><code>React.memo</code> (函数组件) / <code>PureComponent</code> (类组件)：</strong> 对组件进行浅层比较，如果 <code>props</code> 没有变化，则跳过组件的重新渲染。</li>
<li><strong><code>useCallback</code> 和 <code>useMemo</code> Hooks：</strong> 记忆化函数和计算结果，避免子组件因父组件传递的函数/对象引用变化而重复渲染。</li>
<li><strong>合理使用 <code>shouldComponentUpdate</code> (类组件)：</strong> 手动控制组件是否重新渲染（但 Hooks 时代更推荐 <code>React.memo</code>）。</li>
<li><strong>状态提升和组件拆分：</strong> 将不影响某个组件渲染的状态和逻辑提升到父组件或拆分到更小的、独立的组件中，减少单个组件的渲染范围。</li>
<li><strong>Key 的正确使用：</strong> 在渲染列表时使用稳定且唯一的 <code>key</code>，帮助 React 正确识别和复用元素。</li>
</ul>
</li>
<li>
<p><strong>数据层优化：</strong></p>
<ul>
<li><strong>数据不可变性 (Immutable Data)：</strong> 避免直接修改状态，始终创建新的数据副本进行更新。这使得 React 的 Diff 算法能够进行更高效的浅比较。可以使用 Immer 等库简化不可变更新。</li>
<li><strong>合理使用缓存：</strong> 在数据请求层（如使用 <code>react-query</code>）或应用层使用缓存，减少重复的网络请求。</li>
</ul>
</li>
<li>
<p><strong>首次加载性能优化：</strong></p>
<ul>
<li><strong>代码分割 (Code Splitting) 和懒加载 (Lazy Loading)：</strong> 使用 <code>React.lazy</code> 和 <code>Suspense</code> 或动态 <code>import()</code>，按需加载组件和代码，减少初始包体积。</li>
<li><strong>图片优化：</strong> 压缩图片、使用 WebP 格式、图片懒加载。</li>
<li><strong>CDN：</strong> 静态资源使用 CDN 加速。</li>
<li><strong>Gzip/Brotli 压缩：</strong> 服务器端开启资源压缩。</li>
</ul>
</li>
<li>
<p><strong>UI 渲染优化：</strong></p>
<ul>
<li><strong>列表虚拟化 (Virtualization) / 窗口化 (Windowing)：</strong> 对于包含大量数据项的长列表，只渲染可见区域内的列表项，大幅提升性能。</li>
<li><strong>避免在渲染函数中执行昂贵的计算：</strong> 将昂贵的计算放入 <code>useMemo</code> 或移到组件外部。</li>
<li><strong>避免在循环中创建组件：</strong> 尽可能避免在循环内定义函数或组件，这会导致不必要的创建和重新渲染。</li>
</ul>
</li>
<li>
<p><strong>其他：</strong></p>
<ul>
<li><strong>使用生产环境构建：</strong> 生产环境的 React 构建会移除开发环境的调试代码和警告，体积更小，运行更快。</li>
<li><strong>Lighthouse / React DevTools Profiler：</strong> 使用这些工具进行性能分析，找出瓶颈。</li>
</ul>
</li>
</ol>
<h3 id="什么是虚拟化virtualization用过哪些库">
  什么是虚拟化（virtualization）？用过哪些库？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%99%9a%e6%8b%9f%e5%8c%96virtualization%e7%94%a8%e8%bf%87%e5%93%aa%e4%ba%9b%e5%ba%93">#</a>
</h3>
<p><strong>虚拟化（Virtualization），也称为“窗口化（Windowing）”</strong>，是一种针对长列表（包含大量数据项的列表）的性能优化技术。其核心思想是：<strong>只渲染当前在用户视口（即屏幕可见区域）内的列表项，对于视口外的大量列表项，只计算其占位高度，而不实际渲染它们的内容。</strong> 当用户滚动时，动态地渲染和销毁列表项。</p>
<p><strong>优势：</strong> 大幅减少 DOM 节点的数量，降低浏览器渲染压力，提升长列表的滚动性能和页面响应速度。</p>
<p><strong>用过的库：</strong></p>
<ul>
<li><strong><code>react-window</code>：</strong> 轻量级、高性能的 React 列表虚拟化库，由 <code>react-virtualized</code> 作者开发。它提供了固定高度/宽度列表、可变高度/宽度列表、网格等组件。我经常用它来处理需要展示几百到几万条数据的表格或列表，效果非常显著。</li>
<li><strong><code>react-virtualized</code>：</strong> 功能更强大、更全面的虚拟化库，但相对 <code>react-window</code> 更重一些。它提供了更多高级功能，如自动调整行高、滚动到指定位置等。</li>
</ul>
<p><strong>实际应用场景：</strong></p>
<ul>
<li>数据表格（如展示大量用户数据、日志记录）。</li>
<li>聊天记录、信息流。</li>
<li>股票行情、监控面板等实时数据展示。</li>
</ul>
<h3 id="如何避免子组件重复渲染">
  如何避免子组件重复渲染？
  <a class="anchor" href="#%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e5%ad%90%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93">#</a>
</h3>
<p>避免子组件重复渲染是 React 性能优化的关键点之一。主要方法包括：</p>
<ol>
<li>
<p><strong>使用 <code>React.memo</code> (针对函数组件)：</strong></p>
<ul>
<li>这是最常用的方法。<code>React.memo</code> 是一个高阶组件 (HOC)，它会浅层比较组件的 <code>props</code>。如果 <code>props</code> 没有改变，组件就不会重新渲染。</li>
<li><strong>示例：</strong> <code>const MyMemoizedComponent = React.memo(MyComponent);</code></li>
<li><strong>注意事项：</strong> 对于 <code>props</code> 中的函数和对象，如果它们在父组件每次渲染时都重新创建，那么 <code>React.memo</code> 仍然会判断 <code>props</code> 改变，导致子组件重新渲染。此时需要配合 <code>useCallback</code> 和 <code>useMemo</code>。</li>
</ul>
</li>
<li>
<p><strong>使用 <code>useCallback</code> 和 <code>useMemo</code> (针对函数组件的 <code>props</code>)：</strong></p>
<ul>
<li><strong><code>useCallback</code>：</strong> 记忆化传递给子组件的<strong>回调函数</strong>。确保当父组件重新渲染时，如果函数的依赖没有改变，函数引用不会改变，从而避免 <code>React.memo</code> 的子组件重新渲染。</li>
<li><strong><code>useMemo</code>：</strong> 记忆化传递给子组件的<strong>对象、数组或昂贵的计算结果</strong>。确保当父组件重新渲染时，如果值的依赖没有改变，对象/数组引用不会改变，从而避免 <code>React.memo</code> 的子组件重新渲染。</li>
<li><strong>示例：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleClick</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useCallback</span>(() =&gt; { <span style="color:#75715e">/* ... */</span> }, [<span style="color:#a6e22e">dependency</span>]);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useMemo</span>(() =&gt; ({ <span style="color:#75715e">/* ... */</span> }), [<span style="color:#a6e22e">dependency</span>]);
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">MemoizedChild</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">handleClick</span>} <span style="color:#a6e22e">data</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">data</span>} <span style="color:#f92672">/&gt;</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>使用 <code>PureComponent</code> (针对类组件)：</strong></p>
<ul>
<li><code>PureComponent</code> 实现了 <code>shouldComponentUpdate</code> 方法，它也会对 <code>props</code> 和 <code>state</code> 进行浅层比较。如果两者都没有改变，组件将不会重新渲染。</li>
<li><strong>注意事项：</strong> 与 <code>React.memo</code> 类似，也存在函数和对象引用导致的问题。</li>
</ul>
</li>
<li>
<p><strong>状态提升和组件拆分：</strong></p>
<ul>
<li>将不影响子组件渲染的状态和逻辑向上提升到共同的父组件，或者将复杂组件拆分成更小的、独立的组件。这样，当局部状态变化时，只会引起相关的小组件重新渲染，而不是整个大组件树。</li>
</ul>
</li>
<li>
<p><strong>避免在渲染方法中定义函数或组件：</strong></p>
<ul>
<li>在 <code>render</code> 方法（类组件）或函数组件内部直接定义函数或组件，会导致每次渲染都创建新的引用，即使它们逻辑相同，也会导致 <code>props</code> 变化，从而强制子组件重新渲染。</li>
</ul>
</li>
</ol>
<h3 id="什么是代码分割code-splitting">
  什么是代码分割（Code Splitting）？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%bb%a3%e7%a0%81%e5%88%86%e5%89%b2code-splitting">#</a>
</h3>
<p><strong>代码分割 (Code Splitting)</strong> 是一种优化技术，它将应用程序的代码<strong>拆分成更小的、按需加载的块 (chunks)</strong>，而不是一次性加载整个应用程序的所有代码。这有助于显著减少初始加载时下载的代码量，从而提升应用的启动速度。</p>
<p><strong>原理：</strong> 通常与构建工具（如 Webpack、Rollup）配合使用，它们在打包时会根据配置或语法约定将代码分割成多个独立的 JavaScript 文件。</p>
<p><strong>优势：</strong></p>
<ul>
<li><strong>更快的初始加载时间 (TTI)：</strong> 用户只需下载当前页面所需的代码。</li>
<li><strong>更好的用户体验：</strong> 页面更快响应，尤其在网络条件不佳时。</li>
<li><strong>有效利用浏览器缓存：</strong> 不同的代码块可以独立缓存，当代码更新时，用户只需要下载发生变化的块。</li>
</ul>
<h3 id="组件懒加载如何实现reactlazy-vs-动态导入">
  组件懒加载如何实现？React.lazy vs 动态导入
  <a class="anchor" href="#%e7%bb%84%e4%bb%b6%e6%87%92%e5%8a%a0%e8%bd%bd%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0reactlazy-vs-%e5%8a%a8%e6%80%81%e5%af%bc%e5%85%a5">#</a>
</h3>
<p><strong>组件懒加载</strong> 是代码分割的一种具体实现，它允许我们<strong>延迟加载组件的代码</strong>，直到它们实际被渲染时才去下载。</p>
<p><strong>实现方式：</strong></p>
<ol>
<li>
<p><strong><code>React.lazy</code> (推荐用于 React 组件)：</strong></p>
<ul>
<li><code>React.lazy</code> 是 React 提供的一个内置函数，它允许你像渲染常规组件一样渲染一个动态导入的组件。它接收一个函数作为参数，这个函数会返回一个 <code>Promise</code>，该 Promise <code>resolve</code> 为一个 React 组件（即 <code>default export</code>）。</li>
<li>通常与 <code>Suspense</code> 组件一起使用，<code>Suspense</code> 可以在懒加载组件加载过程中显示一个回退 UI（如加载指示器）。</li>
<li><strong>语法：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span>, { <span style="color:#a6e22e">lazy</span>, <span style="color:#a6e22e">Suspense</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">MyLazyComponent</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">lazy</span>(() =&gt; <span style="color:#66d9ef">import</span>(<span style="color:#e6db74">&#39;./MyComponent&#39;</span>)); <span style="color:#75715e">// 动态导入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">App</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">h1</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Welcome</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/h1&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Suspense</span> <span style="color:#a6e22e">fallback</span><span style="color:#f92672">=</span>{<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Loading</span> <span style="color:#a6e22e">MyLazyComponent</span>...<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;}&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">MyLazyComponent</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/Suspense&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li><strong>特点：</strong> 专门为 React 组件设计，易于集成，且与 React 的并发模式兼容。</li>
</ul>
</li>
<li>
<p><strong>动态 <code>import()</code> (通常与 Webpack 等构建工具配合)：</strong></p>
<ul>
<li><code>import()</code> 是 ECMAScript 的一个提案，它允许在运行时动态地导入模块。它返回一个 Promise，Promise resolved 后会得到模块对象。</li>
<li>虽然 <code>React.lazy</code> 在底层就是使用了动态 <code>import()</code>，但我们也可以直接使用 <code>import()</code> 来实现更通用的代码分割，例如加载非组件的模块、工具函数或路由级别代码。</li>
<li><strong>语法：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 动态导入一个模块，不一定是React组件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span>(<span style="color:#e6db74">&#39;./utils&#39;</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">module</span> =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">someFunction</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">module</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">someFunction</span>();
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div></li>
<li><strong>与 <code>React.lazy</code> 结合：</strong> <code>React.lazy</code> 的参数 <code>() =&gt; import('./MyComponent')</code> 就是一个动态导入。</li>
</ul>
</li>
</ol>
<p><strong>选择：</strong></p>
<ul>
<li>对于<strong>React 组件</strong>的懒加载，<strong><code>React.lazy</code> + <code>Suspense</code> 是首选</strong>，它提供了简洁的 API 和内置的回退机制。</li>
<li>对于<strong>非组件的 JavaScript 模块</strong>的按需加载，或者需要更细粒度控制加载时机的场景，可以直接使用<strong>动态 <code>import()</code></strong>。</li>
</ul>
<hr>
<h2 id="-状态管理">
  🔄 状态管理
  <a class="anchor" href="#-%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86">#</a>
</h2>
<hr>
<h3 id="你项目中如何管理组件间状态">
  你项目中如何管理组件间状态？
  <a class="anchor" href="#%e4%bd%a0%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%a6%82%e4%bd%95%e7%ae%a1%e7%90%86%e7%bb%84%e4%bb%b6%e9%97%b4%e7%8a%b6%e6%80%81">#</a>
</h3>
<p>在我的项目中，组件间状态管理会根据项目的规模和复杂性采取不同的策略：</p>
<ol>
<li><strong>就近原则 / 状态提升 (State Hoisting)：</strong> 对于简单的父子组件通信，我会优先将共享状态提升到最近的共同祖先组件中，然后通过 <code>props</code> 传递给子组件。这适用于局部性强、跨组件层级不深的状态。</li>
<li><strong>Context API (useContext)：</strong> 对于一些需要全局共享但变化不频繁的状态（如主题模式、用户信息、语言设置），我会使用 React 的 <code>Context API</code>。它避免了 <code>props drilling</code>（层层传递 props）的问题，使状态在组件树中“直达”需要它的组件。</li>
<li><strong>Redux (或其变体，如 Redux Toolkit)：</strong> 对于中大型、复杂的应用，或者需要处理大量异步操作、可预测状态管理、时间旅行调试等场景，我会采用 Redux。它提供了一个单一的、集中的状态树，通过 action 和 reducer 严格控制状态的变更。
<ul>
<li>我通常会使用 <strong>Redux Toolkit</strong>，因为它简化了 Redux 的配置和样板代码，内置了 <code>RTK Query</code>，能更好地处理数据请求和缓存。</li>
</ul>
</li>
<li><strong>Hooks 结合自定义 Hook：</strong> 对于一些可复用的、具有特定业务逻辑的状态（如表单校验、数据请求状态），我会将其封装成<strong>自定义 Hook</strong>，以便在不同组件中共享逻辑，而不需要共享全局状态。</li>
<li><strong>组件内部状态 (useState)：</strong> 对于组件私有的、不与其他组件共享的状态，就直接使用 <code>useState</code>。</li>
</ol>
<p><strong>我的选择逻辑是：</strong> 优先选择最简单的方案，当复杂度增加时，逐步升级状态管理方案。避免过度设计，但也要为未来的扩展留有余地。</p>
<h3 id="redux-工作原理">
  Redux 工作原理？
  <a class="anchor" href="#redux-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86">#</a>
</h3>
<p>Redux 是一个可预测的 JavaScript <strong>状态容器</strong>，主要用于管理应用程序的全局状态。它的核心原则是：<strong>单一数据源、状态只读、纯函数变更</strong>。</p>
<p><strong>Redux 的核心组件和工作原理：</strong></p>
<ol>
<li>
<p><strong>Store (单一数据源)：</strong></p>
<ul>
<li>整个应用程序的 <strong>所有状态</strong> 都存储在一个单一的 JavaScript 对象树中，这个对象树就是 Store。</li>
<li>它由 <code>createStore</code> 创建。</li>
<li>Store 包含 <code>getState()</code>、<code>dispatch(action)</code> 和 <code>subscribe(listener)</code> 等方法。</li>
</ul>
</li>
<li>
<p><strong>Action (意图的描述)：</strong></p>
<ul>
<li>是一个普通的 JavaScript 对象，用于<strong>描述发生了什么事件</strong>。</li>
<li>必须包含一个 <code>type</code> 字段，表示事件类型。</li>
<li>可以包含其他任意数据，即 <code>payload</code>。</li>
<li><strong>例子：</strong> <code>{ type: 'ADD_TODO', payload: { id: 1, text: 'Learn Redux' } }</code></li>
</ul>
</li>
<li>
<p><strong>Reducer (纯函数)：</strong></p>
<ul>
<li>是一个<strong>纯函数</strong>，接收当前 <code>state</code> 和一个 <code>action</code> 作为参数。</li>
<li>根据 <code>action.type</code> 来<strong>计算并返回一个新的 state</strong>。</li>
<li><strong>核心原则：</strong> 必须是纯函数（不修改原始 state，无副作用），对相同的输入永远返回相同的输出。</li>
<li><strong>例子：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">todosReducer</span>(<span style="color:#a6e22e">state</span> <span style="color:#f92672">=</span> [], <span style="color:#a6e22e">action</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (<span style="color:#a6e22e">action</span>.<span style="color:#a6e22e">type</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;ADD_TODO&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> [...<span style="color:#a6e22e">state</span>, <span style="color:#a6e22e">action</span>.<span style="color:#a6e22e">payload</span>]; <span style="color:#75715e">// 返回新数组，不修改原数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">state</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>Dispatch (触发更新)：</strong></p>
<ul>
<li>是 Store 的一个方法。用于<strong>发送 (dispatch) 一个 action</strong>。</li>
<li>这是唯一能触发状态更新的方式。</li>
</ul>
</li>
</ol>
<p><strong>工作流程：</strong></p>
<ol>
<li><strong>用户交互</strong>（例如，点击按钮）。</li>
<li>组件调用 <code>store.dispatch(action)</code> 发送一个 <strong>Action</strong>。</li>
<li>Store 接收到 Action 后，会将当前 <strong>State</strong> 和该 Action 一起传递给 <strong>Reducer</strong>。</li>
<li>Reducer 根据 Action 类型，计算出新的 State，并<strong>返回新的 State</strong>。</li>
<li>Store 接收到新的 State 后，会更新其内部状态，并通知所有 <strong>订阅者 (subscribers)</strong>。</li>
<li>订阅者（通常是 React 组件）接收到通知后，会获取新的 State，并触发自身重新渲染，更新 UI。</li>
</ol>
<p><strong>总结：</strong> Redux 强制单向数据流和严格的状态变更模式，使得状态的变化可预测、可追踪，便于调试和维护。</p>
<h3 id="usecontext-有哪些适用场景能替代-redux-吗">
  useContext 有哪些适用场景？能替代 Redux 吗？
  <a class="anchor" href="#usecontext-%e6%9c%89%e5%93%aa%e4%ba%9b%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af%e8%83%bd%e6%9b%bf%e4%bb%a3-redux-%e5%90%97">#</a>
</h3>
<p><strong><code>useContext</code> 的适用场景：</strong>
<code>useContext</code> Hook 结合 <code>React.createContext</code> 提供了一种在组件树中共享数据的方式，而无需通过 props 逐层手动传递。它主要适用于：</p>
<ol>
<li><strong>全局不频繁变化的数据：</strong> 例如主题（亮/暗模式）、用户认证信息、语言设置、全局配置等。</li>
<li><strong>避免 Props Drilling (属性逐层传递)：</strong> 当你需要在组件树中深层嵌套的子组件访问某个数据时，避免了父组件到子组件一层层传递 props 的繁琐。</li>
<li><strong>组件库/UI 框架内部的状态管理：</strong> 许多组件库会使用 Context 来管理其内部组件的主题、尺寸等配置。</li>
</ol>
<p><strong><code>useContext</code> 能替代 Redux 吗？</strong>
<strong>通常情况下，<code>useContext</code> 难以完全替代 Redux，尤其是在中大型和复杂应用中。</strong> 它们解决的问题和侧重点有所不同：</p>
<ul>
<li>
<p><strong><code>useContext</code> 优势：</strong></p>
<ul>
<li>API 简单，学习成本低。</li>
<li>适用于共享相对静态或不频繁变化的数据。</li>
<li>代码量少，适合小型项目或特定功能的局部状态共享。</li>
</ul>
</li>
<li>
<p><strong><code>useContext</code> 的局限性（相对于 Redux）：</strong></p>
<ol>
<li><strong>性能问题：</strong> 当 Context Provider 中的值发生变化时，所有消费该 Context 的组件（即使其 <code>props</code> 或 <code>state</code> 没有直接变化）都会重新渲染。如果 Context 中包含频繁变化的数据，会导致大量不必要的渲染。Redux 通常会配合 <code>react-redux</code> 的 <code>connect</code> 或 <code>useSelector</code> 进行性能优化，只在实际需要的状态部分变化时才触发组件渲染。</li>
<li><strong>状态变更逻辑分散：</strong> Context 本身只负责传递数据，不提供强制的状态变更模式（如 Reducer）。当状态逻辑变得复杂时，可能会导致变更逻辑分散在多个组件中，难以追踪和调试。</li>
<li><strong>缺乏开发者工具支持：</strong> Redux 有强大的开发者工具，可以时间旅行调试、查看每次状态变更，这在大型应用中是巨大的优势。Context 没有开箱即用的类似工具。</li>
<li><strong>异步操作复杂：</strong> Context 处理异步操作相对不便，通常需要结合 <code>useEffect</code> 和 <code>useState</code> 来手动管理加载、错误等状态。Redux 有 <code>redux-thunk</code> 或 <code>redux-saga</code> 等中间件来处理复杂的异步流。</li>
</ol>
</li>
</ul>
<p><strong>结论：</strong></p>
<ul>
<li><strong>小型应用或简单全局状态：</strong> <code>useContext</code> 是一个非常好的选择，它简单高效。</li>
<li><strong>中大型或复杂应用：</strong> Redux（尤其是 Redux Toolkit）仍然是更健壮、可维护性更高、调试更方便的选择。</li>
<li><strong>最佳实践：</strong> 可以将两者结合使用。例如，用 <code>useContext</code> 管理主题等不常变且性能影响小的数据；用 Redux 管理核心业务数据和复杂的异步状态。</li>
</ul>
<h3 id="redux-中-thunk--saga-的作用">
  Redux 中 thunk / saga 的作用？
  <a class="anchor" href="#redux-%e4%b8%ad-thunk--saga-%e7%9a%84%e4%bd%9c%e7%94%a8">#</a>
</h3>
<p>在 Redux 中，<strong><code>thunk</code> 和 <code>saga</code> 都是处理异步副作用 (Side Effects) 的中间件</strong>，因为 Redux 的 Reducer 必须是纯函数，不能直接处理异步操作。</p>
<ul>
<li>
<p><strong>Redux Thunk (redux-thunk)：</strong></p>
<ul>
<li><strong>作用：</strong> 允许 <code>dispatch</code> 一个<strong>函数</strong>（而不是普通对象 action）。这个函数接收 <code>dispatch</code> 和 <code>getState</code> 作为参数，可以在其中执行异步操作，并在异步操作完成后再次 <code>dispatch</code> 普通的 action 来更新状态。</li>
<li><strong>原理：</strong> 它非常简单，通过检测 <code>dispatch</code> 的参数是否是函数。如果是函数，就执行这个函数，并将 <code>dispatch</code> 和 <code>getState</code> 传入；如果不是函数，就直接传递给下一个中间件或 Reducer。</li>
<li><strong>特点：</strong>
<ul>
<li><strong>简单易学：</strong> 代码量少，理解成本低。</li>
<li><strong>直接：</strong> 异步逻辑直接写在 <code>thunk</code> 函数中，符合 JavaScript 习惯。</li>
<li><strong>适合：</strong> 简单的异步操作（如单个 API 调用）、一次性的异步流程。</li>
</ul>
</li>
<li><strong>缺点：</strong> 随着异步逻辑复杂（如多个异步操作的串联、取消操作），代码可能变得难以维护和测试（回调地狱）。</li>
</ul>
</li>
<li>
<p><strong>Redux Saga (redux-saga)：</strong></p>
<ul>
<li><strong>作用：</strong> 使用 ES6 的 <strong>Generator 函数</strong>来处理异步副作用。它将异步操作视为一系列的 <strong>Effects</strong>（如 <code>call</code>、<code>put</code>、<code>take</code>、<code>select</code>），这些 Effects 是纯 JS 对象，由 Saga Middleware 解释执行。</li>
<li><strong>原理：</strong> <code>redux-saga</code> 创建一个独立的“进程”（Generator 函数），与主应用进程并行运行，通过监听 Redux Actions 来触发异步任务。它使用 <code>yield</code> 关键字来暂停和恢复异步操作，使得异步流程看起来像同步代码。</li>
<li><strong>特点：</strong>
<ul>
<li><strong>声明式、命令式兼顾：</strong> 异步流程更易于阅读和测试（因为 Effects 都是纯 JS 对象）。</li>
<li><strong>强大的功能：</strong> 提供强大的并发控制、任务取消、竞态条件处理、错误处理等机制。</li>
<li><strong>复杂性：</strong> 学习成本相对较高，需要理解 Generator 函数和 Saga Effect。</li>
<li><strong>适合：</strong> 复杂的异步流程、需要精细控制并发和取消的场景、长时间运行的后台任务。</li>
</ul>
</li>
<li><strong>缺点：</strong> 引入了新的概念（Generator、Effects），增加了项目复杂度。</li>
</ul>
</li>
</ul>
<p><strong>选择：</strong></p>
<ul>
<li><strong>Thunk：</strong> 适合小型项目或异步逻辑简单的场景，追求快速实现。</li>
<li><strong>Saga：</strong> 适合中大型项目，异步逻辑复杂、需要高可控性、可测试性强的场景。</li>
</ul>
<h3 id="zustandrecoiljotai-用过吗优缺点">
  Zustand、Recoil、Jotai 用过吗？优缺点？
  <a class="anchor" href="#zustandrecoiljotai-%e7%94%a8%e8%bf%87%e5%90%97%e4%bc%98%e7%bc%ba%e7%82%b9">#</a>
</h3>
<p>（你需要根据你是否有实际使用经验来回答）</p>
<p><strong>我用过的：</strong></p>
<ul>
<li><strong>Zustand (我用过):</strong>
<ul>
<li><strong>优点：</strong>
<ul>
<li><strong>极简且轻量：</strong> API 极其简洁，几行代码就能搞定状态管理，比 Redux 简单太多。</li>
<li><strong>无需 Provider：</strong> 无需像 Context 或 Redux 那样包裹 <code>Provider</code>，组件可以直接从 Store 读取状态。</li>
<li><strong>响应式更新：</strong> 通过 <code>selector</code> 机制，只有被选择的状态发生变化时，组件才会重新渲染。</li>
<li><strong>基于 Hooks：</strong> 与 React Hooks 天然集成。</li>
<li><strong>可组合性强：</strong> 易于与其他 Hook、工具结合。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>不强制严格的单一数据源和纯函数更新，在大型团队协作时可能需要额外的规范。</li>
<li>缺少像 Redux DevTools 那样开箱即用的时间旅行调试功能（但有社区插件）。</li>
<li>异步操作相对简单，需要手动结合 <code>async/await</code> 或 <code>fetch</code>。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 小型到中型项目、对包体积和学习成本要求高的项目、需要快速原型开发。</li>
</ul>
</li>
</ul>
<p><strong>我了解但未深入使用的 (或者只在小 demo 中体验过)：</strong></p>
<ul>
<li>
<p><strong>Recoil (Facebook 推出)：</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li><strong>原子化状态：</strong> 将状态拆分成细粒度的“原子 (Atoms)”，每个组件只订阅其所需的原子。</li>
<li><strong>性能优化：</strong> 只有订阅了特定原子的组件在原子变化时才会渲染，天然的性能优化。</li>
<li><strong>派生状态 (Selectors)：</strong> 强大的 Selector 机制用于从 Atoms 派生计算状态，并且是可缓存的。</li>
<li><strong>与 React Concurrent Mode 兼容：</strong> 设计之初就考虑了 React 的并发特性。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>学习曲线比 Zustand 稍陡峭，引入了 Atoms 和 Selectors 概念。</li>
<li>文档和社区活跃度相对 Redux 和 Zustand 稍弱一些（但也在快速发展）。</li>
<li>相对比较新，成熟度尚不如 Redux。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 大型复杂应用、需要高性能和细粒度状态控制、追求与 React 最新特性紧密结合。</li>
</ul>
</li>
<li>
<p><strong>Jotai (受 Recoil 启发)：</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li><strong>原子化且更小：</strong> 比 Recoil 更轻量，更小的包体积。</li>
<li><strong>极简 API：</strong> API 甚至比 Recoil 更简单，核心是 <code>atom</code> 和 <code>useAtom</code>。</li>
<li><strong>Typescript 友好：</strong> 天然支持 TypeScript。</li>
<li><strong>高度可组合：</strong> 原子可以互相组合。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>概念抽象，初次理解可能需要一点时间。</li>
<li>社区生态和工具链相对较新。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 追求极致轻量和高性能、高度 TypeScript 化的项目、需要细粒度状态控制。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong> 对于工具链平台这样的项目，如果不需要复杂的异步流和时间旅行调试，<strong>Zustand</strong> 是一个很好的选择，因为它轻量、简单，能快速实现功能。如果项目非常庞大，对状态细粒度控制和未来扩展性有极高要求，可能会考虑 Recoil。Redux Toolkit 仍然是稳健的选择，尤其是有 Redux 经验的团队。</p>
<hr>
<h2 id="-异步与网络请求">
  🌐 异步与网络请求
  <a class="anchor" href="#-%e5%bc%82%e6%ad%a5%e4%b8%8e%e7%bd%91%e7%bb%9c%e8%af%b7%e6%b1%82">#</a>
</h2>
<hr>
<h3 id="react-中如何发送异步请求">
  React 中如何发送异步请求？
  <a class="anchor" href="#react-%e4%b8%ad%e5%a6%82%e4%bd%95%e5%8f%91%e9%80%81%e5%bc%82%e6%ad%a5%e8%af%b7%e6%b1%82">#</a>
</h3>
<p>在 React 中发送异步请求主要有以下几种方式：</p>
<ol>
<li>
<p><strong>在 <code>useEffect</code> Hook 中发送（函数组件，最常用）：</strong></p>
<ul>
<li>这是处理数据获取副作用的标准方式。</li>
<li>通常会结合 <code>useState</code> 来管理请求的加载状态 (<code>isLoading</code>)、错误状态 (<code>isError</code>) 和数据本身。</li>
<li>需要注意<strong>依赖数组</strong>和<strong>清理函数</strong>，以避免内存泄漏和竞态条件。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span>, { <span style="color:#a6e22e">useState</span>, <span style="color:#a6e22e">useEffect</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">MyComponent</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">setData</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">loading</span>, <span style="color:#a6e22e">setLoading</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">error</span>, <span style="color:#a6e22e">setError</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fetchData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> () =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">response</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#39;/api/data&#39;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">ok</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">`HTTP error! status: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">status</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">json</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setData</span>(<span style="color:#a6e22e">result</span>);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setError</span>(<span style="color:#a6e22e">err</span>);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setLoading</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fetchData</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果有需要清理的订阅或定时器，在这里返回一个清理函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 例如，取消请求（如果使用 abort controller）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>  }, []); <span style="color:#75715e">// 空数组表示只在组件挂载时执行一次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">loading</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Loading</span>...<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">error</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>Error<span style="color:#f92672">:</span> {<span style="color:#a6e22e">error</span>.<span style="color:#a6e22e">message</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Data</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>(<span style="color:#a6e22e">data</span>)}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>在事件处理函数中发送：</strong></p>
<ul>
<li>当异步请求是由用户交互（如点击按钮）触发时，直接在事件处理函数中调用。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">MyForm</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleSubmit</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> (<span style="color:#a6e22e">e</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">preventDefault</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">response</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#39;/api/submit&#39;</span>, { <span style="color:#a6e22e">method</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;POST&#39;</span>, <span style="color:#a6e22e">body</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;...&#39;</span> });
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 处理响应
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 处理错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">form</span> <span style="color:#a6e22e">onSubmit</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">handleSubmit</span>}<span style="color:#f92672">&gt;</span>...<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/form&gt;;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>使用自定义 Hook 封装：</strong></p>
<ul>
<li>为了复用数据请求逻辑和状态管理，通常会将 <code>useEffect</code> 中的请求逻辑封装成一个自定义 Hook。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 例如：useFetch.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">useState</span>, <span style="color:#a6e22e">useEffect</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">useFetch</span>(<span style="color:#a6e22e">url</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">setData</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">loading</span>, <span style="color:#a6e22e">setLoading</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">error</span>, <span style="color:#a6e22e">setError</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fetchData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> () =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">response</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#a6e22e">url</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">json</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setData</span>(<span style="color:#a6e22e">result</span>);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setError</span>(<span style="color:#a6e22e">err</span>);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setLoading</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fetchData</span>();
</span></span><span style="display:flex;"><span>  }, [<span style="color:#a6e22e">url</span>]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> { <span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">loading</span>, <span style="color:#a6e22e">error</span> };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在组件中使用：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// const { data, loading, error } = useFetch(&#39;/api/users&#39;);
</span></span></span></code></pre></div></li>
<li>
<p><strong>使用专门的数据请求库/Hooks (如 <code>react-query</code>, <code>SWR</code>)：</strong></p>
<ul>
<li>这些库提供了更高级的功能，如缓存、后台重新验证、错误重试、分页、数据同步等。</li>
</ul>
</li>
</ol>
<h3 id="怎么处理加载中错误和取消请求">
  怎么处理加载中、错误和取消请求？
  <a class="anchor" href="#%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86%e5%8a%a0%e8%bd%bd%e4%b8%ad%e9%94%99%e8%af%af%e5%92%8c%e5%8f%96%e6%b6%88%e8%af%b7%e6%b1%82">#</a>
</h3>
<p><strong>1. 加载中 (Loading State)：</strong></p>
<ul>
<li><strong>实现：</strong> 使用一个 <code>boolean</code> 类型的状态变量（如 <code>isLoading</code> 或 <code>loading</code>）。在请求开始前设为 <code>true</code>，请求成功或失败后设为 <code>false</code>。</li>
<li><strong>用户体验：</strong> 在 UI 上显示加载指示器（Spinner）、骨架屏 (Skeleton Screen)、禁用按钮等。</li>
</ul>
<p><strong>2. 错误 (Error Handling)：</strong></p>
<ul>
<li><strong>实现：</strong> 使用一个状态变量来存储错误信息（如 <code>error</code>，可以是 <code>null</code> 或 <code>Error</code> 对象）。在 <code>try-catch</code> 块中捕获 <code>fetch</code> 或 <code>axios</code> 抛出的异常。</li>
<li><strong>用户体验：</strong> 显示错误消息、重试按钮、错误日志记录。</li>
</ul>
<p><strong>3. 取消请求 (Request Cancellation)：</strong></p>
<ul>
<li><strong>重要性：</strong> 避免在组件卸载后对已卸载组件的状态进行更新（导致“内存泄漏”警告），以及避免不必要的网络请求继续执行。</li>
<li><strong>实现方式：</strong>
<ul>
<li><strong><code>AbortController</code> (Fetch API)：</strong> 这是现代浏览器原生的方式。在 <code>useEffect</code> 的清理函数中，可以调用 <code>AbortController</code> 的 <code>abort()</code> 方法来取消请求。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">controller</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">AbortController</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">signal</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">signal</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fetchData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">response</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#39;/api/data&#39;</span>, { <span style="color:#a6e22e">signal</span> });
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;AbortError&#39;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Fetch aborted&#39;</span>);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setError</span>(<span style="color:#a6e22e">err</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">setLoading</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fetchData</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">abort</span>(); <span style="color:#75715e">// 组件卸载时取消请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  };
</span></span><span style="display:flex;"><span>}, []);
</span></span></code></pre></div></li>
<li><strong>Axios 的取消令牌 (Cancellation Token)：</strong> Axios 提供了自己的取消请求机制。</li>
<li><strong>请求库/Hooks 的内置支持：</strong> <code>react-query</code> 和 <code>SWR</code> 等库通常会内置处理请求取消和缓存，简化开发。</li>
</ul>
</li>
</ul>
<h3 id="项目中如何做接口缓存--分页加载">
  项目中如何做接口缓存 / 分页加载？
  <a class="anchor" href="#%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%a6%82%e4%bd%95%e5%81%9a%e6%8e%a5%e5%8f%a3%e7%bc%93%e5%ad%98--%e5%88%86%e9%a1%b5%e5%8a%a0%e8%bd%bd">#</a>
</h3>
<p><strong>1. 接口缓存 (API Caching)：</strong>
接口缓存是提高用户体验和减少服务器负载的关键。</p>
<ul>
<li><strong>客户端缓存 (前端缓存)：</strong>
<ul>
<li><strong>HTTP 缓存：</strong> 利用 HTTP 响应头（<code>Cache-Control</code>, <code>ETag</code>, <code>Last-Modified</code>）让浏览器缓存资源。对于 GET 请求，如果资源未改变，浏览器可以直接使用缓存。</li>
<li><strong>内存缓存：</strong>
<ul>
<li><strong>状态管理库：</strong> 在 Redux Store 中维护一个数据缓存层，或者使用 Context API 来存储已请求过的数据。</li>
<li><strong>专门的数据请求库：</strong> <strong><code>react-query</code> (或 <code>SWR</code>)</strong> 是处理数据请求和缓存的强大工具。它们提供了自动缓存、后台重新验证、数据过期、乐观更新等功能。这是我实际项目中实现接口缓存的首选。</li>
<li><strong>自定义 Hook：</strong> 封装一个 <code>useCacheFetch</code>，内部使用 <code>Map</code> 或 <code>localStorage</code> 存储数据。</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务器端缓存 (CDN / Reverse Proxy / 应用级缓存)：</strong>
<ul>
<li>对于公共且不经常变化的接口，可以在 CDN、Nginx 或后端应用层（如 Redis）进行缓存。</li>
</ul>
</li>
</ul>
<p><strong>2. 分页加载 (Pagination / Infinite Scroll)：</strong>
对于大量数据的列表，通常采用分页加载来避免一次性加载所有数据导致性能问题。</p>
<ul>
<li>
<p><strong>传统分页 (Pagination)：</strong></p>
<ul>
<li><strong>原理：</strong> 每次请求指定页码和每页数量的数据（<code>page=1&amp;size=10</code>）。后端返回该页的数据和总页数。</li>
<li><strong>实现：</strong> 前端维护当前页码 <code>currentPage</code> 和每页数量 <code>pageSize</code> 状态。用户点击页码时，更新 <code>currentPage</code> 并重新发送请求。</li>
<li><strong>优点：</strong> 用户可以快速跳转到任何页，总数明确。</li>
<li><strong>缺点：</strong> 每次翻页都需要重新请求数据。</li>
</ul>
</li>
<li>
<p><strong>无限滚动 (Infinite Scroll / Load More)：</strong></p>
<ul>
<li><strong>原理：</strong> 初始加载少量数据。当用户滚动到列表底部时，触发加载更多数据的请求（<code>offset=X&amp;limit=Y</code> 或 <code>lastId=Z&amp;limit=Y</code>）。新数据追加到现有列表。</li>
<li><strong>实现：</strong>
<ul>
<li>前端维护 <code>dataList</code> 和 <code>page</code> 或 <code>offset</code> 状态。</li>
<li>监听滚动事件，判断是否滚动到底部。</li>
<li>可以使用 <strong><code>Intersection Observer API</code></strong> 检测一个占位元素是否进入视口，从而触发加载更多。</li>
<li>在请求时显示加载指示器，请求失败时显示重试按钮。</li>
</ul>
</li>
<li><strong>优点：</strong> 提升用户体验，感觉数据源源不断。</li>
<li><strong>缺点：</strong> 无法直接跳转到特定页码，回滚到顶部可能需要重新加载或进行缓存优化。</li>
</ul>
</li>
</ul>
<p><strong>结合使用：</strong></p>
<ul>
<li><strong><code>react-query</code> / <code>SWR</code> 的分页 Hook：</strong> 这些库通常提供了专门的 Hooks（如 <code>useInfiniteQuery</code>）来简化无限滚动的实现，处理了加载状态、错误、缓存和数据合并。</li>
</ul>
<h3 id="用过-react-query-吗核心特性">
  用过 react-query 吗？核心特性？
  <a class="anchor" href="#%e7%94%a8%e8%bf%87-react-query-%e5%90%97%e6%a0%b8%e5%bf%83%e7%89%b9%e6%80%a7">#</a>
</h3>
<p>（如果你用过，可以详细说；没用过，就说了解和其优势）</p>
<p><strong>我用过 <code>react-query</code> (现在叫 TanStack Query)。</strong> 这是一个非常强大的<strong>数据获取和状态管理库</strong>，它将服务器端数据（异步数据）的管理从组件状态中分离出来，并提供了大量开箱即用的功能，极大地简化了数据请求逻辑。</p>
<p><strong>核心特性：</strong></p>
<ol>
<li><strong>数据缓存 (Caching)：</strong>
<ul>
<li>默认开启缓存，减少不必要的网络请求。</li>
<li>数据在后台“stale”后会自动重新获取（<code>stale-while-revalidate</code> 策略），确保数据新鲜度。</li>
<li><strong><code>cacheTime</code> 和 <code>staleTime</code>：</strong> 细粒度控制数据在缓存中保留多久以及多久后变为“过期”状态。</li>
</ul>
</li>
<li><strong>后台重新验证 (Background Re-fetching)：</strong>
<ul>
<li>当窗口重新获得焦点、网络重新连接、或通过特定事件触发时，会自动在后台重新获取数据，确保显示的是最新数据。</li>
</ul>
</li>
<li><strong>查询状态管理：</strong>
<ul>
<li>提供了一致的查询状态 (<code>isLoading</code>, <code>isFetching</code>, <code>isError</code>, <code>isSuccess</code>) 和错误处理，使组件的 UI 逻辑更清晰。</li>
</ul>
</li>
<li><strong>自动重试 (Automatic Retries)：</strong>
<ul>
<li>默认情况下，失败的查询会自动重试几次，提高了请求的健壮性。</li>
</ul>
</li>
<li><strong>分页和无限滚动查询 (<code>useInfiniteQuery</code>)：</strong>
<ul>
<li>简化了分页和无限滚动列表的实现，自动处理数据的合并和加载更多状态。</li>
</ul>
</li>
<li><strong>乐观更新 (Optimistic Updates)：</strong>
<ul>
<li>允许在数据更新请求发送成功之前，就立即更新 UI，给用户即时反馈，提升用户体验。如果请求失败，再回滚 UI。</li>
</ul>
</li>
<li><strong>依赖查询 (Dependent Queries)：</strong>
<ul>
<li>可以方便地定义查询之间的依赖关系，确保某个查询在另一个查询成功后才执行。</li>
</ul>
</li>
<li><strong>开发者工具：</strong> 提供了强大的 DevTools，用于检查查询状态、缓存、请求等，极大地提升了调试效率。</li>
</ol>
<p><strong>使用场景：</strong> 我在项目中主要用 <code>react-query</code> 来管理各种 API 请求的生命周期，例如用户列表的展示、表单数据的提交、实时数据的更新等。它极大地减少了我在 <code>useEffect</code> 中手动管理 <code>loading</code>、<code>error</code>、<code>data</code> 状态的样板代码，并天然解决了许多性能和用户体验问题。</p>
<hr>
<h2 id="-组件通信与复用">
  📦 组件通信与复用
  <a class="anchor" href="#-%e7%bb%84%e4%bb%b6%e9%80%9a%e4%bf%a1%e4%b8%8e%e5%a4%8d%e7%94%a8">#</a>
</h2>
<hr>
<h3 id="父子组件如何通信兄弟组件怎么通信">
  父子组件如何通信？兄弟组件怎么通信？
  <a class="anchor" href="#%e7%88%b6%e5%ad%90%e7%bb%84%e4%bb%b6%e5%a6%82%e4%bd%95%e9%80%9a%e4%bf%a1%e5%85%84%e5%bc%9f%e7%bb%84%e4%bb%b6%e6%80%8e%e4%b9%88%e9%80%9a%e4%bf%a1">#</a>
</h3>
<p><strong>1. 父子组件通信：</strong></p>
<ul>
<li><strong>父组件向子组件传值：通过 Props</strong>
<ul>
<li>这是最直接和常用的方式。父组件将数据作为属性（props）传递给子组件。子组件通过其 <code>props</code> 对象访问这些数据。</li>
<li><strong>示例：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// ParentComponent.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ParentComponent</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello from Parent!&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">ChildComponent</span> <span style="color:#a6e22e">data</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">message</span>} <span style="color:#f92672">/&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ChildComponent.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ChildComponent</span>(<span style="color:#a6e22e">props</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span>{<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">data</span>}<span style="color:#f92672">&lt;</span><span style="color:#e6db74">/p&gt;; /</span><span style="color:#f92672">/</span> <span style="color:#a6e22e">或</span> { <span style="color:#a6e22e">data</span> } <span style="color:#a6e22e">解构</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
</li>
<li><strong>子组件向父组件传值：通过回调函数 (Callback Functions)</strong>
<ul>
<li>父组件将一个函数作为 <code>prop</code> 传递给子组件。子组件在需要向父组件传递数据或触发父组件行为时，调用这个函数，并把数据作为参数传递过去。</li>
<li><strong>示例：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// ParentComponent.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ParentComponent</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleChildClick</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">dataFromChild</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Received from child:&#39;</span>, <span style="color:#a6e22e">dataFromChild</span>);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">ChildButton</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">handleChildClick</span>} <span style="color:#f92672">/&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ChildButton.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ChildButton</span>(<span style="color:#a6e22e">props</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{() =&gt; <span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">onClick</span>(<span style="color:#e6db74">&#39;Data sent!&#39;</span>)}<span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Click</span> <span style="color:#a6e22e">me</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/button&gt;;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
</li>
<li><strong><code>useRef</code> (特殊情况)：</strong> 父组件通过 <code>ref</code> 直接访问子组件的 DOM 节点或实例（类组件），或者使用 <code>useImperativeHandle</code> 暴露子组件的特定方法给父组件调用。这种方式通常用于非声明式的交互，应谨慎使用，因为它打破了单向数据流。</li>
</ul>
<p><strong>2. 兄弟组件通信：</strong></p>
<p>兄弟组件之间不能直接通信，需要通过它们的<strong>共同父组件</strong>作为“中间人”进行通信。</p>
<ul>
<li><strong>通过共同父组件 (状态提升)：</strong>
<ol>
<li>将共享的状态提升到共同的父组件中管理。</li>
<li>父组件将状态通过 <code>props</code> 传递给一个兄弟组件（接收者）。</li>
<li>父组件将更新状态的回调函数通过 <code>props</code> 传递给另一个兄弟组件（发送者）。</li>
<li>发送者兄弟组件调用回调函数来更新父组件的状态，从而影响接收者兄弟组件的渲染。</li>
</ol>
<ul>
<li><strong>示例：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// ParentComponent.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ParentComponent</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">sharedData</span>, <span style="color:#a6e22e">setSharedData</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#e6db74">&#39;&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">SiblingA</span> <span style="color:#a6e22e">onDataChange</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">setSharedData</span>} <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">SiblingB</span> <span style="color:#a6e22e">data</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">sharedData</span>} <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// SiblingA.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SiblingA</span>({ <span style="color:#a6e22e">onDataChange</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{() =&gt; <span style="color:#a6e22e">onDataChange</span>(<span style="color:#e6db74">&#39;Hello from A&#39;</span>)}<span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Send</span> <span style="color:#a6e22e">Data</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/button&gt;;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// SiblingB.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SiblingB</span>({ <span style="color:#a6e22e">data</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Received</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">data</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/p&gt;;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
</li>
<li><strong>Context API (<code>useContext</code>)：</strong>
<ul>
<li>对于需要跨越多个层级或多个兄弟组件共享的数据，可以使用 Context API。共同父组件作为 <code>Provider</code>，提供共享数据和更新函数；兄弟组件作为 <code>Consumer</code>（通过 <code>useContext</code> Hook），获取所需数据。</li>
</ul>
</li>
<li><strong>全局状态管理库 (Redux, Zustand, etc.)：</strong>
<ul>
<li>对于更复杂、需要集中管理和协调的全局状态，使用 Redux、Zustand 等状态管理库是最佳选择。兄弟组件都从 Store 中订阅所需的状态，并 <code>dispatch</code> action 来更新状态。</li>
</ul>
</li>
</ul>
<h3 id="什么是高阶组件hoc">
  什么是高阶组件（HOC）？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6hoc">#</a>
</h3>
<p><strong>高阶组件 (Higher-Order Component, HOC)</strong> 是 React 中用于<strong>组件逻辑复用</strong>的一种高级技术。它本质上是一个<strong>函数</strong>，接收一个组件作为参数，并<strong>返回一个新的（增强型）组件</strong>。</p>
<p><strong>定义：</strong> HOC 是一种约定俗成的模式，它不是 React API 的一部分。它的结构通常是：<code>const EnhancedComponent = higherOrderComponent(WrappedComponent);</code></p>
<p><strong>HOC 的作用：</strong></p>
<ul>
<li><strong>逻辑复用：</strong> 提取和复用公共的状态逻辑或行为，避免在多个组件中重复编写。</li>
<li><strong>代码解耦：</strong> 将增强逻辑与 UI 渲染逻辑分离。</li>
<li><strong>Props 劫持/注入：</strong> 可以修改、添加或删除传递给被包装组件的 <code>props</code>。</li>
<li><strong>渲染劫持：</strong> 可以控制被包装组件的渲染过程（例如，条件渲染、包装额外的元素）。</li>
</ul>
<p><strong>示例：<code>withLoading</code> HOC</strong> (添加加载状态逻辑)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span>, { <span style="color:#a6e22e">useState</span>, <span style="color:#a6e22e">useEffect</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withLoading</span>(<span style="color:#a6e22e">WrappedComponent</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">WithLoadingComponent</span>(<span style="color:#a6e22e">props</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">loading</span>, <span style="color:#a6e22e">setLoading</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 模拟数据加载
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setLoading</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>      }, <span style="color:#ae81ff">2000</span>);
</span></span><span style="display:flex;"><span>    }, []);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">loading</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Loading</span>...<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">WrappedComponent</span> {...<span style="color:#a6e22e">props</span>} <span style="color:#f92672">/&gt;</span>; <span style="color:#75715e">// 传递原始 props
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如何使用：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// const MyDataDisplay = ({ data }) =&gt; &lt;p&gt;{data}&lt;/p&gt;;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// const MyDataDisplayWithLoading = withLoading(MyDataDisplay);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &lt;MyDataDisplayWithLoading data=&#34;Some important data&#34; /&gt;
</span></span></span></code></pre></div><p><strong>HOC 的优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 逻辑复用性强，对原始组件侵入性小。</li>
<li><strong>缺点：</strong>
<ul>
<li><strong>命名冲突：</strong> 如果多个 HOC 注入同名 props，可能会覆盖。</li>
<li><strong>Props 来源不明确：</strong> 很难看出某个 prop 是从哪个 HOC 注入的。</li>
<li><strong>Wrapper Hell：</strong> 多个 HOC 嵌套可能导致组件树层级过深，调试困难。</li>
<li><strong>不兼容 Hooks (早期)：</strong> 在 Hooks 出现之前，HOC 是主要的逻辑复用方式。Hooks 出现后，自定义 Hook 成为更推荐的方式，因为它们解决了 HOC 的一些痛点。</li>
</ul>
</li>
</ul>
<h3 id="什么是-render-props-模式">
  什么是 render props 模式？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-render-props-%e6%a8%a1%e5%bc%8f">#</a>
</h3>
<p><strong>Render Props</strong> 是一种 React 中用于<strong>组件逻辑复用</strong>的模式。其核心思想是：<strong>一个组件的 <code>props</code> 接收一个函数（这个函数返回 React 元素，即渲染内容），而不是直接返回 React 元素。</strong> 子组件在内部调用这个函数 <code>prop</code> 来决定它要渲染什么。</p>
<p><strong>定义：</strong> 任何使用 <code>render</code> prop 来告诉组件要渲染什么，而不是自己渲染的组件，都可以称为使用了 render props 模式。尽管名字叫 <code>render props</code>，但这个 <code>prop</code> 的名称不一定是 <code>render</code>，可以是任何函数类型的 prop（如 <code>children</code>, <code>renderHeader</code> 等）。</p>
<p><strong>示例：<code>MouseTracker</code> 组件</strong> (追踪鼠标位置并渲染任意内容)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span>, { <span style="color:#a6e22e">useState</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MouseTracker</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">React</span>.<span style="color:#a6e22e">Component</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">props</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">super</span>(<span style="color:#a6e22e">props</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">state</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handleMouseMove</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handleMouseMove</span>.<span style="color:#a6e22e">bind</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">handleMouseMove</span>(<span style="color:#a6e22e">event</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">setState</span>({
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">clientX</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">clientY</span>
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">render</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span>{{ <span style="color:#a6e22e">height</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;100vh&#39;</span> }} <span style="color:#a6e22e">onMouseMove</span><span style="color:#f92672">=</span>{<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handleMouseMove</span>}<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        {<span style="color:#75715e">/* 调用传入的 render prop，并将当前鼠标位置作为参数传递 */</span>}
</span></span><span style="display:flex;"><span>        {<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">render</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">state</span>)}
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如何使用：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">App</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">h1</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Move</span> <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">mouse</span> <span style="color:#a6e22e">around</span><span style="color:#f92672">!&lt;</span><span style="color:#960050;background-color:#1e0010">/h1&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">MouseTracker</span> <span style="color:#a6e22e">render</span><span style="color:#f92672">=</span>{({ <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> }) =&gt; (
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Render props 接收 MouseTracker 传递的状态，并决定渲染什么
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">The</span> <span style="color:#a6e22e">mouse</span> <span style="color:#a6e22e">position</span> <span style="color:#a6e22e">is</span> ({<span style="color:#a6e22e">x</span>}, {<span style="color:#a6e22e">y</span>})<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/p&gt;</span>
</span></span><span style="display:flex;"><span>      )}<span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>      {<span style="color:#75715e">/* 也可以渲染其他内容，只要提供不同的 render prop */</span>}
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">MouseTracker</span> <span style="color:#a6e22e">render</span><span style="color:#f92672">=</span>{({ <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> }) =&gt; (
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">img</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://example.com/cat.png&#34;</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span>{{ <span style="color:#a6e22e">position</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;absolute&#39;</span>, <span style="color:#a6e22e">left</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">top</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">y</span> }} <span style="color:#a6e22e">alt</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Cat&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>      )}<span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Render Props 的优缺点：</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li><strong>灵活的 UI 渲染：</strong> 被包装的组件完全控制渲染内容。</li>
<li><strong>逻辑复用：</strong> 行为逻辑（如鼠标追踪、数据获取）可以在不同组件间复用。</li>
<li><strong>避免命名冲突：</strong> 不像 HOC 可能会有 props 命名冲突。</li>
<li><strong>清晰的数据流：</strong> 明确地知道哪些数据从父组件（这里是 <code>MouseTracker</code>）传递给了子组件（render prop 返回的组件）。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li><strong>嵌套地狱 (Wrapper Hell)：</strong> 如果使用多个 render props，可能会导致 JSX 嵌套过深，代码可读性下降。</li>
<li><strong>性能问题：</strong> 每次渲染时，如果 <code>render</code> prop 是一个匿名函数，它会创建一个新的函数引用，可能导致子组件不必要的重新渲染（与 <code>React.memo</code> 结合时需要注意）。</li>
</ul>
</li>
</ul>
<p><strong>Hooks 与 Render Props：</strong>
在 Hooks 出现后，许多原本通过 render props 实现的逻辑复用场景现在可以通过<strong>自定义 Hook</strong> 更简洁地实现，且没有嵌套地狱的问题。例如，上述的 <code>MouseTracker</code> 逻辑就可以封装成一个 <code>useMousePosition</code> 自定义 Hook。尽管如此，Render Props 在某些场景下（如需要动态提供渲染内容）仍然是一种有效的模式。</p>
<h3 id="组件复用有哪些方式你实际项目怎么做的">
  组件复用有哪些方式？你实际项目怎么做的？
  <a class="anchor" href="#%e7%bb%84%e4%bb%b6%e5%a4%8d%e7%94%a8%e6%9c%89%e5%93%aa%e4%ba%9b%e6%96%b9%e5%bc%8f%e4%bd%a0%e5%ae%9e%e9%99%85%e9%a1%b9%e7%9b%ae%e6%80%8e%e4%b9%88%e5%81%9a%e7%9a%84">#</a>
</h3>
<p>组件复用是提高开发效率、代码质量和维护性的重要方面。主要方式有：</p>
<ol>
<li>
<p><strong>高阶组件 (HOC)</strong>：</p>
<ul>
<li><strong>方式：</strong> 函数接收一个组件，返回一个新组件。</li>
<li><strong>适用场景：</strong> 注入公共 <code>props</code>、添加公共逻辑（如加载状态、权限校验、数据请求）。</li>
<li><strong>项目实践：</strong> 我在项目中曾用 HOC 实现过统一的权限校验 (<code>withAuth</code>) 或加载状态展示 (<code>withLoading</code>)，将这些非业务逻辑从业务组件中剥离。</li>
</ul>
</li>
<li>
<p><strong>Render Props 模式</strong>：</p>
<ul>
<li><strong>方式：</strong> 组件的 <code>prop</code> 接收一个函数，该函数返回 JSX。</li>
<li><strong>适用场景：</strong> 需要复用逻辑但 UI 表现形式灵活多样的情况（如鼠标追踪、弹窗、表单字段）。</li>
<li><strong>项目实践：</strong> 我曾用它来实现一个可复用的 <code>DataFetcher</code> 组件，它负责数据的加载、错误处理，然后通过 <code>render</code> prop 把数据和状态传递给子组件来渲染不同形式的 UI。</li>
</ul>
</li>
<li>
<p><strong>自定义 Hook (Custom Hooks)</strong>：</p>
<ul>
<li><strong>方式：</strong> 以 <code>use</code> 开头的函数，内部调用其他 Hook，封装并复用状态逻辑。</li>
<li><strong>适用场景：</strong> <strong>这是 React 官方推荐的、在函数组件中最主要的逻辑复用方式。</strong> 几乎所有需要共享状态逻辑的场景都可以使用。</li>
<li><strong>项目实践：</strong> 我在项目中大量使用了自定义 Hook，例如 <code>useFormValidation</code>（封装表单验证逻辑）、<code>useInfiniteScroll</code>（实现无限滚动列表）、<code>useDebounce</code>（防抖函数）。这极大地减少了组件内部的样板代码，提高了逻辑的内聚性和可测试性。</li>
</ul>
</li>
<li>
<p><strong>组件组合 (Composition)</strong>：</p>
<ul>
<li><strong>方式：</strong> 将多个小组件组合成一个大组件，通过 <code>props.children</code> 或其他命名 <code>props</code> 来传递 JSX 片段。</li>
<li><strong>适用场景：</strong> 构建复杂 UI 结构，例如布局组件、卡片组件、模态框组件。</li>
<li><strong>项目实践：</strong> 我会创建像 <code>Card</code>, <code>Modal</code>, <code>Layout</code> 这样的通用 UI 组件。例如，<code>Card</code> 组件可能有一个 <code>header</code> 和 <code>body</code> prop，允许传入不同的 JSX 来渲染不同的内容，而不是硬编码这些内容。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// Card.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Card</span>({ <span style="color:#a6e22e">header</span>, <span style="color:#a6e22e">children</span>, <span style="color:#a6e22e">footer</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">className</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      {<span style="color:#a6e22e">header</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">className</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-header&#34;</span><span style="color:#f92672">&gt;</span>{<span style="color:#a6e22e">header</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">className</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-body&#34;</span><span style="color:#f92672">&gt;</span>{<span style="color:#a6e22e">children</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>      {<span style="color:#a6e22e">footer</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">className</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-footer&#34;</span><span style="color:#f92672">&gt;</span>{<span style="color:#a6e22e">footer</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Usage
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// &lt;Card header={&lt;h2&gt;Title&lt;/h2&gt;} footer={&lt;button&gt;More&lt;/button&gt;}&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   &lt;p&gt;Card content here&lt;/p&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// &lt;/Card&gt;
</span></span></span></code></pre></div></li>
</ol>
<p><strong>我实际项目怎么做的？</strong>
在我的项目中，<strong>自定义 Hook 是我最主要和最推荐的逻辑复用方式</strong>，因为它简洁、强大且符合 Hooks 的设计哲学。对于 UI 结构上的复用，我主要使用<strong>组件组合</strong>，创建通用且可配置的 UI 组件。HOC 和 Render Props 在 Hooks 出现后使用频率有所下降，但如果面对旧项目或特定需求，它们仍有其用武之地。例如，在旧版类组件较多的项目里，HOC 仍然是有效的复用方案。</p>
<h3 id="什么是组合优于继承react-如何体现">
  什么是组合优于继承？React 如何体现？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%bb%84%e5%90%88%e4%bc%98%e4%ba%8e%e7%bb%a7%e6%89%bfreact-%e5%a6%82%e4%bd%95%e4%bd%93%e7%8e%b0">#</a>
</h3>
<p><strong>“组合优于继承” (Composition over Inheritance)</strong> 是一种设计原则，它建议在设计可复用代码时，应优先考虑通过<strong>组合</strong>的方式来实现功能，而不是通过<strong>继承</strong>。</p>
<ul>
<li>
<p><strong>继承的缺点：</strong></p>
<ul>
<li><strong>紧耦合：</strong> 子类与父类紧密耦合，子类会继承父类的所有方法和属性，即使它不需要。</li>
<li><strong>脆弱的基类问题：</strong> 父类的改变可能会意外地影响所有子类，导致难以调试的问题。</li>
<li><strong>多重继承问题：</strong> 许多语言不支持多重继承，限制了代码复用的灵活性。</li>
<li><strong>关注点混合：</strong> 父类可能包含与子类无关的逻辑。</li>
</ul>
</li>
<li>
<p><strong>组合的优点：</strong></p>
<ul>
<li><strong>松耦合：</strong> 组件之间通过 <code>props</code> 进行通信，依赖关系明确。</li>
<li><strong>高内聚低耦合：</strong> 每个组件只关注自己的职责。</li>
<li><strong>更灵活：</strong> 可以根据需要组合不同的功能。</li>
<li><strong>更易测试：</strong> 独立的组件更容易进行单元测试。</li>
</ul>
</li>
</ul>
<p><strong>React 如何体现“组合优于继承”：</strong></p>
<ol>
<li>
<p><strong>函数组件和 Hooks：</strong></p>
<ul>
<li>React 推荐使用函数组件，它更像一个“纯函数”，接收 <code>props</code> 并返回 UI。</li>
<li><strong>自定义 Hook</strong> 是组合思想的完美体现。它允许你将独立的状态逻辑和副作用封装起来，然后在多个组件中“组合”使用这些逻辑，而不需要通过继承来共享。例如，<code>useToggle</code> 可以在多个组件中组合使用，而不需要组件继承一个 <code>ToggleableComponent</code>。</li>
</ul>
</li>
<li>
<p><strong><code>props.children</code> 和其他 <code>props</code> 传递 JSX：</strong></p>
<ul>
<li>这是 React 中最常见的组合方式。父组件通过 <code>props.children</code>（或自定义的 <code>props</code>，如 <code>leftSidebar</code>, <code>footer</code>）来渲染其内部的内容。父组件只提供结构和布局，不关心子组件的具体渲染逻辑。</li>
<li><strong>示例：</strong> <code>Modal</code> 组件只负责模态框的显示、隐藏、遮罩和关闭按钮，而模态框的<strong>具体内容</strong>则是通过 <code>props.children</code> 传递进来的。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Modal</span>({ <span style="color:#a6e22e">children</span>, <span style="color:#a6e22e">isOpen</span>, <span style="color:#a6e22e">onClose</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">isOpen</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">className</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;modal-overlay&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">className</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;modal-content&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        {<span style="color:#a6e22e">children</span>} {<span style="color:#75715e">/* 组合进去的内容 */</span>}
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">onClose</span>}<span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Close</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/button&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Usage: &lt;Modal isOpen={true} onClose={() =&gt; {}}&gt;&lt;MyForm /&gt;&lt;/Modal&gt;
</span></span></span></code></pre></div><code>Modal</code> 组件并不知道 <code>MyForm</code> 是什么，它只知道要渲染 <code>children</code>。</li>
</ul>
</li>
<li>
<p><strong>高阶组件 (HOC) 和 Render Props (传统方式)：</strong></p>
<ul>
<li>虽然现在自定义 Hook 更流行，但 HOC 和 Render Props 模式本身也是组合的体现。它们通过包装或注入函数来“组合”额外的行为，而不是让组件继承一个基类。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong> React 的设计哲学鼓励我们创建小的、独立的、职责单一的组件，并通过 <code>props</code>、<code>children</code> 和自定义 Hook 将它们组合起来，构建出复杂的应用程序。这与面向对象编程中强调的“组合优于继承”原则不谋而合，使得 React 应用更具灵活性、可维护性和可测试性。</p>
<hr>
<h2 id="-路由与表单">
  📄 路由与表单
  <a class="anchor" href="#-%e8%b7%af%e7%94%b1%e4%b8%8e%e8%a1%a8%e5%8d%95">#</a>
</h2>
<hr>
<h3 id="react-router-的核心原理">
  React Router 的核心原理？
  <a class="anchor" href="#react-router-%e7%9a%84%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86">#</a>
</h3>
<p>React Router 是一个流行的声明式路由库，用于在 React 应用中管理 URL 和 UI 的同步。</p>
<p><strong>核心原理：</strong></p>
<ol>
<li>
<p><strong>历史管理 (History Management)：</strong></p>
<ul>
<li>React Router 的核心是基于 <strong>History API</strong>（<code>pushState</code>, <code>replaceState</code>, <code>popstate</code> 事件）或 <strong>Hash History</strong>（<code>window.location.hash</code>）来管理 URL 的变化。</li>
<li>它提供了一种机制，使得 URL 的变化不会导致浏览器进行页面刷新，而是通过 JavaScript 来动态更新 UI。</li>
<li><strong><code>BrowserRouter</code></strong> 使用 History API (HTML5 Pushstate)。</li>
<li><strong><code>HashRouter</code></strong> 使用 URL 的哈希部分（<code>#/path</code>）。</li>
</ul>
</li>
<li>
<p><strong>声明式路由配置：</strong></p>
<ul>
<li>我们使用 <code>Route</code> 组件来声明路由规则，而不是传统的集中式路由配置。</li>
<li>每个 <code>Route</code> 组件都定义了当 URL 匹配特定 <code>path</code> 时应该渲染哪个组件。</li>
<li><strong><code>path</code> 参数：</strong> 可以是精确匹配，也可以是动态参数（如 <code>/users/:id</code>）。</li>
<li><strong>嵌套路由：</strong> 允许组件内部定义自己的子路由，形成层级结构。</li>
</ul>
</li>
<li>
<p><strong>组件与 URL 的关联：</strong></p>
<ul>
<li><code>Route</code> 组件会监听 URL 的变化。当 URL 与其 <code>path</code> 匹配时，它会渲染指定的组件，并向该组件注入路由相关的 <code>props</code>（如 <code>match</code>, <code>location</code>, <code>history</code>）。</li>
<li>Hooks (<code>useParams</code>, <code>useLocation</code>, <code>useNavigate</code>, <code>useMatch</code>) 提供了更简洁的方式来获取路由信息和进行导航。</li>
</ul>
</li>
<li>
<p><strong>导航：</strong></p>
<ul>
<li><code>Link</code> 组件：用于声明式导航，渲染成一个带有 <code>href</code> 的 <code>&lt;a&gt;</code> 标签，点击时会通过 History API 更新 URL，而不触发页面刷新。</li>
<li><code>useNavigate</code> Hook (React Router v6+)：用于编程式导航，可以在事件处理函数或副作用中进行页面跳转。</li>
</ul>
</li>
<li>
<p><strong>渲染机制：</strong></p>
<ul>
<li>当 URL 变化时，React Router 会比较新的 URL 和已有的路由配置，找出匹配的 <code>Route</code> 组件。</li>
<li>匹配到的 <code>Route</code> 组件会触发其内部组件的渲染。这个过程仍然遵循 React 的 Diff 算法和虚拟 DOM 更新机制。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong> React Router 的核心在于将浏览器的 URL 变化与 React 组件的渲染状态进行<strong>同步</strong>，通过<strong>声明式配置和 History API</strong> 实现了单页面应用 (SPA) 中的无刷新路由跳转和 UI 更新。</p>
<h3 id="路由懒加载怎么做">
  路由懒加载怎么做？
  <a class="anchor" href="#%e8%b7%af%e7%94%b1%e6%87%92%e5%8a%a0%e8%bd%bd%e6%80%8e%e4%b9%88%e5%81%9a">#</a>
</h3>
<p>React Router 中的路由懒加载通常结合 <strong><code>React.lazy</code> 和 <code>Suspense</code></strong> 来实现。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>
<p><strong>使用 <code>React.lazy</code> 动态导入路由组件：</strong></p>
<ul>
<li>将需要进行懒加载的路由对应的组件使用 <code>React.lazy</code> 包裹。<code>React.lazy</code> 接收一个函数，该函数会调用 <code>import()</code> 动态导入组件。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span>, { <span style="color:#a6e22e">lazy</span>, <span style="color:#a6e22e">Suspense</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">BrowserRouter</span>, <span style="color:#a6e22e">Routes</span>, <span style="color:#a6e22e">Route</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react-router-dom&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 懒加载组件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">HomePage</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">lazy</span>(() =&gt; <span style="color:#66d9ef">import</span>(<span style="color:#e6db74">&#39;./pages/HomePage&#39;</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">AboutPage</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">lazy</span>(() =&gt; <span style="color:#66d9ef">import</span>(<span style="color:#e6db74">&#39;./pages/AboutPage&#39;</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">DashboardPage</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">lazy</span>(() =&gt; <span style="color:#66d9ef">import</span>(<span style="color:#e6db74">&#39;./pages/DashboardPage&#39;</span>));
</span></span></code></pre></div></li>
<li>
<p><strong>使用 <code>Suspense</code> 包裹 <code>Route</code> 组件：</strong></p>
<ul>
<li>将包含懒加载组件的 <code>Route</code> 或 <code>Routes</code> 整体用 <code>Suspense</code> 组件包裹起来。</li>
<li><code>Suspense</code> 组件需要一个 <code>fallback</code> prop，用于在懒加载组件加载过程中显示回退内容（如加载指示器）。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">App</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">BrowserRouter</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Suspense</span> <span style="color:#a6e22e">fallback</span><span style="color:#f92672">=</span>{<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Loading</span> <span style="color:#a6e22e">page</span>...<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;}&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Routes</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Route</span> <span style="color:#a6e22e">path</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/&#34;</span> <span style="color:#a6e22e">element</span><span style="color:#f92672">=</span>{<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">HomePage</span> <span style="color:#f92672">/&gt;</span>} <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Route</span> <span style="color:#a6e22e">path</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/about&#34;</span> <span style="color:#a6e22e">element</span><span style="color:#f92672">=</span>{<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">AboutPage</span> <span style="color:#f92672">/&gt;</span>} <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Route</span> <span style="color:#a6e22e">path</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/dashboard&#34;</span> <span style="color:#a6e22e">element</span><span style="color:#f92672">=</span>{<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">DashboardPage</span> <span style="color:#f92672">/&gt;</span>} <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/Routes&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/Suspense&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/BrowserRouter&gt;</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ol>
<p><strong>原理：</strong>
当用户访问一个懒加载路由时，浏览器不会立即下载该路由组件及其所有依赖的代码。只有当用户导航到该路由时，<code>React.lazy</code> 才会触发相应的 <code>import()</code> 动态导入，构建工具（如 Webpack）会识别到这个动态导入，并将其拆分成一个单独的 JavaScript bundle。浏览器会异步下载这个 bundle，并在下载完成后渲染组件。在此期间，<code>Suspense</code> 的 <code>fallback</code> 内容会显示给用户。</p>
<p><strong>优势：</strong></p>
<ul>
<li><strong>减少初始加载时间：</strong> 应用程序的初始 bundle 体积更小。</li>
<li><strong>按需加载：</strong> 只有当用户需要访问某个页面时，才加载该页面对应的代码。</li>
<li><strong>更好的用户体验：</strong> 页面加载更快，尤其是在大型单页应用中。</li>
</ul>
<h3 id="表单库你用过哪些formik--react-hook-form">
  表单库你用过哪些？Formik / React Hook Form？
  <a class="anchor" href="#%e8%a1%a8%e5%8d%95%e5%ba%93%e4%bd%a0%e7%94%a8%e8%bf%87%e5%93%aa%e4%ba%9bformik--react-hook-form">#</a>
</h3>
<p>（根据你的实际使用经验回答，下面以都用过为例）</p>
<p>我在项目中主要使用过 <strong>Formik</strong> 和 <strong>React Hook Form</strong>。</p>
<ul>
<li>
<p><strong>Formik：</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li><strong>功能全面：</strong> 内置了表单值、错误、触控状态 (touched) 的管理，以及提交处理、验证等一整套解决方案。</li>
<li><strong>易于上手：</strong> 对于不熟悉 Hooks 的开发者来说，Formik 提供了 <code>Formik</code> 组件和 <code>Field</code> 组件，封装了大部分逻辑，开箱即用。</li>
<li><strong>生态健全：</strong> 社区活跃，有丰富的集成方案（如与 Yup 配合进行校验）。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li><strong>渲染性能：</strong> 在输入时可能会导致不必要的重渲染，因为 Formik 会更新内部状态，这会引起整个 <code>Formik</code> 上下文的消费者（包括所有 <code>Field</code>）重新渲染。</li>
<li><strong>学习曲线：</strong> 虽然比手动写表单简单，但其 <code>render props</code> 或 HOC 模式在 Hooks 流行后显得略微复杂。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 对性能要求不是特别高、偏好一体化解决方案、或团队习惯类组件模式的项目。</li>
</ul>
</li>
<li>
<p><strong>React Hook Form：</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li><strong>性能优异：</strong> 采用<strong>非受控组件</strong>的思路，通过 <code>ref</code> 直接操作 DOM，避免了组件在每次输入时都重新渲染。这使得它在性能上表现卓越，尤其是在大型或复杂表单中。</li>
<li><strong>小巧轻量：</strong> 包体积非常小，无额外的依赖。</li>
<li><strong>基于 Hooks：</strong> 完全利用 React Hooks 的特性，API 简洁直观。</li>
<li><strong>更少重渲染：</strong> 只有在表单状态（如 <code>isValid</code>, <code>isDirty</code>）真正变化时才会触发组件重渲染，而输入值的变化直接由 DOM 处理。</li>
<li><strong>易于集成：</strong> 校验库（如 Zod, Yup）集成简单。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>对受控组件的支持相对弱一些（需要使用 <code>Controller</code> 组件）。</li>
<li>对于习惯受控组件的开发者来说，可能需要适应其非受控的哲学。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 对表单性能要求高、大型复杂表单、追求轻量级和 Hook 友好的项目。</li>
</ul>
</li>
</ul>
<p><strong>我的选择：</strong>
在我的项目中，我更倾向于使用 <strong>React Hook Form</strong>。它在性能方面的优势非常明显，能够有效避免大型表单带来的卡顿问题。其 Hooks 化的 API 也更符合现代 React 开发的习惯，代码也更简洁。对于需要集成第三方受控组件的场景，<code>Controller</code> 组件也能很好地解决。</p>
<h3 id="表单校验是怎么实现的">
  表单校验是怎么实现的？
  <a class="anchor" href="#%e8%a1%a8%e5%8d%95%e6%a0%a1%e9%aa%8c%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84">#</a>
</h3>
<p>表单校验是确保用户输入数据有效性的关键。我通常结合以下方式来实现：</p>
<ol>
<li>
<p><strong>内置 HTML5 校验：</strong></p>
<ul>
<li><strong>方式：</strong> 利用 HTML5 自身的属性，如 <code>required</code>, <code>minlength</code>, <code>maxlength</code>, <code>type=&quot;email&quot;</code>, <code>pattern</code> 等。</li>
<li><strong>优点：</strong> 简单易用，浏览器原生支持，无需额外 JavaScript。</li>
<li><strong>缺点：</strong> 校验规则有限，错误提示样式不可控，用户体验较差。</li>
</ul>
</li>
<li>
<p><strong>手动校验 (在 <code>onChange</code> 或 <code>onSubmit</code> 事件中)：</strong></p>
<ul>
<li><strong>方式：</strong> 在 <code>input</code> 的 <code>onChange</code> 事件中实时校验，或者在表单提交 (<code>onSubmit</code>) 时集中校验。</li>
<li><strong>优点：</strong> 灵活，可以实现任意复杂的校验逻辑。</li>
<li><strong>缺点：</strong> 需要手动管理大量错误状态，代码量大，逻辑分散。</li>
</ul>
</li>
<li>
<p><strong>使用第三方校验库 (结合表单库)：</strong></p>
<ul>
<li><strong>方式：</strong> 这是最推荐的方式。结合 <code>Formik</code> 或 <code>React Hook Form</code> 这样的表单库，再集成专门的校验库。</li>
<li><strong>常用校验库：</strong>
<ul>
<li><strong>Yup：</strong> 声明式校验库，使用 <code>schema</code> 定义校验规则，语法直观。</li>
<li><strong>Zod：</strong> TypeScript 优先的声明式校验库，提供了更强大的类型推断能力。</li>
<li><strong>Joi：</strong> 另一个流行的声明式校验库（常用于 Node.js，但前端也可用）。</li>
</ul>
</li>
<li><strong>实现流程 (以 React Hook Form + Yup 为例)：</strong>
<ol>
<li>定义 Yup 的 <code>schema</code>，包含所有表单字段的校验规则（如 <code>string().required('必填')</code>, <code>number().min(0)</code>）。</li>
<li>在 <code>useForm</code> Hook 中，将 <code>schema</code> 传入 <code>resolver</code> 配置项（如 <code>resolver: yupResolver(schema)</code>）。</li>
<li><code>React Hook Form</code> 会自动处理表单的校验逻辑，并在错误时提供 <code>errors</code> 对象。</li>
<li>在 UI 层，根据 <code>errors</code> 对象显示相应的错误提示信息。</li>
</ol>
</li>
<li><strong>优点：</strong>
<ul>
<li><strong>代码简洁：</strong> 校验逻辑与 UI 分离，通过 Schema 集中定义。</li>
<li><strong>可复用性：</strong> 校验 Schema 可以复用。</li>
<li><strong>用户体验：</strong> 可以实现实时的字段级校验、提交时集中校验、自定义错误提示。</li>
<li><strong>性能：</strong> 表单库会优化校验触发时机，避免不必要的重渲染。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>后端校验：</strong></p>
<ul>
<li><strong>重要性：</strong> 任何前端校验都不能替代后端校验！前端校验是为了提升用户体验，后端校验是确保数据安全和完整性的最后一道防线。</li>
<li><strong>方式：</strong> 后端接收到数据后，再次进行严格的业务逻辑和数据格式校验。</li>
</ul>
</li>
</ol>
<p><strong>我的实践：</strong>
在我的项目中，我通常会使用 <strong><code>React Hook Form</code> 结合 <code>Yup</code> 或 <code>Zod</code> 来实现前端的表单校验。</strong> 这套组合能提供极佳的开发体验和运行时性能。同时，后端接口也会有对应的校验逻辑，确保数据的最终正确性。对于一些复杂或需要动态变化的校验规则，我可能会在 <code>Yup</code> Schema 中结合条件校验，或者在 <code>React Hook Form</code> 的 <code>watch</code> 机制中手动触发一些副作用来管理。</p>
<hr>
<h2 id="-测试与工具链">
  🧪 测试与工具链
  <a class="anchor" href="#-%e6%b5%8b%e8%af%95%e4%b8%8e%e5%b7%a5%e5%85%b7%e9%93%be">#</a>
</h2>
<hr>
<h3 id="如何对-react-组件进行单元测试">
  如何对 React 组件进行单元测试？
  <a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%af%b9-react-%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">#</a>
</h3>
<p>对 React 组件进行单元测试通常涉及到以下几个关键点：</p>
<ol>
<li><strong>测试运行器：</strong> 使用 <strong>Jest</strong> 作为测试运行器和断言库。</li>
<li><strong>渲染库：</strong> 使用 <strong>React Testing Library (RTL)</strong> 或 Enzyme（现在 RTL 更推荐）来渲染和与组件交互。</li>
<li><strong>模拟 (Mocking)：</strong> 使用 Jest 的模拟功能来模拟组件的依赖项（如 API 请求、外部模块、DOM API）。</li>
</ol>
<p><strong>单元测试的核心原则：</strong></p>
<ul>
<li><strong>测试组件的公共接口：</strong> 而不是其内部实现细节。</li>
<li><strong>模拟用户行为：</strong> 而不是直接调用组件方法。</li>
<li><strong>关注输出：</strong> 验证组件渲染的 UI、触发的事件、对状态的更新等。</li>
</ul>
<p><strong>基本步骤和示例 (使用 Jest + React Testing Library)：</strong></p>
<ol>
<li><strong>安装依赖：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>npm install --save-dev @testing-library/react @testing-library/jest-dom jest
</span></span></code></pre></div></li>
<li><strong>编写测试文件：</strong> 通常放在组件文件旁边或独立的 <code>__tests__</code> 目录中。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// MyComponent.test.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">render</span>, <span style="color:#a6e22e">screen</span>, <span style="color:#a6e22e">fireEvent</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;@testing-library/react&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;@testing-library/jest-dom&#39;</span>; <span style="color:#75715e">// 引入断言扩展
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">MyComponent</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./MyComponent&#39;</span>; <span style="color:#75715e">// 待测试组件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">describe</span>(<span style="color:#e6db74">&#39;MyComponent&#39;</span>, () =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 测试组件是否正确渲染
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#39;renders correctly with default props&#39;</span>, () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">render</span>(<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">MyComponent</span> <span style="color:#f92672">/&gt;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">screen</span>.<span style="color:#a6e22e">getByText</span>(<span style="color:#e6db74">/Hello, World!/i</span>)).<span style="color:#a6e22e">toBeInTheDocument</span>();
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 测试点击事件和状态更新
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#39;increments count on button click&#39;</span>, () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">render</span>(<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">MyComponent</span> <span style="color:#f92672">/&gt;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">button</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">screen</span>.<span style="color:#a6e22e">getByRole</span>(<span style="color:#e6db74">&#39;button&#39;</span>, { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">/Increment/i</span> });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">screen</span>.<span style="color:#a6e22e">getByText</span>(<span style="color:#e6db74">/Count: 0/i</span>)).<span style="color:#a6e22e">toBeInTheDocument</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fireEvent</span>.<span style="color:#a6e22e">click</span>(<span style="color:#a6e22e">button</span>); <span style="color:#75715e">// 模拟点击
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">screen</span>.<span style="color:#a6e22e">getByText</span>(<span style="color:#e6db74">/Count: 1/i</span>)).<span style="color:#a6e22e">toBeInTheDocument</span>();
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 测试 props 的传递
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#39;renders custom greeting based on prop&#39;</span>, () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">render</span>(<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">MyComponent</span> <span style="color:#a6e22e">greeting</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Hi there!&#34;</span> <span style="color:#f92672">/&gt;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">screen</span>.<span style="color:#a6e22e">getByText</span>(<span style="color:#e6db74">/Hi there!/i</span>)).<span style="color:#a6e22e">toBeInTheDocument</span>();
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 模拟异步请求的测试（如果组件有数据获取）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#39;fetches data and displays it&#39;</span>, <span style="color:#66d9ef">async</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 模拟 fetch API
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">jest</span>.<span style="color:#a6e22e">spyOn</span>(<span style="color:#a6e22e">global</span>, <span style="color:#e6db74">&#39;fetch&#39;</span>).<span style="color:#a6e22e">mockImplementation</span>(() =&gt;
</span></span><span style="display:flex;"><span>      Promise.<span style="color:#a6e22e">resolve</span>({
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ok</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">json</span><span style="color:#f92672">:</span> () =&gt; Promise.<span style="color:#a6e22e">resolve</span>({ <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Test Data&#39;</span> }),
</span></span><span style="display:flex;"><span>      })
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">render</span>(<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">MyComponent</span> <span style="color:#f92672">/&gt;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">screen</span>.<span style="color:#a6e22e">getByText</span>(<span style="color:#e6db74">/Loading.../i</span>)).<span style="color:#a6e22e">toBeInTheDocument</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 等待异步操作完成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">screen</span>.<span style="color:#a6e22e">findByText</span>(<span style="color:#e6db74">/Title: Test Data/i</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">screen</span>.<span style="color:#a6e22e">queryByText</span>(<span style="color:#e6db74">/Loading.../i</span>)).<span style="color:#a6e22e">not</span>.<span style="color:#a6e22e">toBeInTheDocument</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">global</span>.<span style="color:#a6e22e">fetch</span>.<span style="color:#a6e22e">mockRestore</span>(); <span style="color:#75715e">// 恢复原始 fetch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  });
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// MyComponent.js (示例待测试组件)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span>, { <span style="color:#a6e22e">useState</span>, <span style="color:#a6e22e">useEffect</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">MyComponent</span>({ <span style="color:#a6e22e">greeting</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello, World!&#34;</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">setCount</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">setData</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">loading</span>, <span style="color:#a6e22e">setLoading</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fetchData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> () =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">setLoading</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#39;/api/data&#39;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">json</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">json</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">setData</span>(<span style="color:#a6e22e">json</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">setLoading</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fetchData</span>();
</span></span><span style="display:flex;"><span>  }, []);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">h1</span><span style="color:#f92672">&gt;</span>{<span style="color:#a6e22e">greeting</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/h1&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Count</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">count</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/p&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{() =&gt; <span style="color:#a6e22e">setCount</span>(<span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)}<span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Increment</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/button&gt;</span>
</span></span><span style="display:flex;"><span>      {<span style="color:#a6e22e">loading</span> <span style="color:#f92672">?</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Loading</span>...<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/p&gt; : data &amp;&amp; &lt;p&gt;Title: {data.title}&lt;/p&gt;}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#a6e22e">MyComponent</span>;
</span></span></code></pre></div></li>
</ol>
<p><strong>关键点：</strong></p>
<ul>
<li><strong><code>render</code>：</strong> 渲染组件到虚拟 DOM。</li>
<li><strong><code>screen</code>：</strong> 查询 DOM 节点，推荐使用用户可见的查询方式（如 <code>getByText</code>, <code>getByRole</code>）。</li>
<li><strong><code>fireEvent</code>：</strong> 模拟用户事件（点击、输入等）。</li>
<li><strong><code>expect(...).toBeInTheDocument()</code>：</strong> 检查元素是否存在于 DOM 中。</li>
<li><strong>异步测试：</strong> 使用 <code>async/await</code> 和 <code>findBy*</code> 查询（<code>findByText</code>, <code>findByRole</code>），它们会自动等待元素出现。</li>
<li><strong>模拟外部依赖：</strong> 使用 <code>jest.mock</code> 或 <code>jest.spyOn</code>。</li>
</ul>
<h3 id="jestreact-testing-library-用过吗">
  jest、react-testing-library 用过吗？
  <a class="anchor" href="#jestreact-testing-library-%e7%94%a8%e8%bf%87%e5%90%97">#</a>
</h3>
<p><strong>是的，我用过 Jest 和 React Testing Library (RTL)，它们是我在 React 项目中进行单元测试和集成测试的主要工具。</strong></p>
<ul>
<li>
<p><strong>Jest：</strong></p>
<ul>
<li><strong>角色：</strong> 它是一个<strong>JavaScript 测试运行器</strong>，也是一个<strong>断言库</strong>（<code>expect</code> API）、<strong>模拟框架</strong> (<code>jest.mock</code>, <code>jest.spyOn</code>)。</li>
<li><strong>核心特点：</strong>
<ul>
<li><strong>零配置：</strong> 对于大多数 React 项目，Jest 开箱即用，无需复杂配置。</li>
<li><strong>快照测试：</strong> 可以方便地对比 UI 快照，检测意外的 UI 变化。</li>
<li><strong>强大的模拟：</strong> 轻松模拟模块、函数和定时器。</li>
<li><strong>代码覆盖率报告：</strong> 提供详细的测试覆盖率报告。</li>
</ul>
</li>
<li><strong>用法：</strong> 我用 Jest 来组织测试套件 (<code>describe</code>)、定义测试用例 (<code>test</code>/<code>it</code>)、编写断言 (<code>expect</code>) 和进行模拟。</li>
</ul>
</li>
<li>
<p><strong>React Testing Library (RTL)：</strong></p>
<ul>
<li><strong>角色：</strong> 它是一个<strong>渲染库</strong>，用于渲染 React 组件并提供工具来查询和与这些组件进行交互。</li>
<li><strong>核心理念：</strong> <strong>“越像用户使用你的软件，你的测试就越有信心。”</strong> 它鼓励我们从用户的角度来测试组件，而不是关注内部实现。</li>
<li><strong>核心特点：</strong>
<ul>
<li><strong>关注用户行为：</strong> 优先提供基于可访问性（Accessibility）的查询方法（<code>getByRole</code>, <code>getByLabelText</code>, <code>getByText</code> 等），模拟用户如何与页面互动。</li>
<li><strong>不关注实现细节：</strong> 鼓励测试组件的最终渲染结果和行为，而不是内部状态或生命周期方法。</li>
<li><strong>更接近真实浏览器环境：</strong> 渲染组件到一个轻量级的 DOM 环境中。</li>
</ul>
</li>
<li><strong>用法：</strong> 我用 <code>render</code> 函数来渲染组件，用 <code>screen</code> 对象上的查询方法来获取 DOM 元素，用 <code>fireEvent</code> 来模拟用户事件。</li>
</ul>
</li>
</ul>
<p><strong>我的实践：</strong>
我通常会结合 Jest 和 RTL 来对我的 React 组件进行测试。</p>
<ul>
<li>我会为每个核心业务组件编写单元测试，确保其在不同 <code>props</code> 和 <code>state</code> 下的渲染正确性，以及用户交互（点击、输入）的预期行为。</li>
<li>对于带有异步操作（如 API 请求）的组件，我会使用 Jest 模拟 <code>fetch</code> 或 <code>axios</code>，然后使用 RTL 的 <code>findBy</code> 查询等待异步 UI 更新。</li>
<li>我会确保关键组件的测试覆盖率，并通过 CI/CD 流水线自动化运行测试。</li>
</ul>
<h3 id="用什么工具调试-react-应用">
  用什么工具调试 React 应用？
  <a class="anchor" href="#%e7%94%a8%e4%bb%80%e4%b9%88%e5%b7%a5%e5%85%b7%e8%b0%83%e8%af%95-react-%e5%ba%94%e7%94%a8">#</a>
</h3>
<p>我主要使用以下工具来调试 React 应用：</p>
<ol>
<li>
<p><strong>React DevTools (浏览器扩展)：</strong></p>
<ul>
<li><strong>核心调试利器。</strong> 它是 Chrome/Firefox 的浏览器扩展。</li>
<li><strong>功能：</strong>
<ul>
<li><strong>Components Tab：</strong> 查看组件树、检查组件的 <code>props</code>、<code>state</code>、Context。可以实时修改 <code>props</code> 和 <code>state</code> 来观察 UI 变化。</li>
<li><strong>Profiler Tab：</strong> 记录组件渲染过程，分析渲染性能，找出不必要的重新渲染或性能瓶颈。</li>
<li><strong>Hooks 检查：</strong> 可以查看 Hook 的内部值（如 <code>useState</code> 的值、<code>useRef.current</code> 的值）。</li>
</ul>
</li>
<li><strong>使用场景：</strong> 检查组件状态、定位 <code>props</code> 传递错误、分析渲染性能。</li>
</ul>
</li>
<li>
<p><strong>浏览器开发者工具 (DevTools - Console, Network, Elements)：</strong></p>
<ul>
<li><strong>Console：</strong> 查看 <code>console.log</code> 输出、错误和警告信息。这是排查 JavaScript 运行时错误最直接的方式。</li>
<li><strong>Network：</strong> 监控所有网络请求（API 请求、图片、脚本加载），检查请求头、响应体、状态码、加载时间等。对于排查接口问题、跨域问题、加载性能问题至关重要。</li>
<li><strong>Elements：</strong> 检查和修改页面的真实 DOM 结构和样式，查看元素计算样式、布局等。</li>
<li><strong>Sources：</strong> 设置断点、单步调试 JavaScript 代码，查看变量值、调用堆栈。</li>
</ul>
</li>
<li>
<p><strong>VS Code 调试器：</strong></p>
<ul>
<li><strong>功能：</strong> 如果是在 VS Code 中开发，可以配置内置的 JavaScript 调试器，直接在编辑器中设置断点，单步执行代码，查看变量，比浏览器 DevTools 更方便。</li>
<li><strong>使用场景：</strong> 调试复杂的 JavaScript 逻辑，特别是当问题不是直接发生在 React 渲染层时。</li>
</ul>
</li>
<li>
<p><strong>Redux DevTools (如果使用 Redux)：</strong></p>
<ul>
<li><strong>功能：</strong> 强大的 Redux 专属调试工具，可以时间旅行调试（回溯 Action 和 State 的变化）、查看每个 Action 的详情、State 的前后对比、甚至派发 Action。</li>
<li><strong>使用场景：</strong> 排查 Redux 状态管理问题，理解数据流，调试复杂的异步 Action。</li>
</ul>
</li>
<li>
<p><strong>自定义日志 (console.log / console.warn / console.error)：</strong></p>
<ul>
<li>在开发阶段，合理地插入 <code>console.log</code> 是快速查看变量值和代码执行流程的有效方法。</li>
</ul>
</li>
</ol>
<p><strong>调试策略：</strong>
我通常会从 <strong>React DevTools</strong> 开始，检查组件的 <code>props</code> 和 <code>state</code> 是否符合预期。如果发现数据有问题，再结合<strong>网络面板</strong>检查 API 请求或<strong>控制台</strong>查看 JavaScript 错误。对于更深层次的逻辑错误，会利用 <strong>VS Code 的调试器</strong>或在关键代码处添加 <code>console.log</code> 进行细致排查。</p>
<h3 id="webpack--vite-配置你了解吗">
  Webpack / Vite 配置你了解吗？
  <a class="anchor" href="#webpack--vite-%e9%85%8d%e7%bd%ae%e4%bd%a0%e4%ba%86%e8%a7%a3%e5%90%97">#</a>
</h3>
<p><strong>我了解 Webpack 和 Vite，并在项目中实际配置和使用过。</strong></p>
<hr>
<h3 id="webpack-传统打包工具">
  <strong>Webpack (传统打包工具)</strong>
  <a class="anchor" href="#webpack-%e4%bc%a0%e7%bb%9f%e6%89%93%e5%8c%85%e5%b7%a5%e5%85%b7">#</a>
</h3>
<ul>
<li>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>Entry (入口)：</strong> 指示 Webpack 从哪个文件开始构建其内部依赖图。</li>
<li><strong>Output (输出)：</strong> 告诉 Webpack 在哪里输出打包后的文件，以及如何命名。</li>
<li><strong>Loader (加载器)：</strong> Webpack 自身只能理解 JavaScript 和 JSON 文件。Loader 允许 Webpack 处理其他类型的文件（如 CSS、图片、字体、TypeScript、JSX），将它们转换成有效的模块。
<ul>
<li><strong>常见 Loader：</strong> <code>babel-loader</code> (处理 ES6+/JSX)、<code>css-loader</code> (解析 CSS)、<code>style-loader</code> (将 CSS 注入 DOM)、<code>sass-loader</code> (处理 Sass)、<code>file-loader</code>/<code>url-loader</code> (处理文件)。</li>
</ul>
</li>
<li><strong>Plugin (插件)：</strong> 插件用于执行更广泛的任务，例如打包优化、资源管理、注入环境变量等。它们可以拦截 Webpack 构建流程中的各种事件。
<ul>
<li><strong>常见 Plugin：</strong> <code>HtmlWebpackPlugin</code> (生成 HTML 文件并注入打包后的 JS/CSS)、<code>MiniCssExtractPlugin</code> (提取 CSS 到单独文件)、<code>CleanWebpackPlugin</code> (清理输出目录)、<code>DefinePlugin</code> (定义全局常量)。</li>
</ul>
</li>
<li><strong>Mode (模式)：</strong> <code>development</code> (开发模式，优化构建速度，提供调试信息) 或 <code>production</code> (生产模式，优化输出体积和运行性能)。</li>
</ul>
</li>
<li>
<p><strong>常见配置：</strong></p>
<ul>
<li><strong>模块解析 (resolve)：</strong> 配置模块如何被解析，例如设置别名 (<code>alias</code>) 简化导入路径。</li>
<li><strong>优化 (optimization)：</strong>
<ul>
<li><strong><code>splitChunks</code>：</strong> 代码分割，将公共依赖或第三方库提取到单独的 chunk，利用浏览器缓存。</li>
<li><strong><code>minimizer</code>：</strong> 压缩代码（如 <code>TerserWebpackPlugin</code> 压缩 JS，<code>CssMinimizerWebpackPlugin</code> 压缩 CSS）。</li>
</ul>
</li>
<li><strong>DevServer：</strong> 开发服务器配置，实现热模块替换 (HMR)、代理 (proxy)。</li>
</ul>
</li>
<li>
<p><strong>我的了解和实践：</strong></p>
<ul>
<li>我熟悉 <code>webpack.config.js</code> 的基本结构和常用配置项。</li>
<li>在项目中，我配置过 <code>babel-loader</code> 来编译 React/JSX 和 ESNext 语法。</li>
<li>配置过 <code>css-loader</code> 和 <code>style-loader</code> 来处理样式文件，也用 <code>MiniCssExtractPlugin</code> 提取过 CSS。</li>
<li>利用 <code>HtmlWebpackPlugin</code> 自动化生成 HTML 文件。</li>
<li>利用 <code>splitChunks</code> 优化包体积和缓存策略。</li>
<li>配置 <code>webpack-dev-server</code> 实现热更新和 API 代理。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="vite-新一代构建工具">
  <strong>Vite (新一代构建工具)</strong>
  <a class="anchor" href="#vite-%e6%96%b0%e4%b8%80%e4%bb%a3%e6%9e%84%e5%bb%ba%e5%b7%a5%e5%85%b7">#</a>
</h3>
<ul>
<li>
<p><strong>核心理念：</strong> <strong>基于浏览器 ESM (ES Modules) 的开发模式</strong> 和 <strong>Rollup 生产打包</strong>。</p>
</li>
<li>
<p><strong>开发模式 (Dev Server)：</strong></p>
<ul>
<li><strong>按需编译：</strong> Vite 在开发模式下不需要打包整个应用。它利用浏览器对 ES Modules 的原生支持，只在浏览器请求某个模块时才对其进行转换和提供。</li>
<li><strong>冷启动极快：</strong> 这种按需编译的模式使得 Vite 的开发服务器启动速度极快。</li>
<li><strong>热模块替换 (HMR) 极快：</strong> HMR 的更新只作用于发生变化的模块，并通过 WebSocket 将更新推送到浏览器，而不是重新构建整个模块图，使得 HMR 速度飞快。</li>
</ul>
</li>
<li>
<p><strong>生产打包：</strong></p>
<ul>
<li>Vite 使用 <strong>Rollup</strong> 进行生产环境的打包。Rollup 在打包 JS 库方面表现优秀，其 Tree Shaking 能力强。</li>
</ul>
</li>
<li>
<p><strong>特点：</strong></p>
<ul>
<li><strong>快：</strong> 开发体验的核心优势。</li>
<li><strong>开箱即用：</strong> 对于大多数项目，Vite 几乎是零配置。</li>
<li><strong>插件化：</strong> 基于 Rollup 插件接口，社区提供了丰富的插件。</li>
<li><strong>TypeScript / JSX / CSS 支持：</strong> 内置支持，无需额外配置 Loader。</li>
</ul>
</li>
<li>
<p><strong>我的了解和实践：</strong></p>
<ul>
<li>我认识到 Vite 解决了 Webpack 在大型项目冷启动慢、HMR 更新慢的痛点。</li>
<li>我了解 Vite 通过 <code>vite.config.js</code> 进行配置，相比 Webpack 简洁得多。</li>
<li>我使用过 Vite 的 <code>proxy</code> 配置进行 API 转发。</li>
<li>对于新项目，我更倾向于选择 Vite，因为它能提供更流畅的开发体验。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong> Webpack 强大且灵活，适合各种复杂的场景，但配置相对繁琐，开发模式速度较慢。Vite 则是后起之秀，以其极快的开发模式和极简配置赢得了开发者青睐，尤其适合现代前端项目。</p>
<hr>
<h2 id="-项目实战经验">
  🛠️ 项目实战经验
  <a class="anchor" href="#-%e9%a1%b9%e7%9b%ae%e5%ae%9e%e6%88%98%e7%bb%8f%e9%aa%8c">#</a>
</h2>
<hr>
<h3 id="描述你做过的一个复杂-react-项目">
  描述你做过的一个复杂 React 项目？
  <a class="anchor" href="#%e6%8f%8f%e8%bf%b0%e4%bd%a0%e5%81%9a%e8%bf%87%e7%9a%84%e4%b8%80%e4%b8%aa%e5%a4%8d%e6%9d%82-react-%e9%a1%b9%e7%9b%ae">#</a>
</h3>
<p>（这里需要你结合你简历中“汇丰软件开发（广东）有限公司上海分公司”的经验来组织答案，以下是我的示例框架，你填充具体细节）</p>
<p><strong>项目名称：</strong> &ldquo;我们之前在汇丰参与设计并实现了一个<strong>基于 Java Spring Boot 和 React 的云原生微服务平台</strong>，用于支撑银行内部的某项核心业务（例如：高频交易数据处理 / 金融产品风险评估 / 客户数据管理平台等）。&rdquo;</p>
<p><strong>项目背景和复杂性：</strong></p>
<ul>
<li><strong>高并发/高可用：</strong> 这是一个关键业务系统，要求能够支撑 <strong>5,000+ TPS</strong>，峰值可扩展至<strong>万级并发</strong>，且系统可用性达到 <strong>99.9%+</strong>。这意味着前端组件要能高效渲染，同时后端服务要能快速响应，整个系统要具备极高的容错能力。</li>
<li><strong>数据量大：</strong> 需要处理和展示大量实时或准实时数据，支持 <strong>20,000+ 用户</strong>的数据分析和 AI 模型集成。</li>
<li><strong>安全性/合规性：</strong> 作为银行系统，对数据加密传输、权限校验、审计日志有严格的安全合规要求。</li>
<li><strong>微服务架构：</strong> 整个系统是基于云原生微服务架构，前端需要与多个后端服务进行交互，并处理复杂的跨服务数据流。</li>
<li><strong>前后端协同：</strong> 作为一个全栈工程师，我不仅负责前端，也深入参与了后端和部署运维。</li>
</ul>
<p><strong>我在项目中扮演的角色和职责：</strong></p>
<ul>
<li><strong>前端方面：</strong>
<ul>
<li>负责核心业务模块（例如：交易详情展示、风险指标图表、用户配置界面）的 React 组件设计和开发。</li>
<li>针对大量数据列表，引入了**虚拟化技术（如 <code>react-window</code>）**来提升渲染性能。</li>
<li>实现了复杂的<strong>表单逻辑和校验</strong>（可能使用了 <code>React Hook Form</code>），确保数据输入的准确性。</li>
<li>封装了<strong>通用的数据请求 Hook</strong>，统一处理加载、错误和取消请求，并实现了接口缓存和分页加载，优化用户体验。</li>
<li>参与了前端性能优化，如<strong>组件懒加载和代码分割</strong>，减少初始加载时间。</li>
</ul>
</li>
<li><strong>后端方面：</strong>
<ul>
<li>设计和实现了基于 Spring Boot 的微服务 API 接口，负责数据处理和业务逻辑。</li>
<li>参与了<strong>数据库分片和分布式事务</strong>的设计与实现，以应对高并发场景。</li>
<li>在架构中嵌入了<strong>加密传输、细粒度权限校验（RBAC）和审计日志</strong>，确保安全合规。</li>
</ul>
</li>
<li><strong>DevOps/架构方面：</strong>
<ul>
<li>参与了<strong>云原生微服务平台</strong>的架构设计和选型（Kubernetes, Docker）。</li>
<li>协助搭建和优化 <strong>CI/CD 流水线</strong>（GitLab CI/Jenkins, Terraform IaC），实现了多环境自动化部署，显著提升了研发和发布效率。</li>
<li>协助搭建了 <strong>Prometheus + Grafana 监控平台</strong>，实现系统实时监控、告警和故障定位。</li>
</ul>
</li>
</ul>
<p><strong>项目成果（量化数据）：</strong></p>
<ul>
<li>支撑 <strong>5,000+ TPS</strong>，峰值可扩展至万级并发。</li>
<li>系统可用性达到 <strong>99.9%+</strong>。</li>
<li>平均响应时延降低 <strong>50% 以上</strong>。</li>
<li>故障定位效率提升 <strong>100%</strong>。</li>
<li>CI/CD 流水线执行时间缩短至 <strong>5 分钟</strong>，发布频率提升数倍。</li>
</ul>
<p><strong>遇到的挑战与解决方案：</strong> (挑一个最典型的挑战来展开说，例如：高并发下的数据一致性/性能优化)</p>
<ul>
<li><strong>挑战：</strong> 例如，在处理高并发交易数据时，如何确保数据在分布式数据库（分片）中的<strong>最终一致性</strong>，并保证交易的原子性？</li>
<li><strong>解决方案：</strong> 我们采用了<strong>基于消息队列的最终一致性方案</strong>（如 Kafka）。交易数据首先写入 Kafka，然后由消费者异步处理并写入到不同的数据库分片。对于核心流程，我们结合了<strong>分布式锁</strong>（基于 Redis）来避免并发冲突。同时，使用 <strong><code>@Transactional</code> 结合 Spring Boot 的事务传播机制</strong>来控制单库事务，对于跨库事务，则倾向于采用<strong>柔性事务（如 TCC 或 Saga 模式）</strong>，确保在复杂业务流程中的数据一致性。</li>
</ul>
<p><strong>我在项目中的思考和贡献：</strong></p>
<ul>
<li>作为高级全栈工程师，我不仅关注代码实现，也积极参与了架构设计和技术选型。例如，在选择状态管理方案时，我主导了对 Redux Toolkit 和 <code>react-query</code> 的调研和引入，显著提升了数据层的管理效率和组件的开发体验。</li>
<li>我注重代码质量和可维护性，推行了代码审查和单元测试，并积极编写技术文档。</li>
</ul>
<hr>
<h3 id="项目中遇到过哪些性能问题怎么解决的">
  项目中遇到过哪些性能问题？怎么解决的？
  <a class="anchor" href="#%e9%a1%b9%e7%9b%ae%e4%b8%ad%e9%81%87%e5%88%b0%e8%bf%87%e5%93%aa%e4%ba%9b%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3%e7%9a%84">#</a>
</h3>
<p>（结合你在汇丰的经验，从前端和后端挑1-2个具体例子）</p>
<p>我在多个项目中都遇到过性能问题，解决这些问题是提升用户体验和系统稳定性的关键。以下是一个我记忆深刻的例子：</p>
<p><strong>案例：长列表渲染性能问题</strong></p>
<ul>
<li><strong>问题描述：</strong>
<ul>
<li>在一个展示大量交易明细（可能达到几千甚至上万条记录）的页面中，用户在加载或滚动时会明显感觉到页面卡顿、响应迟钝。初步分析发现，页面首次加载时间很长，并且滚动时 CPU 使用率飙升。</li>
</ul>
</li>
<li><strong>诊断过程：</strong>
<ul>
<li><strong>首先，使用浏览器开发者工具（Performance Tab）进行性能分析。</strong> 发现大量的<strong>脚本执行时间</strong>和<strong>布局/重绘时间</strong>。</li>
<li><strong>React DevTools 的 Profiler Tab</strong> 显示，每次滚动或数据更新时，整个包含大量列表项的父组件都在进行<strong>不必要的重新渲染</strong>，并且生成了大量的 DOM 节点。</li>
<li><strong>初步判断：</strong> 主要瓶颈在于一次性渲染了过多的 DOM 节点，以及 React 在处理这些节点时进行了大量的 Diff 和 DOM 操作。</li>
</ul>
</li>
<li><strong>解决方案：</strong>
<ol>
<li><strong>引入列表虚拟化 (Virtualization)：</strong>
<ul>
<li>决定使用 <strong><code>react-window</code></strong> 库。它只渲染用户当前可见区域内的列表项，并对不可见区域的列表项进行高度占位。</li>
<li>将数据源和渲染逻辑适配 <code>FixedSizeList</code> 或 <code>VariableSizeList</code> 组件。</li>
<li><strong>效果：</strong> 页面 DOM 节点数量从上万个骤降到几十个（取决于视口大小），滚动性能瞬间流畅，CPU 占用率大幅下降。</li>
</ul>
</li>
<li><strong>优化数据源和更新策略：</strong>
<ul>
<li><strong>结合分页加载：</strong> 如果是无限滚动，确保不是一次性把所有数据都加载到前端，而是根据滚动位置<strong>懒加载</strong>更多数据。</li>
<li><strong>数据不可变性：</strong> 确保更新列表数据时，始终创建新的数组引用，而不是直接修改原数组，以便 React 的 Diff 算法能正确进行浅比较。</li>
<li><strong><code>key</code> 的正确使用：</strong> 确保每个列表项都有一个稳定且唯一的 <code>key</code>（通常是后端返回的唯一 ID），避免虚拟化库内部因 <code>key</code> 变化而导致的错误复用和重新渲染。</li>
</ul>
</li>
</ol>
</li>
<li><strong>成果：</strong>
<ul>
<li>页面<strong>首次加载时间缩短了约 60%</strong>。</li>
<li><strong>滚动流畅度显著提升</strong>，从肉眼可见的卡顿变为平滑滚动。</li>
<li>浏览器 CPU 和内存占用<strong>大幅降低</strong>。</li>
<li>用户体验得到极大改善，能够高效地浏览和分析大量数据。</li>
</ul>
</li>
</ul>
<p><strong>其他可能遇到的性能问题和解决方案（可作为备选案例）：</strong></p>
<ul>
<li><strong>后端 API 响应慢：</strong> 检查后端日志、数据库慢查询、引入 Redis 缓存、优化 SQL、读写分离、数据库分片。</li>
<li><strong>网络请求过多/过大：</strong> 接口合并、数据压缩、图片懒加载、CDN 加速、HTTP 缓存。</li>
<li><strong>组件不必要的重渲染：</strong> 使用 <code>React.memo</code> / <code>useCallback</code> / <code>useMemo</code>。</li>
<li><strong>JS 逻辑计算耗时：</strong> 将复杂计算放入 Web Worker、或使用 <code>useMemo</code> 记忆化。</li>
</ul>
<h3 id="你是如何组织组件结构和模块的">
  你是如何组织组件结构和模块的？
  <a class="anchor" href="#%e4%bd%a0%e6%98%af%e5%a6%82%e4%bd%95%e7%bb%84%e7%bb%87%e7%bb%84%e4%bb%b6%e7%bb%93%e6%9e%84%e5%92%8c%e6%a8%a1%e5%9d%97%e7%9a%84">#</a>
</h3>
<p>我通常采用一种<strong>功能导向（或领域驱动）与职责分离</strong>相结合的组件和模块组织方式，以提高项目的可维护性、可扩展性和开发效率。</p>
<p><strong>核心思想：</strong></p>
<ol>
<li><strong>高内聚，低耦合：</strong> 组件和模块内部功能紧密相关，相互之间的依赖尽可能少。</li>
<li><strong>可读性与可查找性：</strong> 目录结构清晰，易于团队成员理解和找到相关代码。</li>
<li><strong>可复用性：</strong> 尽可能提取通用组件和逻辑。</li>
</ol>
<p><strong>具体的组织结构（示例）：</strong></p>
<pre tabindex="0"><code>src/
├── assets/                  # 静态资源（图片、字体、全局样式）
│   ├── images/
│   ├── fonts/
│   └── styles/
│       ├── _variables.scss  # Sass 变量
│       ├── _mixins.scss     # Sass 混入
│       └── global.scss      # 全局样式
│
├── components/              # 通用/UI组件 (Dumb Components)
│   ├── Button/
│   │   ├── Button.jsx
│   │   └── index.js
│   ├── Modal/
│   │   ├── Modal.jsx
│   │   └── index.js
│   ├── Table/
│   │   ├── Table.jsx
│   │   └── index.js
│   └── LoadingSpinner/
│       └── LoadingSpinner.jsx
│
├── features/                # 业务功能模块 (Smart Components / Containers) - 按业务领域划分
│   ├── UserManagement/      # 用户管理模块
│   │   ├── components/      # 该模块内部的UI组件
│   │   │   ├── UserListTable.jsx
│   │   │   └── UserForm.jsx
│   │   ├── hooks/           # 该模块内部的自定义Hook
│   │   │   └── useUsersData.js
│   │   ├── pages/           # 路由页面组件
│   │   │   └── UserListPage.jsx
│   │   ├── services/        # 模块相关的API服务
│   │   │   └── userService.js
│   │   └── index.js         # 导出模块公共接口
│   ├── ProductCatalog/      # 产品目录模块
│   │   └── ...
│   └── OrderProcessing/     # 订单处理模块
│       └── ...
│
├── hooks/                   # 通用自定义Hook (跨模块复用)
│   ├── useDebounce.js
│   ├── useLocalStorage.js
│   └── useClickOutside.js
│
├── services/                # 全局或通用的 API 服务
│   ├── authService.js
│   └── apiClient.js         # 封装 Axios 或 Fetch
│
├── store/                   # 全局状态管理 (Redux/Zustand等)
│   ├── index.js             # Store 配置
│   ├── userSlice.js         # Redux Toolkit 的 Slice
│   ├── authSlice.js
│   └── ...
│
├── utils/                   # 工具函数和常量
│   ├── constants.js
│   ├── helpers.js
│   ├── validators.js
│   └── dateUtils.js
│
├── router/                  # 路由配置
│   ├── index.js             # 主路由配置
│   └── routes.js            # 路由定义
│
├── App.jsx                  # 应用根组件
├── index.js                 # 入口文件
└── reportWebVitals.js
</code></pre><p><strong>我的实践和原则：</strong></p>
<ol>
<li><strong>按功能/领域划分 (Feature-based)：</strong> 这是最重要的原则。将与特定业务功能相关的组件、Hook、服务、页面等都放在一个独立的 <code>features</code> 目录下。这使得团队更容易理解某个功能的全部代码，也方便未来进行拆分或独立部署。</li>
<li><strong>UI 组件与业务组件分离：</strong> <code>components</code> 目录存放可复用的、与业务逻辑无关的<strong>哑组件 (Dumb Components)</strong>，它们只负责渲染 UI 和接收 <code>props</code>。<code>features</code> 目录下的组件（通常是页面组件或容器组件）则包含业务逻辑和状态，它们会组合使用 <code>components</code> 目录下的 UI 组件。</li>
<li><strong>Hooks 集中管理：</strong> 分为 <code>hooks/</code>（通用 Hook）和 <code>features/*/hooks/</code>（特定业务 Hook），清晰地表达其复用范围。</li>
<li><strong>服务层抽象：</strong> 所有的 API 请求都封装在 <code>services</code> 目录下，与组件解耦。可以进一步按业务模块细分。</li>
<li><strong>全局状态：</strong> <code>store</code> 目录集中管理全局状态（如 Redux store），并按模块 (<code>slice</code>) 进行划分。</li>
<li><strong>路由集中：</strong> 独立的 <code>router</code> 目录管理路由配置，便于维护和实现路由懒加载。</li>
<li><strong>入口文件：</strong> <code>App.jsx</code> 和 <code>index.js</code> 保持简洁，主要用于初始化应用和挂载根组件。</li>
</ol>
<p>这种结构在我的项目中表现良好，特别是在团队协作和项目迭代过程中，能够清晰地划分职责，降低沟通成本，并有效支撑项目的扩展。</p>
<h3 id="在-react-项目中做过哪些抽象封装">
  在 React 项目中做过哪些抽象/封装？
  <a class="anchor" href="#%e5%9c%a8-react-%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%81%9a%e8%bf%87%e5%93%aa%e4%ba%9b%e6%8a%bd%e8%b1%a1%e5%b0%81%e8%a3%85">#</a>
</h3>
<p>在 React 项目中，我主要在以下几个层面进行抽象和封装，以提高代码复用性、可维护性和开发效率：</p>
<ol>
<li>
<p><strong>自定义 Hook 封装（逻辑复用核心）：</strong></p>
<ul>
<li><strong>职责：</strong> 这是我最主要的抽象方式，用于封装和复用<strong>状态逻辑和副作用</strong>。</li>
<li><strong>例子：</strong>
<ul>
<li><strong><code>useFetchData</code> / <code>useApi</code>：</strong> 封装数据请求、加载状态、错误处理、取消请求、缓存等。</li>
<li><strong><code>useForm</code> / <code>useValidation</code>：</strong> 封装表单字段的状态管理、验证逻辑、提交处理。</li>
<li><strong><code>useLocalStorage</code>：</strong> 封装与浏览器本地存储的交互。</li>
<li><strong><code>useDebounce</code> / <code>useThrottle</code>：</strong> 封装防抖/节流逻辑。</li>
<li><strong><code>useClickOutside</code>：</strong> 封装点击组件外部的事件监听。</li>
</ul>
</li>
<li><strong>效果：</strong> 极大地减少了组件内部的样板代码，使组件更专注于 UI 渲染，逻辑更清晰，也更容易进行单元测试。</li>
</ul>
</li>
<li>
<p><strong>UI 组件/通用组件封装：</strong></p>
<ul>
<li><strong>职责：</strong> 封装与业务逻辑无关的、可复用的 UI 元素。</li>
<li><strong>例子：</strong> <code>Button</code>、<code>Input</code>、<code>Modal</code>、<code>Table</code>、<code>LoadingSpinner</code>、<code>DatePicker</code> 等。这些组件通常是“哑组件”或“展示型组件”，只接收 <code>props</code> 来控制外观和行为。</li>
<li><strong>效果：</strong> 确保 UI 风格的一致性，提高开发效率，降低维护成本。</li>
</ul>
</li>
<li>
<p><strong>API 请求层封装：</strong></p>
<ul>
<li><strong>职责：</strong> 统一管理所有后端 API 请求，处理公共逻辑。</li>
<li><strong>例子：</strong> 封装 <code>axios</code> 或 <code>fetch</code>。
<ul>
<li><strong>统一的请求配置：</strong> 基础 URL、请求头（如 <code>Authorization Token</code>、<code>Content-Type</code>）。</li>
<li><strong>请求拦截器：</strong> 添加认证 Token、记录请求日志、处理全局 loading 状态。</li>
<li><strong>响应拦截器：</strong> 统一处理错误码（如 401 未认证、403 无权限）、解析响应数据、统一错误提示。</li>
<li><strong>取消请求机制：</strong> 封装 <code>AbortController</code>。</li>
</ul>
</li>
<li><strong>效果：</strong> 集中管理网络请求逻辑，提高代码健壮性和可维护性，减少每个业务模块对请求细节的关注。</li>
</ul>
</li>
<li>
<p><strong>状态管理模块抽象（如果使用 Redux/Zustand）：</strong></p>
<ul>
<li><strong>职责：</strong> 抽象 Redux 的 <code>reducer</code>、<code>action</code>、<code>selector</code> 或 Zustand 的 <code>store</code> 定义。</li>
<li><strong>例子：</strong>
<ul>
<li>在使用 Redux Toolkit 时，我会将每个业务模块的状态定义为一个 <code>slice</code>，其中包含了 <code>reducer</code>、<code>action creator</code> 和 <code>selector</code>，实现了状态的模块化封装。</li>
<li>在使用 Zustand 时，我会将 <code>store</code> 的定义、其中的 <code>state</code> 和 <code>actions</code> 封装在一个单独的文件中。</li>
</ul>
</li>
<li><strong>效果：</strong> 清晰地定义了每个业务领域的状态和状态变更逻辑，提高了状态管理的可预测性和可测试性。</li>
</ul>
</li>
<li>
<p><strong>工具函数库：</strong></p>
<ul>
<li><strong>职责：</strong> 封装与业务无关的、通用的 JavaScript 工具函数。</li>
<li><strong>例子：</strong> 日期格式化、字符串处理、数据验证辅助函数、数值计算等。</li>
<li><strong>效果：</strong> 避免代码重复，提高代码可读性和可维护性。</li>
</ul>
</li>
</ol>
<p>这些抽象和封装策略使得我的 React 项目能够从一个小型的 Demo 扩展到一个复杂的企业级应用，同时保持了良好的代码质量和开发效率。</p>
<h3 id="和后端如何对接有没有封装请求库">
  和后端如何对接？有没有封装请求库？
  <a class="anchor" href="#%e5%92%8c%e5%90%8e%e7%ab%af%e5%a6%82%e4%bd%95%e5%af%b9%e6%8e%a5%e6%9c%89%e6%b2%a1%e6%9c%89%e5%b0%81%e8%a3%85%e8%af%b7%e6%b1%82%e5%ba%93">#</a>
</h3>
<p>在我的 React 项目中，与后端对接是一个非常重要的环节，我通常会采取以下策略和步骤：</p>
<ol>
<li>
<p><strong>明确 API 文档和接口规范：</strong></p>
<ul>
<li>在项目开始阶段，会与后端团队共同定义详细的 <strong>API 文档</strong>（如使用 Swagger/OpenAPI、Postman Collections）。这包括接口 URL、请求方法（GET/POST/PUT/DELETE）、请求参数（Query Params, Request Body）、响应结构（成功/失败）、错误码定义等。</li>
<li>明确前后端数据传输格式（通常是 <strong>JSON</strong>）。</li>
</ul>
</li>
<li>
<p><strong>封装请求库 (Service Layer)：</strong></p>
<ul>
<li><strong>是的，我一定会封装请求库。</strong> 这是前端项目工程化和提高可维护性的重要一环。</li>
<li><strong>选择：</strong> 我主要使用 <strong><code>axios</code></strong> 作为 HTTP 客户端，因为它提供了强大的拦截器、取消请求、超时设置等功能。</li>
<li><strong>封装内容：</strong>
<ul>
<li><strong>基本配置：</strong> 设置 <code>baseURL</code>（开发和生产环境）、<code>timeout</code>。</li>
<li><strong>请求拦截器 (Request Interceptors)：</strong>
<ul>
<li><strong>添加认证 Token：</strong> 自动在每个请求头中加入 <code>Authorization</code> Token (如 JWT)。</li>
<li><strong>统一参数处理：</strong> 例如，统一对 GET 请求的参数进行序列化。</li>
<li><strong>全局 Loading 状态：</strong> 在请求开始时显示全局 loading 动画。</li>
<li><strong>日志记录：</strong> 记录请求 URL、方法等信息，方便调试。</li>
</ul>
</li>
<li><strong>响应拦截器 (Response Interceptors)：</strong>
<ul>
<li><strong>统一错误处理：</strong> 根据后端返回的 HTTP 状态码或业务错误码进行统一处理（如 401 未认证时跳转登录页，403 无权限时显示提示信息）。</li>
<li><strong>数据结构解构：</strong> 如果后端响应体有统一的封装（如 <code>{ code: 0, message: 'Success', data: {} }</code>），则在拦截器中直接返回 <code>data</code> 部分。</li>
<li><strong>全局错误提示：</strong> 对某些错误码，自动弹出统一的错误提示消息（如 Toast）。</li>
<li><strong>全局 Loading 状态结束。</strong></li>
</ul>
</li>
<li><strong>取消请求：</strong> 封装 <code>AbortController</code> 机制，允许组件在卸载或请求过期时取消未完成的请求。</li>
</ul>
</li>
<li><strong>示例代码结构：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// src/services/apiClient.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">axios</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;axios&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">apiClient</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">axios</span>.<span style="color:#a6e22e">create</span>({
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">baseURL</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span>.<span style="color:#a6e22e">REACT_APP_API_BASE_URL</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">&#39;/api&#39;</span>, <span style="color:#75715e">// 环境变量配置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">timeout</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">10000</span>, <span style="color:#75715e">// 10秒超时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">headers</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;Content-Type&#39;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;application/json&#39;</span>,
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 请求拦截器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">apiClient</span>.<span style="color:#a6e22e">interceptors</span>.<span style="color:#a6e22e">request</span>.<span style="color:#a6e22e">use</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">config</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从 localStorage 或 Redux store 获取 token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">token</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">getItem</span>(<span style="color:#e6db74">&#39;authToken&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">token</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">headers</span>.<span style="color:#a6e22e">Authorization</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`Bearer </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">token</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 可以添加全局 loading 状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// showGlobalLoading();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">config</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">error</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 响应拦截器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">apiClient</span>.<span style="color:#a6e22e">interceptors</span>.<span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">use</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">response</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// hideGlobalLoading();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果后端有统一的数据结构，这里可以只返回实际的数据部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">data</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">code</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">data</span>; <span style="color:#75715e">// 返回业务数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">data</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">message</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 处理业务错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// showToast(response.data.message, &#39;error&#39;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#66d9ef">new</span> Error(<span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">message</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">response</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">error</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// hideGlobalLoading();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">error</span>.<span style="color:#a6e22e">response</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">data</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">error</span>.<span style="color:#a6e22e">response</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">401</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 处理未认证，例如跳转到登录页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// redirectToLogin();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// showToast(&#39;认证失败，请重新登录&#39;, &#39;error&#39;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">403</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 处理无权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// showToast(&#39;无访问权限&#39;, &#39;error&#39;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// showToast(data.message || &#39;请求失败&#39;, &#39;error&#39;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">error</span>.<span style="color:#a6e22e">request</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 请求已发送但未收到响应
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// showToast(&#39;网络错误或服务器无响应&#39;, &#39;error&#39;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 请求设置时发生错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// showToast(&#39;请求配置错误&#39;, &#39;error&#39;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#a6e22e">apiClient</span>;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>业务 API 服务模块：</strong></p>
<ul>
<li>对于每个业务模块，我会创建独立的 API 服务文件，统一管理该模块相关的接口。</li>
<li><strong>例子：</strong> <code>src/services/userService.js</code>, <code>src/services/productService.js</code></li>
<li>这些文件会导入上面封装的 <code>apiClient</code>，并提供具体的业务方法。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// src/services/userService.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">apiClient</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./apiClient&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">getUsers</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">params</span>) =&gt; <span style="color:#a6e22e">apiClient</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#39;/users&#39;</span>, { <span style="color:#a6e22e">params</span> });
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">getUserById</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">id</span>) =&gt; <span style="color:#a6e22e">apiClient</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">`/users/</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">id</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">createUser</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">data</span>) =&gt; <span style="color:#a6e22e">apiClient</span>.<span style="color:#a6e22e">post</span>(<span style="color:#e6db74">&#39;/users&#39;</span>, <span style="color:#a6e22e">data</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span></code></pre></div></li>
<li>
<p><strong>在组件或 Hook 中调用：</strong></p>
<ul>
<li>组件或自定义 Hook 会调用这些业务 API 服务方法来获取或提交数据。</li>
<li>我倾向于使用<strong>自定义 Hook (如 <code>useQuery</code> from <code>react-query</code> 或自定义 <code>useFetchData</code> )</strong> 来封装数据请求的生命周期，包括加载、错误、数据状态管理，并在此处调用 <code>userService.getUsers()</code> 等方法。</li>
</ul>
</li>
</ol>
<p>通过这种分层的对接方式，我能够确保前端与后端交互的健壮性、可维护性和高效率。</p>
<hr>
<h2 id="-进阶与框架原理">
  🧠 进阶与框架原理
  <a class="anchor" href="#-%e8%bf%9b%e9%98%b6%e4%b8%8e%e6%a1%86%e6%9e%b6%e5%8e%9f%e7%90%86">#</a>
</h2>
<hr>
<h3 id="react-中-setstate-是同步还是异步的为什么">
  React 中 setState 是同步还是异步的？为什么？
  <a class="anchor" href="#react-%e4%b8%ad-setstate-%e6%98%af%e5%90%8c%e6%ad%a5%e8%bf%98%e6%98%af%e5%bc%82%e6%ad%a5%e7%9a%84%e4%b8%ba%e4%bb%80%e4%b9%88">#</a>
</h3>
<p>在 React 中，<strong><code>setState</code>（包括函数组件的 <code>useState</code> 更新函数）既可以是同步的，也可以是异步的，这取决于它在什么上下文被调用。</strong></p>
<p><strong>概括：</strong></p>
<ul>
<li>在 <strong>React 内部的事件处理函数和生命周期方法中</strong>，<code>setState</code> 是<strong>异步</strong>的（批处理）。</li>
<li>在 <strong>原生事件处理函数或异步代码（如 <code>setTimeout</code>、<code>Promise</code> 回调）中</strong>，<code>setState</code> 是<strong>同步</strong>的。</li>
<li><strong>React 18 之后，所有 <code>setState</code> 调用默认都是异步的（自动批处理），无论在何种上下文。</strong></li>
</ul>
<p><strong>为什么会这样？（React 18 之前的机制）</strong>
这是因为 React 有一个<strong>批处理 (Batching)</strong> 机制。</p>
<ol>
<li><strong>为了性能优化：</strong> 如果每次 <code>setState</code> 调用都立即更新 DOM，会导致频繁的重绘和回流，性能极差。</li>
<li><strong>防止不一致的 UI 状态：</strong> 在一个事件循环中，如果多个状态更新是同步的，可能会导致中间状态的 UI 闪烁。</li>
</ol>
<p><strong>批处理机制：</strong>
当你在 React 内部的事件处理函数（例如 <code>onClick</code>、<code>onChange</code> 等合成事件）中多次调用 <code>setState</code> 时，React 会将这些更新<strong>合并 (batch)</strong> 起来，在<strong>一个事件循环结束时统一执行一次真实的 DOM 更新</strong>。这确保了：</p>
<ul>
<li><strong>更少的 DOM 操作：</strong> 所有的 <code>setState</code> 调用只触发一次 DOM 渲染。</li>
<li><strong>更好的性能：</strong> 避免了不必要的重复计算和渲染。</li>
<li><strong>状态一致性：</strong> 保证在一个事件内，组件的 <code>props</code> 和 <code>state</code> 处于一个一致的最终状态。</li>
</ul>
<p><strong>示例（React 18 之前）：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// React 18 之前
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">MyComponent</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">setCount</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleClick</span> <span style="color:#f92672">=</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setCount</span>(<span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 第一次调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">count</span>); <span style="color:#75715e">// 0 (旧值，因为 setState 异步)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setCount</span>(<span style="color:#a6e22e">prev</span> =&gt; <span style="color:#a6e22e">prev</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 第二次调用 (函数式更新，会被合并)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">count</span>); <span style="color:#75715e">// 0 (旧值)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 上述两个 setCount 会被批处理，最终 count 会变成 2，但 console.log 看到的是旧值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleAsyncClick</span> <span style="color:#f92672">=</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">setCount</span>(<span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 第一次调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">count</span>); <span style="color:#75715e">// 可能是 0 或 1 (取决于 timing，但这里通常是同步更新)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">setCount</span>(<span style="color:#a6e22e">prev</span> =&gt; <span style="color:#a6e22e">prev</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 第二次调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">count</span>); <span style="color:#75715e">// 可能是 1 或 2 (同步更新)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// 在 setTimeout 中，每个 setState 都会同步更新并触发渲染
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>React 18 后的变化：自动批处理 (Automatic Batching)</strong>
React 18 引入了<strong>自动批处理</strong>。现在，无论 <code>setState</code> 是在 React 事件处理函数、原生事件、<code>setTimeout</code> 还是 Promise 回调中调用，它都将默认被批处理。这意味着所有这些更新都将在下一个渲染中一起处理，除非你明确选择退出批处理（使用 <code>ReactDOM.flushSync</code>）。</p>
<p><strong>好处：</strong> 进一步简化了开发者对 <code>setState</code> 行为的理解，并提升了应用在更多场景下的性能。</p>
<h3 id="什么是调和reconciliation">
  什么是调和（Reconciliation）？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%b0%83%e5%92%8creconciliation">#</a>
</h3>
<p><strong>调和（Reconciliation）</strong> 是 React 的核心算法。它指的是 React 在组件状态（或 <code>props</code>）发生变化时，<strong>更新 UI 的过程</strong>。这个过程涉及将新的 React 元素树（虚拟 DOM）与之前的 React 元素树进行比较，以确定对真实 DOM 做出哪些最小的更改。</p>
<p><strong>调和过程的步骤：</strong></p>
<ol>
<li><strong>触发更新：</strong> 当组件的 <code>state</code> 或 <code>props</code> 发生变化时，会触发一次重新渲染。</li>
<li><strong>生成新的虚拟 DOM 树：</strong> React 会调用组件的 <code>render</code> 方法（或函数组件的体），生成一棵新的 React 元素树（也就是新的虚拟 DOM）。</li>
<li><strong>Diff 算法比较：</strong> React 会将这棵新的虚拟 DOM 树与上一次渲染的虚拟 DOM 树进行<strong>递归比较</strong>。这就是所谓的 <strong>Diff 算法</strong>。
<ul>
<li><strong>核心规则：</strong>
<ul>
<li><strong>元素类型不同：</strong> 如果两个元素的类型不同（例如，<code>&lt;div&gt;</code> 变为 <code>&lt;span&gt;</code>），React 会销毁旧树，并从头开始构建新树。</li>
<li><strong>元素类型相同：</strong> 如果两个元素的类型相同，React 会比较它们的属性。只有发生改变的属性会被更新到真实 DOM 上。</li>
<li><strong>列表比较（通过 <code>key</code>）：</strong> 对于列表，React 使用 <code>key</code> 属性来识别元素。如果 <code>key</code> 相同，则认为它们是同一个组件，会尝试复用；如果 <code>key</code> 不同，则销毁重建。</li>
</ul>
</li>
</ul>
</li>
<li><strong>生成更新队列 (Patch)：</strong> Diff 算法会计算出最小的更新集合，形成一个“补丁” (patch) 或“更新队列”。</li>
<li><strong>更新真实 DOM：</strong> React 将这个补丁应用到真实的 DOM 上，只执行必要的 DOM 操作（插入、删除、更新属性）。这使得 React 能够高效地更新 UI，避免了代价昂贵的整体 DOM 重绘。</li>
</ol>
<p><strong>为什么叫“调和”而不是“渲染”？</strong>
“渲染”通常指将数据转化为可视化形式的过程。而“调和”更强调的是<strong>比较和协调</strong>旧的 UI 状态与新的 UI 状态，并找出最小的差异以达到最终状态的过程。</p>
<h3 id="fiber-架构解决了什么问题">
  Fiber 架构解决了什么问题？
  <a class="anchor" href="#fiber-%e6%9e%b6%e6%9e%84%e8%a7%a3%e5%86%b3%e4%ba%86%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98">#</a>
</h3>
<p>Fiber 是 React 16 引入的一个全新的<strong>核心算法的重写</strong>。它解决了之前 React Stack Reconciler（栈调和器）存在的<strong>主要问题：长任务阻塞主线程，导致页面卡顿。</strong></p>
<p><strong>Stack Reconciler 的问题 (React 15 及以前)：</strong></p>
<ul>
<li><strong>递归执行：</strong> 调和过程是同步的、递归执行的。一旦开始渲染，就会一口气处理完整个组件树的 Diff 过程，直到完成。</li>
<li><strong>阻塞主线程：</strong> 如果组件树非常深、组件数量非常多，或者某个组件的 <code>render</code> 过程计算量很大，整个 Diff 过程可能会持续很长时间。由于 JavaScript 是单线程的，这会阻塞浏览器的主线程，导致页面长时间无响应，用户无法进行操作，出现卡顿。</li>
</ul>
<p><strong>Fiber 架构如何解决这些问题：</strong></p>
<ol>
<li>
<p><strong>可中断和可恢复的更新：</strong></p>
<ul>
<li>Fiber 将 React 内部的协调工作分解成一个个小的**“工作单元”（Fiber）**。</li>
<li>每个 Fiber 代表一个组件或一个 DOM 节点。</li>
<li>协调过程不再是同步递归，而是可以<strong>暂停和恢复</strong>的。React 可以在完成一部分工作后，将控制权交还给浏览器，让浏览器处理优先级更高的任务（如用户输入、动画），然后再继续之前中断的工作。</li>
<li>这种能力称为**“可中断渲染” (Interruptible Rendering)**，是实现 Concurrent Mode 和 Suspense 的基础。</li>
</ul>
</li>
<li>
<p><strong>优先级调度 (Prioritization)：</strong></p>
<ul>
<li>Fiber 引入了<strong>任务优先级</strong>的概念。React 可以根据不同的更新类型（如用户输入、动画、网络请求等）分配不同的优先级。</li>
<li>高优先级的更新可以中断低优先级的更新，优先得到执行和渲染，确保关键用户交互的及时响应。</li>
</ul>
</li>
<li>
<p><strong>双缓冲机制 (Double Buffering)：</strong></p>
<ul>
<li>Fiber 维护两棵 Fiber 树：<strong>“Current”树</strong>（当前在屏幕上显示的状态）和**“WorkInProgress”树**（正在构建的、即将变成下一个 Current 树的草稿）。</li>
<li>所有的更新操作都在 WorkInProgress 树上进行。当 WorkInProgress 树构建完成后，并且所有副作用都处理完毕，React 会通过一个简单的指针切换，将 WorkInProgress 树变为新的 Current 树，一次性提交到真实 DOM。</li>
<li>这保证了 UI 更新的<strong>原子性</strong>和<strong>一致性</strong>，用户不会看到中间状态或不完整的 UI。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong> Fiber 架构将 React 的协调过程从同步的、不可中断的递归模型，转变为<strong>异步的、可中断的增量更新模型</strong>。这使得 React 能够更好地利用浏览器空闲时间，响应用户交互，并为未来的并发模式（Concurrent Mode）和 Suspense 等高级特性奠定了基础，从而提供更流畅的用户体验。</p>
<h3 id="concurrent-mode-和-suspense-知道多少">
  Concurrent Mode 和 Suspense 知道多少？
  <a class="anchor" href="#concurrent-mode-%e5%92%8c-suspense-%e7%9f%a5%e9%81%93%e5%a4%9a%e5%b0%91">#</a>
</h3>
<p><strong>Concurrent Mode (并发模式)</strong> 和 <strong>Suspense</strong> 是 React 18 引入的强大新特性，它们基于 Fiber 架构，旨在提升用户体验和应用性能。</p>
<p><strong>1. Concurrent Mode (并发模式)：</strong></p>
<ul>
<li><strong>核心思想：</strong> 允许 React <strong>同时处理多个任务</strong>（例如，一个用户输入事件和一个数据获取）。它通过<strong>可中断渲染和优先级调度</strong>来实现。</li>
<li><strong>解决了什么问题：</strong> 解决了 React 15 及其以前版本中由于同步渲染可能导致页面卡顿的问题。在并发模式下，即使有大量或昂贵的更新，React 也能在后台准备新的 UI，同时不阻塞用户交互。</li>
<li><strong>工作原理：</strong>
<ul>
<li>React 会在后台构建新的 Fiber 树（“WorkInProgress”树）。</li>
<li>在构建过程中，如果优先级更高的任务（如用户输入）到来，React 可以暂停当前正在进行的低优先级渲染任务，优先处理高优先级任务，等高优先级任务完成后再继续之前的低优先级任务。</li>
<li>只有当新的 UI 准备好并完全一致时，React 才会将其一次性提交到真实的 DOM。</li>
</ul>
</li>
<li><strong>状态：</strong> 在 React 18 中，Concurrent Mode 并不是一个单独的“模式”开关，而是作为 React 的默认行为和底层优化自动启用。例如，<code>startTransition</code> API 允许你标记更新为“可中断的过渡”。</li>
<li><strong>优势：</strong>
<ul>
<li><strong>更流畅的用户体验：</strong> 应用程序在处理大量或计算密集型任务时仍能保持响应。</li>
<li><strong>更好的交互性：</strong> 用户输入、动画等高优先级任务可以优先响应。</li>
</ul>
</li>
</ul>
<p><strong>2. Suspense：</strong></p>
<ul>
<li><strong>核心思想：</strong> 允许组件“等待”某个异步操作完成，并在等待期间显示一个回退 (fallback) UI。它让数据获取等异步操作的加载状态管理变得声明式，而不是命令式。</li>
<li><strong>解决了什么问题：</strong> 解决了传统数据获取中“瀑布式请求”和手动管理 <code>isLoading</code> 状态的繁琐问题。</li>
<li><strong>工作原理：</strong>
<ul>
<li>当一个组件（或其内部的子组件）“挂起” (suspends) 时（例如，它内部的数据请求尚未完成），React 会捕获这个挂起，并渲染最近的 <code>&lt;Suspense&gt;</code> 祖先组件的 <code>fallback</code> prop。</li>
<li>一旦异步操作完成，组件数据准备就绪，React 就会替换 <code>fallback</code> UI，渲染真实的组件内容。</li>
</ul>
</li>
<li><strong>常见用途：</strong>
<ul>
<li><strong>组件懒加载：</strong> <code>React.lazy</code> 和 <code>Suspense</code> 结合实现代码分割和按需加载。</li>
<li><strong>数据获取：</strong> (未来的主要用例) 结合支持 Suspense 的数据获取库（如 <code>react-query</code> 的 experimental Suspense 模式），可以直接在组件中调用数据获取逻辑，而无需手动管理 <code>loading</code> 状态。</li>
</ul>
</li>
<li><strong>优势：</strong>
<ul>
<li><strong>声明式数据加载：</strong> 简化了异步数据加载的 UI 逻辑。</li>
<li><strong>改善用户体验：</strong> 避免了组件加载时的闪烁和不一致性，提供更平滑的加载过渡。</li>
<li><strong>避免瀑布式请求：</strong> 理论上能更好地协调并行数据获取。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong> Concurrent Mode 是 React 内部的调度能力，使得 React 能够更智能地处理和渲染更新。Suspense 是暴露给开发者的一种能力，让我们可以声明式地处理异步资源的加载状态，并利用 Concurrent Mode 的底层能力提供更好的用户体验。它们共同是 React 未来发展的重要方向。</p>
<h3 id="react-18-引入了哪些新特性">
  React 18 引入了哪些新特性？
  <a class="anchor" href="#react-18-%e5%bc%95%e5%85%a5%e4%ba%86%e5%93%aa%e4%ba%9b%e6%96%b0%e7%89%b9%e6%80%a7">#</a>
</h3>
<p>React 18 带来了许多重要的更新，主要关注<strong>性能优化、用户体验提升和新的并发特性</strong>。核心新特性包括：</p>
<ol>
<li>
<p><strong>自动批处理 (Automatic Batching)：</strong></p>
<ul>
<li><strong>作用：</strong> 无论 <code>setState</code> 调用在何处（包括事件处理函数、Promise 回调、<code>setTimeout</code> 等），React 都会<strong>自动将多个状态更新合并成一个批次</strong>，在一次渲染中完成所有更新。</li>
<li><strong>优势：</strong> 减少了不必要的重新渲染，提升了应用性能，简化了开发者对 <code>setState</code> 行为的理解。在 React 18 之前，只有在 React 事件处理函数中 <code>setState</code> 才是批处理的。</li>
</ul>
</li>
<li>
<p><strong><code>startTransition</code> (可中断更新)：</strong></p>
<ul>
<li><strong>作用：</strong> 允许你将某些不紧急的状态更新标记为“<strong>过渡 (transitions)</strong>”。这些过渡更新是可中断的，React 会优先处理紧急更新（如用户输入），而过渡更新可以在后台进行，甚至被更紧急的更新中断。</li>
<li><strong>用法：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">startTransition</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleChange</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">e</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setInputValue</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">value</span>); <span style="color:#75715e">// 紧急更新，立即显示输入内容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">startTransition</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这个更新被标记为非紧急，可以被中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">setSearchResults</span>(<span style="color:#a6e22e">filterData</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">value</span>));
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div></li>
<li><strong>优势：</strong> 即使有大量数据计算或渲染，也能确保 UI 的响应性，避免卡顿。</li>
</ul>
</li>
<li>
<p><strong>Suspense for Data Fetching (用于数据获取的 Suspense)：</strong></p>
<ul>
<li>虽然在 React 16.6 中已经引入了 <code>Suspense</code> 用于代码分割 (<code>React.lazy</code>)，但 React 18 扩展了其能力，使其能够用于<strong>数据获取</strong>。</li>
<li><strong>作用：</strong> 当组件的数据尚未准备好时，它可以“挂起” (suspend)，并让最近的 <code>Suspense</code> 边界显示 <code>fallback</code> UI。当数据加载完成后，再渲染组件内容。</li>
<li><strong>优势：</strong> 简化了数据获取的加载状态管理，避免了“瀑布式请求”，改善了用户体验。需要搭配支持 Suspense 的数据获取库（如 <code>react-query</code> 的实验性模式或未来的 React Server Components）。</li>
</ul>
</li>
<li>
<p><strong>新的 Root API (<code>createRoot</code>)：</strong></p>
<ul>
<li><strong>作用：</strong> React 18 引入了新的根 API <code>ReactDOM.createRoot()</code> 来替代旧的 <code>ReactDOM.render()</code>。</li>
<li><strong>用法：</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 旧版
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// import ReactDOM from &#39;react-dom&#39;;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 新版
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">ReactDOM</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react-dom/client&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ReactDOM</span>.<span style="color:#a6e22e">createRoot</span>(document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#39;root&#39;</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">render</span>(<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">App</span> <span style="color:#f92672">/&gt;</span>);
</span></span></code></pre></div></li>
<li><strong>优势：</strong> 新的 Root API 是启用所有并发特性（包括自动批处理和 <code>startTransition</code>）的前提。</li>
</ul>
</li>
<li>
<p><strong><code>useDeferredValue</code> Hook：</strong></p>
<ul>
<li><strong>作用：</strong> 允许你“延迟”更新某个值。当值发生变化时，它会返回该值的最新版本，但会给 React 一个提示，这个更新可以被延迟，不会立即阻塞主线程。</li>
<li><strong>优势：</strong> 类似于 <code>startTransition</code>，但粒度更细，通常用于优化实时搜索框或输入框的响应性，当用户快速输入时，只显示部分更新结果，而在空闲时再显示完整结果。</li>
</ul>
</li>
<li>
<p><strong>Server Components (处于实验阶段，不是 React 18 核心发布内容但相关)：</strong></p>
<ul>
<li><strong>作用：</strong> 允许开发者在服务器端渲染和获取数据，并将组件直接发送到客户端，减少客户端 JavaScript 的数量。</li>
<li><strong>优势：</strong> 提升初始加载性能，降低客户端资源消耗。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong> React 18 的核心在于引入了<strong>并发渲染</strong>的概念，使得 React 应用在处理复杂和大数据量更新时能够保持更高的响应性。它通过自动批处理、可中断更新（<code>startTransition</code>）和更强大的 Suspense 机制来提升用户体验和开发效率。</p>
</div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>



<div class="busuanzi-footer">
  <p>© 2025 Powered By <a href="https://themes.gohugo.io/">Hugo</a> & 
    <a href="https://github.com/alex-shpak/hugo-book">Hugo-book</a> Contact: <a href="mailto:j.duan@foxmail.com">j.duan@foxmail.com</a></p> 
  <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span id="busuanzi_container_site_uv">
    本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>
</div>
 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<style>
    .no-marker::marker {
        content: none;
    }
</style>
<li class="no-marker"><a href="#React%20%e7%9f%a5%e8%af%86">React 知识</a></li>
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#-react-核心基础">💡 React 核心基础</a>
          <ul>
            <li><a href="#react-的核心原理是什么">React 的核心原理是什么？</a></li>
            <li><a href="#什么是虚拟-dom它怎么提升性能">什么是虚拟 DOM？它怎么提升性能？</a></li>
            <li><a href="#react-组件有哪些函数组件-vs-类组件区别">React 组件有哪些？函数组件 vs 类组件区别？</a></li>
            <li><a href="#什么是-jsx它如何被处理">什么是 JSX？它如何被处理？</a></li>
            <li><a href="#react-中的状态和-props-有什么区别">React 中的状态和 props 有什么区别？</a></li>
            <li><a href="#key-的作用是什么为什么不能用-index">key 的作用是什么？为什么不能用 index？</a></li>
            <li><a href="#什么是受控组件和非受控组件">什么是受控组件和非受控组件？</a></li>
          </ul>
        </li>
        <li><a href="#-hooks">⚙️ Hooks</a>
          <ul>
            <li><a href="#usestate-和-useeffect-的用法与注意事项">useState 和 useEffect 的用法与注意事项？</a></li>
            <li><a href="#如何模拟-componentdidmount--didupdate--willunmount">如何模拟 componentDidMount / DidUpdate / WillUnmount？</a></li>
            <li><a href="#useeffect-依赖数组为什么不能随便省略">useEffect 依赖数组为什么不能随便省略？</a></li>
            <li><a href="#如何用-useref-实现防抖或保存旧状态">如何用 useRef 实现防抖或保存旧状态？</a></li>
            <li><a href="#usecallback-vs-usememo-区别">useCallback vs useMemo 区别？</a></li>
            <li><a href="#自定义-hook-怎么写实际项目中写过哪些">自定义 Hook 怎么写？实际项目中写过哪些？</a></li>
          </ul>
        </li>
        <li><a href="#-性能优化与架构">🚀 性能优化与架构</a>
          <ul>
            <li><a href="#react-中有哪些性能优化方法">React 中有哪些性能优化方法？</a></li>
            <li><a href="#什么是虚拟化virtualization用过哪些库">什么是虚拟化（virtualization）？用过哪些库？</a></li>
            <li><a href="#如何避免子组件重复渲染">如何避免子组件重复渲染？</a></li>
            <li><a href="#什么是代码分割code-splitting">什么是代码分割（Code Splitting）？</a></li>
            <li><a href="#组件懒加载如何实现reactlazy-vs-动态导入">组件懒加载如何实现？React.lazy vs 动态导入</a></li>
          </ul>
        </li>
        <li><a href="#-状态管理">🔄 状态管理</a>
          <ul>
            <li><a href="#你项目中如何管理组件间状态">你项目中如何管理组件间状态？</a></li>
            <li><a href="#redux-工作原理">Redux 工作原理？</a></li>
            <li><a href="#usecontext-有哪些适用场景能替代-redux-吗">useContext 有哪些适用场景？能替代 Redux 吗？</a></li>
            <li><a href="#redux-中-thunk--saga-的作用">Redux 中 thunk / saga 的作用？</a></li>
            <li><a href="#zustandrecoiljotai-用过吗优缺点">Zustand、Recoil、Jotai 用过吗？优缺点？</a></li>
          </ul>
        </li>
        <li><a href="#-异步与网络请求">🌐 异步与网络请求</a>
          <ul>
            <li><a href="#react-中如何发送异步请求">React 中如何发送异步请求？</a></li>
            <li><a href="#怎么处理加载中错误和取消请求">怎么处理加载中、错误和取消请求？</a></li>
            <li><a href="#项目中如何做接口缓存--分页加载">项目中如何做接口缓存 / 分页加载？</a></li>
            <li><a href="#用过-react-query-吗核心特性">用过 react-query 吗？核心特性？</a></li>
          </ul>
        </li>
        <li><a href="#-组件通信与复用">📦 组件通信与复用</a>
          <ul>
            <li><a href="#父子组件如何通信兄弟组件怎么通信">父子组件如何通信？兄弟组件怎么通信？</a></li>
            <li><a href="#什么是高阶组件hoc">什么是高阶组件（HOC）？</a></li>
            <li><a href="#什么是-render-props-模式">什么是 render props 模式？</a></li>
            <li><a href="#组件复用有哪些方式你实际项目怎么做的">组件复用有哪些方式？你实际项目怎么做的？</a></li>
            <li><a href="#什么是组合优于继承react-如何体现">什么是组合优于继承？React 如何体现？</a></li>
          </ul>
        </li>
        <li><a href="#-路由与表单">📄 路由与表单</a>
          <ul>
            <li><a href="#react-router-的核心原理">React Router 的核心原理？</a></li>
            <li><a href="#路由懒加载怎么做">路由懒加载怎么做？</a></li>
            <li><a href="#表单库你用过哪些formik--react-hook-form">表单库你用过哪些？Formik / React Hook Form？</a></li>
            <li><a href="#表单校验是怎么实现的">表单校验是怎么实现的？</a></li>
          </ul>
        </li>
        <li><a href="#-测试与工具链">🧪 测试与工具链</a>
          <ul>
            <li><a href="#如何对-react-组件进行单元测试">如何对 React 组件进行单元测试？</a></li>
            <li><a href="#jestreact-testing-library-用过吗">jest、react-testing-library 用过吗？</a></li>
            <li><a href="#用什么工具调试-react-应用">用什么工具调试 React 应用？</a></li>
            <li><a href="#webpack--vite-配置你了解吗">Webpack / Vite 配置你了解吗？</a></li>
            <li><a href="#webpack-传统打包工具"><strong>Webpack (传统打包工具)</strong></a></li>
            <li><a href="#vite-新一代构建工具"><strong>Vite (新一代构建工具)</strong></a></li>
          </ul>
        </li>
        <li><a href="#-项目实战经验">🛠️ 项目实战经验</a>
          <ul>
            <li><a href="#描述你做过的一个复杂-react-项目">描述你做过的一个复杂 React 项目？</a></li>
            <li><a href="#项目中遇到过哪些性能问题怎么解决的">项目中遇到过哪些性能问题？怎么解决的？</a></li>
            <li><a href="#你是如何组织组件结构和模块的">你是如何组织组件结构和模块的？</a></li>
            <li><a href="#在-react-项目中做过哪些抽象封装">在 React 项目中做过哪些抽象/封装？</a></li>
            <li><a href="#和后端如何对接有没有封装请求库">和后端如何对接？有没有封装请求库？</a></li>
          </ul>
        </li>
        <li><a href="#-进阶与框架原理">🧠 进阶与框架原理</a>
          <ul>
            <li><a href="#react-中-setstate-是同步还是异步的为什么">React 中 setState 是同步还是异步的？为什么？</a></li>
            <li><a href="#什么是调和reconciliation">什么是调和（Reconciliation）？</a></li>
            <li><a href="#fiber-架构解决了什么问题">Fiber 架构解决了什么问题？</a></li>
            <li><a href="#concurrent-mode-和-suspense-知道多少">Concurrent Mode 和 Suspense 知道多少？</a></li>
            <li><a href="#react-18-引入了哪些新特性">React 18 引入了哪些新特性？</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>













---
title: Saga 模式最佳实践
---

## Saga 服务设计的实践经验
1. 允许空补偿
* 空补偿：原服务未执行，补偿服务执行了
* 出现原因：
    * 原服务 超时（丢包）
    * Saga 事务触发 回滚
    * 未收到 原服务请求，先收到 补偿请求

所以服务设计时需要允许空补偿, 即没有找到要补偿的业务主键时返回补偿成功并将原业务主键记录下来

2. 防悬挂控制
* 悬挂：补偿服务 比 原服务 先执行
* 出现原因：
    * 原服务 超时（拥堵）
    * Saga 事务回滚，触发 回滚
    * 拥堵的 原服务 到达

所以要检查当前业务主键是否已经在空补偿记录下来的业务主键中存在，如果存在则要拒绝服务的执行

3. 幂等控制
* 原服务与补偿服务都需要保证幂等性, 由于网络可能超时, 可以设置重试策略，重试发生时要通过幂等控制避免业务数据重复更新

## 缺乏隔离性的应对
* 由于 Saga 事务不保证隔离性, 在极端情况下可能由于脏写无法完成回滚操作, 比如举一个极端的例子, 分布式事务内先给用户 A 充值, 然后给用户 B 扣减余额, 如果在给 A 用户充值成功, 在事务提交以前, A 用户把余额消费掉了, 如果事务发生回滚, 这时则没有办法进行补偿了。这就是缺乏隔离性造成的典型的问题, 实践中一般的应对方法是：
    * 业务流程设计时遵循“宁可长款, 不可短款”的原则, 长款意思是客户少了钱机构多了钱, 以机构信誉可以给客户退款, 反之则是短款, 少的钱可能追不回来了。所以在业务流程设计上一定是先扣款。
    * 有些业务场景可以允许让业务最终成功, 在回滚不了的情况下可以继续重试完成后面的流程, 所以状态机引擎除了提供“回滚”能力还需要提供“向前”恢复上下文继续执行的能力, 让业务最终执行成功, 达到最终一致性的目的。

## 性能优化
* 配置客户端参数`client.rm.report.success.enable=false`，可以在当分支事务执行成功时不上报分支状态到 server，从而提升性能。
    > 当上一个分支事务的状态还没有上报的时候，下一个分支事务已注册，可以认为上一个实际已成功
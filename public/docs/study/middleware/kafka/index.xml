<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kafka on 君宝的笔记</title>
    <link>http://localhost:1313/docs/study/middleware/kafka/</link>
    <description>Recent content in Kafka on 君宝的笔记</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <atom:link href="http://localhost:1313/docs/study/middleware/kafka/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kafka Exactly-Once</title>
      <link>http://localhost:1313/docs/study/middleware/kafka/exactly-once/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/middleware/kafka/exactly-once/</guid>
      <description>&lt;h1 id=&#34;流程&#34;&gt;&#xD;&#xA;  流程&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;幂等生产者（生产者 Producer ID + 分区维护 Sequence Number）&lt;/li&gt;&#xA;&lt;li&gt;事务协调者带 _transaction_state（用户 Transaction ID + 生产者 epoch + 分区 Control Messages + 消费者 LSO）&lt;/li&gt;&#xA;&lt;li&gt;完整流程：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;事务初始化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生产者寻找事务协调者（Transactional Coordinator）。&lt;/li&gt;&#xA;&lt;li&gt;生产者向事务协调者获取  PID。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;事务开始&lt;/li&gt;&#xA;&lt;li&gt;Consume-Process-Produce：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;消费者（流处理应用同时作为消费者和生产者）从源 Topic 消费消息并做处理。&lt;/li&gt;&#xA;&lt;li&gt;生产者同步消息所要发往的  Topic-Partition 信息给事务协调者。&lt;/li&gt;&#xA;&lt;li&gt;生产者向目标 Topic-Partition 发送消息。&lt;/li&gt;&#xA;&lt;li&gt;生产者同步提交位点所要发往的  Topic-Partition （内部 Topic __consumer_offsets）信息给事务协调者。&lt;/li&gt;&#xA;&lt;li&gt;生产者通知 消费组协调者（Group Coordinator，服务端负责感知消费组变化的 Broker）提交位点（仅持久化位点，但并 未更新缓存，因此直到事务提交前对消费者不可见）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;提交/回滚事务&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生产者告知事务协调者事务 执行结果（提交/回滚）。&lt;/li&gt;&#xA;&lt;li&gt;事务协调者向事务所涉及的分区 Leader 发送 控制消息标记事务执行结果，同时事务协调者给生产者响应事务已提交/回滚成功。&lt;/li&gt;&#xA;&lt;li&gt;待所有分区 Leader 将控制消息持久化（任何一个失败都会进行无限重试）后，事务协调者将该事务状态修改为已提交/回滚，事务结束。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;下面基于上述 Exactly-Once 语义实现的内容，对“重要场景”与“关键设计”分别进行归纳与解释。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;归纳与解释&#34;&gt;&#xD;&#xA;  归纳与解释&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bd%92%e7%ba%b3%e4%b8%8e%e8%a7%a3%e9%87%8a&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;1-重要场景及-kafka-在其中的角色&#34;&gt;&#xD;&#xA;  1. 重要场景及 Kafka 在其中的角色&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e9%87%8d%e8%a6%81%e5%9c%ba%e6%99%af%e5%8f%8a-kafka-%e5%9c%a8%e5%85%b6%e4%b8%ad%e7%9a%84%e8%a7%92%e8%89%b2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;At-Most-Once / At-Least-Once vs Exactly-Once 流处理场景对比&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>微服务通信</title>
      <link>http://localhost:1313/docs/study/middleware/kafka/microservices-comm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/middleware/kafka/microservices-comm/</guid>
      <description>&lt;p&gt;Kafka 本身在“Kafka 主题内部”的生产者到消费者环节，可以通过幂等生产者 + 事务机制实现“恰好一次”（Exactly-Once）的消息写入和消费-offset 提交。但在微服务通信的更广泛场景中，往往涉及将消息消费后的结果写入外部系统（如数据库）或调用其他服务，这时要达到端到端的“恰好一次”则更复杂，需要配合额外设计与模式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;kafka-内部的-exactly-once-保证&#34;&gt;&#xD;&#xA;  &lt;strong&gt;Kafka 内部的 Exactly-Once 保证&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka-%e5%86%85%e9%83%a8%e7%9a%84-exactly-once-%e4%bf%9d%e8%af%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用幂等生产者（Producer ID + 分区内序列号 + 服务端判重）可保证单会话、单分区写入不重复。&lt;/li&gt;&#xA;&lt;li&gt;引入事务（Transactional ID + Transaction Coordinator + WriteTxnMarker + read_committed 消费模式 + sendOffsetsToTransaction），可将“消费消息→处理→生产新消息”与“提交消费 offset”放在同一事务内，确保要么都生效要么都不生效，从而在同一个 Kafka 流程链上实现恰好一次处理。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;微服务通信的挑战&#34;&gt;&#xD;&#xA;  &lt;strong&gt;微服务通信的挑战&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%be%ae%e6%9c%8d%e5%8a%a1%e9%80%9a%e4%bf%a1%e7%9a%84%e6%8c%91%e6%88%98&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;外部系统事务不可跨 Kafka 事务自动协调&lt;/strong&gt;：Kafka 事务只能保证 Kafka 内部的写入与 offset 提交原子性，无法直接与外部数据库或其它消息队列的事务做分布式两阶段提交。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;服务间调用或数据库写入的幂等性&lt;/strong&gt;：若服务处理消息后要写数据库或调用下游服务，需要保证该步骤幂等或者可回滚，否则即使 Kafka 端不重复，外部操作仍可能因重试导致重复或漏处理。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;网络或进程故障时的一致性边界&lt;/strong&gt;：处理过程中若播出消息已提交但外部写入失败，或相反，都可能导致不一致。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;常见解决模式&#34;&gt;&#xD;&#xA;  &lt;strong&gt;常见解决模式&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e8%a7%81%e8%a7%a3%e5%86%b3%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;1-outbox-模式&#34;&gt;&#xD;&#xA;  1. &lt;strong&gt;Outbox 模式&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-outbox-%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt; * 在业务数据库的同一个事务内，同时写入主业务表和“outbox 表”记录待发送的消息。事务提交后，由专门的进程或 Debezium 等 CDC 工具读取 outbox 表并向 Kafka 发送消息。这样可保证“业务写入与消息投递”在同一数据库事务隔离中，无漏发；发送到 Kafka 时再通过幂等或事务控制避免重复投递。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;2-idempotent-消费与处理&#34;&gt;&#xD;&#xA;  2. &lt;strong&gt;Idempotent 消费与处理&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-idempotent-%e6%b6%88%e8%b4%b9%e4%b8%8e%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt; * 下游服务在消费 Kafka 消息写入数据库时，设计幂等写入（如基于业务主键做 UPSERT，或记录已处理消息 ID 以去重）。即便重试消费，也不会导致多次副作用。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;3-事务协调与补偿saga&#34;&gt;&#xD;&#xA;  3. &lt;strong&gt;事务协调与补偿（Saga）&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e4%ba%8b%e5%8a%a1%e5%8d%8f%e8%b0%83%e4%b8%8e%e8%a1%a5%e5%81%bfsaga&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt; * 对于跨多个服务或系统的业务，将大事务拆分为多个本地事务，并设计补偿逻辑：失败时回滚已生效的步骤。配合可靠消息（Kafka 生产）与幂等处理，可在一定程度上保证最終一致性。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;4-双写校验&#34;&gt;&#xD;&#xA;  4. &lt;strong&gt;双写+校验&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%e5%8f%8c%e5%86%99%e6%a0%a1%e9%aa%8c&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt; * 消费消息后同时往 Kafka 和数据库写入，但需外部校验或异步补偿来处理可能的写入不一致，通常结合重试策略与幂等设计。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;5-exactly-once-semantics-eos-for-kafka-streams&#34;&gt;&#xD;&#xA;  5. &lt;strong&gt;Exactly-Once Semantics (EOS) for Kafka Streams&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#5-exactly-once-semantics-eos-for-kafka-streams&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt; * 如果微服务本身使用 Kafka Streams，并且流处理结果也写回 Kafka，再由另一个服务消费并写数据库，可在 Kafka Streams 侧利用事务保证流内部恰好一次。但写到外部 DB 时，仍需借助 Outbox 或幂等写入等方式。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;实践建议&#34;&gt;&#xD;&#xA;  &lt;strong&gt;实践建议&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e8%b7%b5%e5%bb%ba%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;尽量把核心业务状态写入同一数据库事务时触发 outbox 消息，再由 Kafka 负责后续分发。&lt;/li&gt;&#xA;&lt;li&gt;消费端写数据库时使用幂等或存在检查；避免依赖单纯 Kafka 事务就认为外部写入也“恰好一次”。&lt;/li&gt;&#xA;&lt;li&gt;在可能的场景下，将更多逻辑留在 Kafka Streams 或 ksqlDB 等框架内，减少外部系统交互，利用其内建事务能力。&lt;/li&gt;&#xA;&lt;li&gt;明确 SLA：很多系统接受“至少一次”加幂等处理即可；若必须严格恰好一次，需要结合上述模式并接受复杂度和性能成本。&lt;/li&gt;&#xA;&lt;li&gt;对延迟、吞吐与可用性的权衡：出于高可用，往往避免分布式两阶段提交，转而用补偿或幂等设计。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;结论&#34;&gt;&#xD;&#xA;  &lt;strong&gt;结论&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e8%ae%ba&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Kafka 可在自身范围内（“读 Kafka → 处理 → 写 Kafka → 提交 offset”）做到 Exactly-Once，但在微服务通信中若涉及外部数据库或其它服务，需要借助 Outbox、幂等写入、补偿事务（Saga）等模式来接近端到端恰好一次。无需强求跨多系统的分布式两阶段提交（复杂且易成瓶颈），而是通过可靠消息、幂等设计与补偿逻辑，实现在常见微服务场景下的业务正确性和最终一致性。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

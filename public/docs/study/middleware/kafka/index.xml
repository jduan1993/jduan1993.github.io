<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kafka on 君宝的笔记</title>
    <link>http://localhost:1313/docs/study/middleware/kafka/</link>
    <description>Recent content in Kafka on 君宝的笔记</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <atom:link href="http://localhost:1313/docs/study/middleware/kafka/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kafka Exactly-Once</title>
      <link>http://localhost:1313/docs/study/middleware/kafka/exactly-once/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/middleware/kafka/exactly-once/</guid>
      <description>&lt;p&gt;下面基于上述 Exactly-Once 语义实现的内容，对“重要场景”与“关键设计”分别进行归纳与解释。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-重要场景及-kafka-在其中的角色&#34;&gt;&#xD;&#xA;  1. 重要场景及 Kafka 在其中的角色&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e9%87%8d%e8%a6%81%e5%9c%ba%e6%99%af%e5%8f%8a-kafka-%e5%9c%a8%e5%85%b6%e4%b8%ad%e7%9a%84%e8%a7%92%e8%89%b2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;At-Most-Once / At-Least-Once vs Exactly-Once 流处理场景对比&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;场景说明&lt;/strong&gt;：流处理通常涉及“消费-处理-生产”（Consume-Process-Produce）流程；若仅用 At-Least-Once 语义，会因网络抖动或进程崩溃导致消息重复处理；若 At-Most-Once，则可能丢失消息。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Kafka 角色&lt;/strong&gt;：提供端到端 Exactly-Once 能力（在消费来源于 Kafka，且输出写回 Kafka 的场景）。通过幂等生产者与事务机制，避免重复消息与丢失，确保每条输入消息“恰好一次”被处理并产出消息，同时提交位点也被原子化地与输出挂钩。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;网络 ACK 丢失导致重试的重复写入场景&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;场景说明&lt;/strong&gt;：生产者发送消息，Broker 实际已写入但 ACK 丢失，客户端误以为失败重试，导致重复写入。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Kafka 角色&lt;/strong&gt;：在幂等生产者中，通过 Producer ID + 分区内序列号、服务端维护最近 N 条批次信息，判重与乱序检测；再结合事务可保证跨会话的幂等，避免因 ACK 丢失产生重复。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;消费端已发送输出但尚未提交位点前崩溃导致重读并重复写入场景&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;场景说明&lt;/strong&gt;：在流处理应用中，消息处理完并向目标 Topic 发送成功后，若在提交 consumer offset 之前崩溃，重启后会再次消费并重复发送。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Kafka 角色&lt;/strong&gt;：通过事务：把“发送消息到目标 Topic”与“提交源 Topic 的位点（__consumer_offsets）”都纳入同一事务。若事务最终提交，则两者一起生效；若中途失败或崩溃未提交，则事务回滚，输出消息不可见且位点也不会生效，从而避免重复计算。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;多分区或多次读写操作的原子性需求场景&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;场景说明&lt;/strong&gt;：流处理可能对多个分区写入，或同时需要向多个 Topic-Partition 发送结果，并提交多个操作（如写结果、更新状态 topic、提交位点等）。需要保证这些操作要么都生效，要么都不生效。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Kafka 角色&lt;/strong&gt;：引入事务协调者（Transaction Coordinator），在事务上下文中跟踪涉及的所有分区信息；最终通过控制消息（WriteTxnMarker）通知各分区 Leader 提交或回滚，确保原子性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;跨会话恢复场景&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;场景说明&lt;/strong&gt;：流处理应用或生产者进程重启后，若使用相同的事务 ID，应能识别前一会话未完成的事务并进行恰当回滚或继续。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Kafka 角色&lt;/strong&gt;：Transactional ID（用户提供）+ 服务端分配的 PID + epoch 机制。重启后客户端用相同 Transactional ID 找到协调者，协调者检测到旧事务未完成，会回滚旧事务，给新的会话分配新的 epoch，从而保证幂等与正确恢复。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Broker/协调者故障或网络分区场景&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>微服务通信</title>
      <link>http://localhost:1313/docs/study/middleware/kafka/microservices-comm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/middleware/kafka/microservices-comm/</guid>
      <description>&lt;p&gt;Kafka 本身在“Kafka 主题内部”的生产者到消费者环节，可以通过幂等生产者 + 事务机制实现“恰好一次”（Exactly-Once）的消息写入和消费-offset 提交。但在微服务通信的更广泛场景中，往往涉及将消息消费后的结果写入外部系统（如数据库）或调用其他服务，这时要达到端到端的“恰好一次”则更复杂，需要配合额外设计与模式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;kafka-内部的-exactly-once-保证&#34;&gt;&#xD;&#xA;  &lt;strong&gt;Kafka 内部的 Exactly-Once 保证&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka-%e5%86%85%e9%83%a8%e7%9a%84-exactly-once-%e4%bf%9d%e8%af%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用幂等生产者（Producer ID + 分区内序列号 + 服务端判重）可保证单会话、单分区写入不重复。&lt;/li&gt;&#xA;&lt;li&gt;引入事务（Transactional ID + Transaction Coordinator + WriteTxnMarker + read_committed 消费模式 + sendOffsetsToTransaction），可将“消费消息→处理→生产新消息”与“提交消费 offset”放在同一事务内，确保要么都生效要么都不生效，从而在同一个 Kafka 流程链上实现恰好一次处理。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;微服务通信的挑战&#34;&gt;&#xD;&#xA;  &lt;strong&gt;微服务通信的挑战&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%be%ae%e6%9c%8d%e5%8a%a1%e9%80%9a%e4%bf%a1%e7%9a%84%e6%8c%91%e6%88%98&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;外部系统事务不可跨 Kafka 事务自动协调&lt;/strong&gt;：Kafka 事务只能保证 Kafka 内部的写入与 offset 提交原子性，无法直接与外部数据库或其它消息队列的事务做分布式两阶段提交。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;服务间调用或数据库写入的幂等性&lt;/strong&gt;：若服务处理消息后要写数据库或调用下游服务，需要保证该步骤幂等或者可回滚，否则即使 Kafka 端不重复，外部操作仍可能因重试导致重复或漏处理。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;网络或进程故障时的一致性边界&lt;/strong&gt;：处理过程中若播出消息已提交但外部写入失败，或相反，都可能导致不一致。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;常见解决模式&#34;&gt;&#xD;&#xA;  &lt;strong&gt;常见解决模式&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e8%a7%81%e8%a7%a3%e5%86%b3%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;1-outbox-模式&#34;&gt;&#xD;&#xA;  1. &lt;strong&gt;Outbox 模式&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-outbox-%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt; * 在业务数据库的同一个事务内，同时写入主业务表和“outbox 表”记录待发送的消息。事务提交后，由专门的进程或 Debezium 等 CDC 工具读取 outbox 表并向 Kafka 发送消息。这样可保证“业务写入与消息投递”在同一数据库事务隔离中，无漏发；发送到 Kafka 时再通过幂等或事务控制避免重复投递。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;2-idempotent-消费与处理&#34;&gt;&#xD;&#xA;  2. &lt;strong&gt;Idempotent 消费与处理&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-idempotent-%e6%b6%88%e8%b4%b9%e4%b8%8e%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt; * 下游服务在消费 Kafka 消息写入数据库时，设计幂等写入（如基于业务主键做 UPSERT，或记录已处理消息 ID 以去重）。即便重试消费，也不会导致多次副作用。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;3-事务协调与补偿saga&#34;&gt;&#xD;&#xA;  3. &lt;strong&gt;事务协调与补偿（Saga）&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e4%ba%8b%e5%8a%a1%e5%8d%8f%e8%b0%83%e4%b8%8e%e8%a1%a5%e5%81%bfsaga&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt; * 对于跨多个服务或系统的业务，将大事务拆分为多个本地事务，并设计补偿逻辑：失败时回滚已生效的步骤。配合可靠消息（Kafka 生产）与幂等处理，可在一定程度上保证最終一致性。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;4-双写校验&#34;&gt;&#xD;&#xA;  4. &lt;strong&gt;双写+校验&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%e5%8f%8c%e5%86%99%e6%a0%a1%e9%aa%8c&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt; * 消费消息后同时往 Kafka 和数据库写入，但需外部校验或异步补偿来处理可能的写入不一致，通常结合重试策略与幂等设计。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;5-exactly-once-semantics-eos-for-kafka-streams&#34;&gt;&#xD;&#xA;  5. &lt;strong&gt;Exactly-Once Semantics (EOS) for Kafka Streams&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#5-exactly-once-semantics-eos-for-kafka-streams&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt; * 如果微服务本身使用 Kafka Streams，并且流处理结果也写回 Kafka，再由另一个服务消费并写数据库，可在 Kafka Streams 侧利用事务保证流内部恰好一次。但写到外部 DB 时，仍需借助 Outbox 或幂等写入等方式。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;实践建议&#34;&gt;&#xD;&#xA;  &lt;strong&gt;实践建议&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e8%b7%b5%e5%bb%ba%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;尽量把核心业务状态写入同一数据库事务时触发 outbox 消息，再由 Kafka 负责后续分发。&lt;/li&gt;&#xA;&lt;li&gt;消费端写数据库时使用幂等或存在检查；避免依赖单纯 Kafka 事务就认为外部写入也“恰好一次”。&lt;/li&gt;&#xA;&lt;li&gt;在可能的场景下，将更多逻辑留在 Kafka Streams 或 ksqlDB 等框架内，减少外部系统交互，利用其内建事务能力。&lt;/li&gt;&#xA;&lt;li&gt;明确 SLA：很多系统接受“至少一次”加幂等处理即可；若必须严格恰好一次，需要结合上述模式并接受复杂度和性能成本。&lt;/li&gt;&#xA;&lt;li&gt;对延迟、吞吐与可用性的权衡：出于高可用，往往避免分布式两阶段提交，转而用补偿或幂等设计。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;结论&#34;&gt;&#xD;&#xA;  &lt;strong&gt;结论&lt;/strong&gt;&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e8%ae%ba&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Kafka 可在自身范围内（“读 Kafka → 处理 → 写 Kafka → 提交 offset”）做到 Exactly-Once，但在微服务通信中若涉及外部数据库或其它服务，需要借助 Outbox、幂等写入、补偿事务（Saga）等模式来接近端到端恰好一次。无需强求跨多系统的分布式两阶段提交（复杂且易成瓶颈），而是通过可靠消息、幂等设计与补偿逻辑，实现在常见微服务场景下的业务正确性和最终一致性。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

---
title: 方案
---


## ✅ 一、常见缓存方案对比

| 缓存策略                                    | 特点                      | 适合场景                 | 优缺点                                      |
| --------------------------------------- | ----------------------- | -------------------- | ---------------------------------------- |
| **Redis 集群**                            | 分布式内存数据库，支持多数据结构、持久化、分片 | 高频访问、分布式系统、跨服务缓存     | ✅ 功能强，支持过期策略、发布订阅、Lua 脚本<br>❌ 成本较高、复杂度较大 |
| **Memcached**                           | 高性能 key-value 内存缓存，无持久化 | 简单 kv 缓存、大量读、无数据结构需求 | ✅ 速度快，轻量级<br>❌ 不支持复杂数据结构、数据易丢失           |
| **本地缓存（如 Guava Cache）**                 | 服务进程内存缓存                | 热点数据、本地配置、小规模缓存      | ✅ 极快访问、无网络延迟<br>❌ 不共享、易过期不一致             |
| **CDN 缓存（如 Cloudflare、AWS CloudFront）** | 基于 HTTP 静态文件缓存          | 图片、视频、前端静态资源         | ✅ 全球加速，用户端就近获取<br>❌ 不适用于动态数据             |

---

## ✅ 二、如何选择最终方案？

选择缓存方案的依据，通常围绕 **一致性需求 + 热点程度 + 成本 + 技术复杂度** 这几方面展开。

### 示例：某 SaaS 平台接口缓存选择路径

| 选项          | 原因                                |
| ----------- | --------------------------------- |
| ❌ 本地缓存      | 数据在多服务实例间不共享，不适用于高一致性             |
| ❌ Memcached | 不支持持久化、集群化不方便，数据结构能力弱             |
| ✅ Redis 集群  | 支持 key 过期、LRU 淘汰策略、支持分布式部署，可支撑高并发 |
| ✅ CDN（搭配使用） | 用于前端静态资源、公共 API GET 缓存，减轻后端压力     |

最终方案：

> **Redis Cluster + CDN + 本地热点缓存（组合策略）**

---

## ✅ 三、如果业务增长 10 倍，缓存层如何扩展？

> 假设你当前 QPS 为 1,000，目标是支撑 QPS 10,000 甚至更高。

### 🔹 1. **Redis 缓存层扩展策略**

| 措施                     | 说明                             |
| ---------------------- | ------------------------------ |
| **水平扩展 Redis Cluster** | 增加分片节点，Redis 自动做 key 的 slot 分配 |
| **主从复制 + 哨兵**          | 提高读能力，故障自动切换（Sentinel）         |
| **冷热分离缓存策略**           | 高频数据放 Redis，低频数据考虑读取 DB 或预热缓存  |
| **调整 TTL + 设置淘汰策略**    | 避免缓存撑爆内存，采用 LRU 或 LFU          |
| **引入二级缓存**             | 如本地缓存 + Redis，减少热点 key 的访问压力   |
| **加压测试 + 预热机制**        | 服务启动时加载热点数据，避免缓存穿透             |

---

### 🔹 2. **CDN 层扩展策略**

| 策略                      | 说明                                       |
| ----------------------- | ---------------------------------------- |
| **Cache-Control 优化**    | 控制缓存时长、更新策略，减少请求回源频率                     |
| **内容版本化**               | 静态资源增加 hash 避免 CDN 缓存不一致                 |
| **边缘函数（Edge Function）** | 如 Cloudflare Workers，在边缘节点处理请求逻辑，进一步降低延迟 |

---

### 🔹 3. **缓存失效与穿透防护**

| 问题   | 解决策略                         |
| ---- | ---------------------------- |
| 缓存击穿 | 热点 key 设置较长 TTL + 加锁更新       |
| 缓存雪崩 | 设置 TTL 时加入随机波动，避免大规模同时失效     |
| 缓存穿透 | 查询前判断参数合法性 + 对空结果也缓存（短期 TTL） |

---

## ✅ 四、总结选型与扩展思路

### 选择方案理由（以 Redis 为例）：

* 分布式能力强，支持集群横向扩展；
* 数据结构丰富，支持排行榜、布隆过滤器、队列等；
* 支持 key 过期、持久化、备份、监控；
* 开发生态广，语言 SDK 成熟。

### 扩展策略：

1. 预估峰值流量 → 合理分片；
2. 读多写少：主从 + 读写分离；
3. 热点处理：分布式锁 + 本地缓存；
4. 接入监控报警系统（Redis 监控、命中率、内存使用等）；
5. 增加异地多活与容灾策略（高级场景）。
<!DOCTYPE html>
<html lang="zh" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  1. Python基础知识答案
  #



  数据类型
  #



Python中有哪些内置数据类型？它们之间有什么区别？
Python的内置数据类型主要包括：

数字（Numbers）: int (整数), float (浮点数), complex (复数)。
布尔值（Boolean）: bool (True/False)。
字符串（String）: str (不可变的字符序列)。
列表（List）: list (可变的有序序列，元素可以是不同类型)。
元组（Tuple）: tuple (不可变的有序序列，元素可以是不同类型)。
字典（Dictionary）: dict (可变的无序键值对集合，键必须是不可变的，值可以是任意类型)。
集合（Set）: set (可变的无序不重复元素集合)。
不可变集合（Frozen Set）: frozenset (不可变的无序不重复元素集合)。

主要区别在于：

可变性（Mutability）: 列表、字典、集合是可变的，创建后可以修改；数字、字符串、元组、frozenset是不可变的，创建后不能修改。
有序性（Order）: 列表、元组、字符串是有序的，可以通过索引访问；字典（Python 3.7&#43; 保证插入顺序，3.6及以前版本是无序的）、集合是无序的。
重复性（Duplication）: 列表、元组、字符串可以包含重复元素；集合和frozenset不允许重复元素。
键值对: 只有字典是键值对形式的。



什么是可变（mutable）和不可变（immutable）对象？请举例说明。

不可变对象（Immutable Objects）: 一旦创建，其内存中的值就不能被改变。对不可变对象进行修改操作，实际上是创建了一个新的对象。

例子: 数字、字符串、元组、frozenset。


# 字符串是不可变的
s = &#34;hello&#34;
print(id(s)) # 查看内存地址
s = s &#43; &#34; world&#34; # 看起来修改了s，但实际上创建了一个新的字符串对象
print(id(s)) # 内存地址已改变

# 元组是不可变的
t = (1, 2, 3)
# t[0] = 10 # 这会报错：TypeError: &#39;tuple&#39; object does not support item assignment

可变对象（Mutable Objects）: 创建后，可以对其内容进行修改，而无需改变其内存地址。

例子: 列表、字典、集合。


# 列表是可变的
l = [1, 2, 3]
print(id(l)) # 查看内存地址
l.append(4) # 直接在原对象上修改
print(id(l)) # 内存地址不变




深拷贝和浅拷贝有什么区别？何时使用它们？">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/study/python/python/">
  <meta property="og:site_name" content="君宝的笔记">
  <meta property="og:title" content="Python 基础">
  <meta property="og:description" content="1. Python基础知识答案#数据类型#Python中有哪些内置数据类型？它们之间有什么区别？ Python的内置数据类型主要包括：
数字（Numbers）: int (整数), float (浮点数), complex (复数)。 布尔值（Boolean）: bool (True/False)。 字符串（String）: str (不可变的字符序列)。 列表（List）: list (可变的有序序列，元素可以是不同类型)。 元组（Tuple）: tuple (不可变的有序序列，元素可以是不同类型)。 字典（Dictionary）: dict (可变的无序键值对集合，键必须是不可变的，值可以是任意类型)。 集合（Set）: set (可变的无序不重复元素集合)。 不可变集合（Frozen Set）: frozenset (不可变的无序不重复元素集合)。 主要区别在于：
可变性（Mutability）: 列表、字典、集合是可变的，创建后可以修改；数字、字符串、元组、frozenset是不可变的，创建后不能修改。 有序性（Order）: 列表、元组、字符串是有序的，可以通过索引访问；字典（Python 3.7&#43; 保证插入顺序，3.6及以前版本是无序的）、集合是无序的。 重复性（Duplication）: 列表、元组、字符串可以包含重复元素；集合和frozenset不允许重复元素。 键值对: 只有字典是键值对形式的。 什么是可变（mutable）和不可变（immutable）对象？请举例说明。
不可变对象（Immutable Objects）: 一旦创建，其内存中的值就不能被改变。对不可变对象进行修改操作，实际上是创建了一个新的对象。 例子: 数字、字符串、元组、frozenset。 # 字符串是不可变的 s = &#34;hello&#34; print(id(s)) # 查看内存地址 s = s &#43; &#34; world&#34; # 看起来修改了s，但实际上创建了一个新的字符串对象 print(id(s)) # 内存地址已改变 # 元组是不可变的 t = (1, 2, 3) # t[0] = 10 # 这会报错：TypeError: &#39;tuple&#39; object does not support item assignment 可变对象（Mutable Objects）: 创建后，可以对其内容进行修改，而无需改变其内存地址。 例子: 列表、字典、集合。 # 列表是可变的 l = [1, 2, 3] print(id(l)) # 查看内存地址 l.append(4) # 直接在原对象上修改 print(id(l)) # 内存地址不变 深拷贝和浅拷贝有什么区别？何时使用它们？">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
<title>Python 基础 | 君宝的笔记</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/study/python/python/">
<link rel="stylesheet" href="/book.min.06d84d78247e572aefdb64432e406e1f78a9ead4ef25479efa82ff79bd6c0873.css" integrity="sha256-BthNeCR&#43;Vyrv22RDLkBuH3ip6tTvJUee&#43;oL/eb1sCHM=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/zh.search.min.171e36c9135ee2dc743e33f6120c37950006bb1001237e1b56e0cb5f412607fc.js" integrity="sha256-Fx42yRNe4tx0PjP2Egw3lQAGuxABI34bVuDLX0EmB/w=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>君宝的笔记</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>



  



  
    
  



<ul class="book-languages">
  <li>
    <input type="checkbox" id="languages" class="toggle" />
    <label for="languages" class="flex justify-between">
      <a role="button" class="flex align-center">
        <img src="/svg/translate.svg" class="book-icon" alt="Languages" />
        简体中文
      </a>
    </label>

    <ul>
      
      <li>
        <a href="/en/">
          English
        </a>
      </li>
      
    </ul>
  </li>
</ul>














  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-51faac69e5e901597a0480b538fe5e9e" class="toggle" checked />
    <label for="section-51faac69e5e901597a0480b538fe5e9e" class="flex justify-between">
      <a role="button" class="">学习资料</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f24aaea3accf88abc877401f4ea14426" class="toggle" checked />
    <label for="section-f24aaea3accf88abc877401f4ea14426" class="flex justify-between">
      <a role="button" class="">Python</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/python/python/" class="active">Python 基础</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-582da456f48414d663a4153b7d734ed6" class="toggle"  />
    <label for="section-582da456f48414d663a4153b7d734ed6" class="flex justify-between">
      <a role="button" class="">安全</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/security/replay-attack/" class="">重放攻击</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-407d2f8dd9410e8eef358914dd8c0dc2" class="toggle"  />
    <label for="section-407d2f8dd9410e8eef358914dd8c0dc2" class="flex justify-between">
      <a role="button" class="">缓存</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/cache/solution/" class="">方案</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e8dd3e3cc6bf1cd4a7414fff39582ee8" class="toggle"  />
    <label for="section-e8dd3e3cc6bf1cd4a7414fff39582ee8" class="flex justify-between">
      <a role="button" class="">基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/base/saga-best-practices/" class="">Saga 模式最佳实践</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/base/license-comparison/" class="">主流许可证对比</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-57eec37e4d3dd0c268dbeb31bc61d4b1" class="toggle"  />
    <label for="section-57eec37e4d3dd0c268dbeb31bc61d4b1" class="flex justify-between">
      <a role="button" class="">前端</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/frontend/react-knowledge/" class="">React 知识</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70d792a755054f6bbbb3adad5db99041" class="toggle"  />
    <label for="section-70d792a755054f6bbbb3adad5db99041" class="flex justify-between">
      <a role="button" class="">数据库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/database/postgresql-mysql/" class="">PostgreSQL vs MySQL (InnoDB) 选型</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3ba9e8b376ea48d5beb815b520fdce5d" class="toggle"  />
    <label for="section-3ba9e8b376ea48d5beb815b520fdce5d" class="flex justify-between">
      <a role="button" class="">网络</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/network/http-comparison/" class="">HTTP 协议各版本比较</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/network/rtt/" class="">往返时间（Round Trip Time）</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a1d7a3583cdff606ffe4820acf270df1" class="toggle"  />
    <label for="section-a1d7a3583cdff606ffe4820acf270df1" class="flex justify-between">
      <a role="button" class="">系统设计</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/system-design/" class="">系统设计</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/doctolib-tips/" class="">Doctolib 大纲</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/doctolib-system-design/" class="">Doctolib 系统设计</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/rpc/" class="">RPC 框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/high-availability/" class="">高可用性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/system-design/cache-consistency/" class="">缓存一致性</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-92f7d13098d747ba4906005529a0358a" class="toggle"  />
    <label for="section-92f7d13098d747ba4906005529a0358a" class="flex justify-between">
      <a role="button" class="">中间件</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>Kafka</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/middleware/kafka/exactly-once/" class="">Kafka Exactly-Once</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/middleware/kafka/microservices-comm/" class="">微服务通信</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/middleware/netty/" class="">Netty 详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <span>OAuth2</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/middleware/oauth2/auth-code/" class="">授权码模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-6711a471a1458349986928f5c4b580ef" class="toggle"  />
    <label for="section-6711a471a1458349986928f5c4b580ef" class="flex justify-between">
      <a role="button" class="">自省</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/introspection/juc/" class="">Java.util.concurrent 包</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-06148cf0da5a87ffda4f34920eae5a83" class="toggle"  />
    <label for="section-06148cf0da5a87ffda4f34920eae5a83" class="flex justify-between">
      <a href="/docs/example/" class="">Example Site</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/" class="">Table of Contents</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/with-toc/" class="">With ToC</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/without-toc/" class="">Without ToC</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-dcab297e11de79eb42396c59d3314623" class="toggle"  />
    <label for="section-dcab297e11de79eb42396c59d3314623" class="flex justify-between">
      <a role="button" class="">Collapsed</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/collapsed/3rd-level/" class="">3rd Level</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/collapsed/3rd-level/4th-level/" class="">4th Level</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/introduction/" class="">介绍</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-25b4439e87cf8c09de5a8727ce755d08" class="toggle"  />
    <label for="section-25b4439e87cf8c09de5a8727ce755d08" class="flex justify-between">
      <a role="button" class="">Shortcodes</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/buttons/" class="">Buttons</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/columns/" class="">Columns</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/details/" class="">Details</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/hints/" class="">Hints</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/mermaid/" class="">Mermaid</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/tabs/" class="">Tabs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/katex/" class="">KaTeX</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>










  
<ul>
  
  <li>
    <a href="https://github.com/jduan1993"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Python 基础</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <meta name="referrer" content="no-referrer-when-downgrade">

  
  <aside class="hidden clearfix">
    
  
<style>
    .no-marker::marker {
        content: none;
    }
</style>
<li class="no-marker"><a href="#Python%20%e5%9f%ba%e7%a1%80">Python 基础</a></li>
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#1-python基础知识答案">1. Python基础知识答案</a></li>
            <li><a href="#2-高级特性与进阶概念答案">2. 高级特性与进阶概念答案</a></li>
            <li><a href="#3-python库与框架答案">3. Python库与框架答案</a></li>
            <li><a href="#4-算法与数据结构答案">4. 算法与数据结构答案</a></li>
            <li><a href="#5-项目经验与实践答案">5. 项目经验与实践答案</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1 id="Python 基础">
    Python 基础
    <a class="anchor" href="#Python%20%e5%9f%ba%e7%a1%80">#</a>
  </h1>
  
  


  

  


  <div class="book-post-content"><h3 id="1-python基础知识答案">
  1. Python基础知识答案
  <a class="anchor" href="#1-python%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86%e7%ad%94%e6%a1%88">#</a>
</h3>
<hr>
<h4 id="数据类型">
  数据类型
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">#</a>
</h4>
<ul>
<li>
<p><strong>Python中有哪些内置数据类型？它们之间有什么区别？</strong>
Python的内置数据类型主要包括：</p>
<ul>
<li><strong>数字（Numbers）</strong>: <code>int</code> (整数), <code>float</code> (浮点数), <code>complex</code> (复数)。</li>
<li><strong>布尔值（Boolean）</strong>: <code>bool</code> (True/False)。</li>
<li><strong>字符串（String）</strong>: <code>str</code> (不可变的字符序列)。</li>
<li><strong>列表（List）</strong>: <code>list</code> (可变的有序序列，元素可以是不同类型)。</li>
<li><strong>元组（Tuple）</strong>: <code>tuple</code> (不可变的有序序列，元素可以是不同类型)。</li>
<li><strong>字典（Dictionary）</strong>: <code>dict</code> (可变的无序键值对集合，键必须是不可变的，值可以是任意类型)。</li>
<li><strong>集合（Set）</strong>: <code>set</code> (可变的无序不重复元素集合)。</li>
<li><strong>不可变集合（Frozen Set）</strong>: <code>frozenset</code> (不可变的无序不重复元素集合)。</li>
</ul>
<p><strong>主要区别在于：</strong></p>
<ul>
<li><strong>可变性（Mutability）</strong>: 列表、字典、集合是<strong>可变</strong>的，创建后可以修改；数字、字符串、元组、frozenset是<strong>不可变</strong>的，创建后不能修改。</li>
<li><strong>有序性（Order）</strong>: 列表、元组、字符串是有序的，可以通过索引访问；字典（Python 3.7+ 保证插入顺序，3.6及以前版本是无序的）、集合是无序的。</li>
<li><strong>重复性（Duplication）</strong>: 列表、元组、字符串可以包含重复元素；集合和frozenset不允许重复元素。</li>
<li><strong>键值对</strong>: 只有字典是键值对形式的。</li>
</ul>
</li>
<li>
<p><strong>什么是可变（mutable）和不可变（immutable）对象？请举例说明。</strong></p>
<ul>
<li><strong>不可变对象（Immutable Objects）</strong>: 一旦创建，其内存中的值就不能被改变。对不可变对象进行修改操作，实际上是创建了一个新的对象。
<ul>
<li><strong>例子</strong>: <strong>数字</strong>、<strong>字符串</strong>、<strong>元组</strong>、<strong>frozenset</strong>。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 字符串是不可变的</span>
</span></span><span style="display:flex;"><span>s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span>print(id(s)) <span style="color:#75715e"># 查看内存地址</span>
</span></span><span style="display:flex;"><span>s <span style="color:#f92672">=</span> s <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; world&#34;</span> <span style="color:#75715e"># 看起来修改了s，但实际上创建了一个新的字符串对象</span>
</span></span><span style="display:flex;"><span>print(id(s)) <span style="color:#75715e"># 内存地址已改变</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 元组是不可变的</span>
</span></span><span style="display:flex;"><span>t <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># t[0] = 10 # 这会报错：TypeError: &#39;tuple&#39; object does not support item assignment</span>
</span></span></code></pre></div></li>
<li><strong>可变对象（Mutable Objects）</strong>: 创建后，可以对其内容进行修改，而无需改变其内存地址。
<ul>
<li><strong>例子</strong>: <strong>列表</strong>、<strong>字典</strong>、<strong>集合</strong>。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 列表是可变的</span>
</span></span><span style="display:flex;"><span>l <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>print(id(l)) <span style="color:#75715e"># 查看内存地址</span>
</span></span><span style="display:flex;"><span>l<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">4</span>) <span style="color:#75715e"># 直接在原对象上修改</span>
</span></span><span style="display:flex;"><span>print(id(l)) <span style="color:#75715e"># 内存地址不变</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>深拷贝和浅拷贝有什么区别？何时使用它们？</strong></p>
<ul>
<li>
<p><strong>浅拷贝（Shallow Copy）</strong>:</p>
<ul>
<li>创建一个新对象，这个新对象里包含的元素是对原对象中<strong>子对象（引用）的引用</strong>。</li>
<li>如果原对象中的元素是不可变类型（数字、字符串、元组），那么拷贝后的对象和原对象共享这些不可变元素的值。</li>
<li>如果原对象中包含可变类型（列表、字典等）的子对象，那么浅拷贝后的新对象和原对象会<strong>共享这些可变子对象</strong>。修改这些共享的可变子对象会影响到两个对象。</li>
<li><strong>实现方式</strong>: <code>list.copy()</code>, <code>dict.copy()</code>, <code>copy.copy()</code>，或使用切片 <code>[:]</code>。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> copy
</span></span><span style="display:flex;"><span>list1 <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>list2 <span style="color:#f92672">=</span> copy<span style="color:#f92672">.</span>copy(list1) <span style="color:#75715e"># 浅拷贝</span>
</span></span><span style="display:flex;"><span>list1[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span> <span style="color:#75715e"># 修改内部可变列表</span>
</span></span><span style="display:flex;"><span>list1[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">88</span> <span style="color:#75715e"># 修改外部不可变元素</span>
</span></span><span style="display:flex;"><span>print(list1) <span style="color:#75715e"># [[99, 2], 88]</span>
</span></span><span style="display:flex;"><span>print(list2) <span style="color:#75715e"># [[99, 2], 3] - 注意list2的第一个元素也被修改了，第二个没有</span>
</span></span></code></pre></div></li>
<li>
<p><strong>深拷贝（Deep Copy）</strong>:</p>
<ul>
<li>递归地创建一个新对象，并且新对象中包含的所有元素都是<strong>完全独立的新副本</strong>，不再与原对象的任何子对象共享内存。</li>
<li>修改深拷贝后的对象不会影响原对象，反之亦然。</li>
<li><strong>实现方式</strong>: <code>copy.deepcopy()</code>。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> copy
</span></span><span style="display:flex;"><span>list1 <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>list3 <span style="color:#f92672">=</span> copy<span style="color:#f92672">.</span>deepcopy(list1) <span style="color:#75715e"># 深拷贝</span>
</span></span><span style="display:flex;"><span>list1[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span>
</span></span><span style="display:flex;"><span>list1[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">88</span>
</span></span><span style="display:flex;"><span>print(list1) <span style="color:#75715e"># [[99, 2], 88]</span>
</span></span><span style="display:flex;"><span>print(list3) <span style="color:#75715e"># [[1, 2], 3] - list3完全独立</span>
</span></span></code></pre></div></li>
<li>
<p><strong>何时使用？</strong></p>
<ul>
<li>当你的数据结构中<strong>只包含不可变对象</strong>，或者你<strong>不关心内部可变对象是否共享</strong>时，可以使用<strong>浅拷贝</strong>，它通常更快。</li>
<li>当你需要一个<strong>完全独立的新对象，其中所有层级的子对象都与原对象分离</strong>，并且修改新对象不会影响原对象时，必须使用<strong>深拷贝</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="控制流">
  控制流
  <a class="anchor" href="#%e6%8e%a7%e5%88%b6%e6%b5%81">#</a>
</h4>
<ul>
<li>
<p><strong><code>if/elif/else</code>、<code>for</code>循环和<code>while</code>循环的用法。</strong></p>
<ul>
<li><strong><code>if/elif/else</code></strong>: 用于条件判断，根据条件执行不同的代码块。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>score <span style="color:#f92672">=</span> <span style="color:#ae81ff">85</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> score <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">90</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;优秀&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">elif</span> score <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">60</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;及格&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;不及格&#34;</span>)
</span></span></code></pre></div></li>
<li><strong><code>for</code>循环</strong>: 用于遍历序列（列表、元组、字符串）、集合或其他可迭代对象中的元素。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 遍历列表</span>
</span></span><span style="display:flex;"><span>fruits <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;apple&#34;</span>, <span style="color:#e6db74">&#34;banana&#34;</span>, <span style="color:#e6db74">&#34;cherry&#34;</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> fruit <span style="color:#f92672">in</span> fruits:
</span></span><span style="display:flex;"><span>    print(fruit)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 遍历数字范围</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">5</span>): <span style="color:#75715e"># 从0到4</span>
</span></span><span style="display:flex;"><span>    print(i)
</span></span></code></pre></div></li>
<li><strong><code>while</code>循环</strong>: 当给定条件为真时，重复执行代码块。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> count <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Count is: </span><span style="color:#e6db74">{</span>count<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong><code>break</code>、<code>continue</code>和<code>pass</code>语句的作用。</strong></p>
<ul>
<li><strong><code>break</code></strong>: 立即终止当前循环（<code>for</code>或<code>while</code>），并跳到循环体后面的第一条语句。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span> <span style="color:#75715e"># 当i等于5时，循环停止</span>
</span></span><span style="display:flex;"><span>    print(i) <span style="color:#75715e"># 输出 0 1 2 3 4</span>
</span></span></code></pre></div></li>
<li><strong><code>continue</code></strong>: 终止当前循环的<strong>本次迭代</strong>，并跳到下一次迭代的开头。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">5</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span> <span style="color:#75715e"># 当i等于2时，跳过本次循环的剩余部分，直接进入下一次迭代</span>
</span></span><span style="display:flex;"><span>    print(i) <span style="color:#75715e"># 输出 0 1 3 4</span>
</span></span></code></pre></div></li>
<li><strong><code>pass</code></strong>: 空操作，不做任何事情。它通常用作占位符，当语法要求一个语句但你不需要执行任何操作时使用。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">my_function</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span> <span style="color:#75715e"># 占位符，以后再实现函数体</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span> <span style="color:#75715e"># 占位符，以后再添加条件逻辑</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>列表推导式（list comprehensions）和字典推导式（dictionary comprehensions）的优点和用法。</strong></p>
<ul>
<li><strong>优点</strong>:
<ul>
<li><strong>代码简洁</strong>: 用更少的代码实现复杂逻辑。</li>
<li><strong>效率更高</strong>: 通常比传统的<code>for</code>循环更高效，因为它们在C语言层面实现了优化。</li>
<li><strong>可读性强</strong>: 在很多情况下，推导式能让代码更易于理解。</li>
</ul>
</li>
<li><strong>列表推导式</strong>: 快速创建一个新列表，根据现有列表或其他可迭代对象生成。
<ul>
<li><strong>用法</strong>: <code>[expression for item in iterable if condition]</code></li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 生成1到5的平方数列表</span>
</span></span><span style="display:flex;"><span>squares <span style="color:#f92672">=</span> [x<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>)]
</span></span><span style="display:flex;"><span>print(squares) <span style="color:#75715e"># [1, 4, 9, 16, 25]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 过滤偶数并加倍</span>
</span></span><span style="display:flex;"><span>even_doubled <span style="color:#f92672">=</span> [x <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>) <span style="color:#66d9ef">if</span> x <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>print(even_doubled) <span style="color:#75715e"># [0, 4, 8, 12, 16]</span>
</span></span></code></pre></div></li>
<li><strong>字典推导式</strong>: 快速创建一个新字典。
<ul>
<li><strong>用法</strong>: <code>{key_expression: value_expression for item in iterable if condition}</code></li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 创建一个字典，键是数字，值是其平方</span>
</span></span><span style="display:flex;"><span>squares_dict <span style="color:#f92672">=</span> {x: x<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>)}
</span></span><span style="display:flex;"><span>print(squares_dict) <span style="color:#75715e"># {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 从列表中创建字典，筛选出长度大于3的单词</span>
</span></span><span style="display:flex;"><span>words <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;apple&#34;</span>, <span style="color:#e6db74">&#34;banana&#34;</span>, <span style="color:#e6db74">&#34;cat&#34;</span>, <span style="color:#e6db74">&#34;dog&#34;</span>]
</span></span><span style="display:flex;"><span>word_lengths <span style="color:#f92672">=</span> {word: len(word) <span style="color:#66d9ef">for</span> word <span style="color:#f92672">in</span> words <span style="color:#66d9ef">if</span> len(word) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>print(word_lengths) <span style="color:#75715e"># {&#39;apple&#39;: 5, &#39;banana&#39;: 6}</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="函数">
  函数
  <a class="anchor" href="#%e5%87%bd%e6%95%b0">#</a>
</h4>
<ul>
<li>
<p><strong>如何定义函数？函数参数的类型（位置参数、关键字参数、默认参数、可变参数）？</strong></p>
<ul>
<li><strong>定义函数</strong>: 使用<code>def</code>关键字。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">greet</span>(name):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;这是一个简单的问候函数&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Hello, </span><span style="color:#e6db74">{</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>greet(<span style="color:#e6db74">&#34;Alice&#34;</span>)
</span></span></code></pre></div></li>
<li><strong>函数参数类型</strong>:
<ul>
<li><strong>位置参数（Positional Arguments）</strong>: 按照参数的顺序传入。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add</span>(a, b):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b
</span></span><span style="display:flex;"><span>print(add(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>)) <span style="color:#75715e"># a=10, b=20</span>
</span></span></code></pre></div></li>
<li><strong>关键字参数（Keyword Arguments）</strong>: 通过参数名来指定，不依赖位置。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">show_info</span>(name, age):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Name: </span><span style="color:#e6db74">{</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">, Age: </span><span style="color:#e6db74">{</span>age<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>show_info(age<span style="color:#f92672">=</span><span style="color:#ae81ff">30</span>, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Bob&#34;</span>) <span style="color:#75715e"># 顺序无关</span>
</span></span></code></pre></div></li>
<li><strong>默认参数（Default Arguments）</strong>: 定义时赋有默认值的参数。如果调用时没有传入，则使用默认值。默认参数必须放在非默认参数的后面。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">say_hello</span>(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;World&#34;</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Hello, </span><span style="color:#e6db74">{</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">!&#34;</span>)
</span></span><span style="display:flex;"><span>say_hello()         <span style="color:#75715e"># Hello, World!</span>
</span></span><span style="display:flex;"><span>say_hello(<span style="color:#e6db74">&#34;Python&#34;</span>) <span style="color:#75715e"># Hello, Python!</span>
</span></span></code></pre></div></li>
<li><strong>可变位置参数（Arbitrary Positional Arguments）</strong>: 使用<code>*args</code>。它会将传入的所有位置参数收集到一个元组中。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_all</span>(<span style="color:#f92672">*</span>numbers):
</span></span><span style="display:flex;"><span>    total <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> numbers:
</span></span><span style="display:flex;"><span>        total <span style="color:#f92672">+=</span> num
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> total
</span></span><span style="display:flex;"><span>print(sum_all(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)) <span style="color:#75715e"># 10</span>
</span></span></code></pre></div></li>
<li><strong>可变关键字参数（Arbitrary Keyword Arguments）</strong>: 使用<code>**kwargs</code>。它会将传入的所有关键字参数收集到一个字典中。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">show_details</span>(<span style="color:#f92672">**</span>details):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> key, value <span style="color:#f92672">in</span> details<span style="color:#f92672">.</span>items():
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>key<span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{</span>value<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>show_details(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Alice&#34;</span>, age<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span>, city<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;New York&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># name: Alice</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># age: 25</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># city: New York</span>
</span></span></code></pre></div></li>
<li><strong>参数顺序</strong>: 定义时，通常的顺序是：位置参数 -&gt; 默认参数 -&gt; <code>*args</code> -&gt; 关键字参数 -&gt; <code>**kwargs</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>*args</code>和<code>**kwargs</code>的用法和区别。</strong></p>
<ul>
<li><strong><code>*args</code></strong>:
<ul>
<li><strong>用法</strong>: 用于接收任意数量的<strong>位置参数</strong>。在函数定义中，<code>*args</code>前的星号表示将这些参数打包成一个<strong>元组（tuple）</strong>。</li>
<li><strong>场景</strong>: 当你不确定函数会被传入多少个位置参数时。</li>
<li><strong>例子</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print_items</span>(<span style="color:#f92672">*</span>items):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> items:
</span></span><span style="display:flex;"><span>        print(item)
</span></span><span style="display:flex;"><span>print_items(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#66d9ef">True</span>)
</span></span></code></pre></div></li>
</ul>
</li>
<li><strong><code>**kwargs</code></strong>:
<ul>
<li><strong>用法</strong>: 用于接收任意数量的<strong>关键字参数</strong>。在函数定义中，<code>**kwargs</code>前的双星号表示将这些参数打包成一个<strong>字典（dictionary）</strong>。</li>
<li><strong>场景</strong>: 当你不确定函数会被传入多少个关键字参数，或者想在函数内部以键值对的形式访问这些参数时。</li>
<li><strong>例子</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">process_config</span>(<span style="color:#f92672">**</span>config):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> key, value <span style="color:#f92672">in</span> config<span style="color:#f92672">.</span>items():
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>key<span style="color:#e6db74">}</span><span style="color:#e6db74"> = </span><span style="color:#e6db74">{</span>value<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>process_config(host<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost&#34;</span>, port<span style="color:#f92672">=</span><span style="color:#ae81ff">8080</span>, debug<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span></code></pre></div></li>
</ul>
</li>
<li><strong>区别总结</strong>:
<ul>
<li><code>*args</code>收集位置参数，返回<strong>元组</strong>。</li>
<li><code>**kwargs</code>收集关键字参数，返回<strong>字典</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>什么是<code>lambda</code>函数？它有哪些应用场景？</strong></p>
<ul>
<li><strong><code>lambda</code>函数（匿名函数）</strong>:
<ul>
<li>是一种小型、匿名、单行的函数。</li>
<li>它没有函数名，因此被称为“匿名”。</li>
<li>只能包含一个表达式，表达式的计算结果就是函数的返回值。</li>
<li>语法: <code>lambda arguments: expression</code></li>
</ul>
</li>
<li><strong>应用场景</strong>:
<ul>
<li><strong>作为高阶函数的参数</strong>: <code>lambda</code>函数常用于那些需要一个函数作为参数的函数（高阶函数），例如<code>map()</code>, <code>filter()</code>, <code>sorted()</code>的<code>key</code>参数。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># sorted() 使用 lambda 作为 key</span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> [{<span style="color:#e6db74">&#39;name&#39;</span>: <span style="color:#e6db74">&#39;Alice&#39;</span>, <span style="color:#e6db74">&#39;age&#39;</span>: <span style="color:#ae81ff">30</span>}, {<span style="color:#e6db74">&#39;name&#39;</span>: <span style="color:#e6db74">&#39;Bob&#39;</span>, <span style="color:#e6db74">&#39;age&#39;</span>: <span style="color:#ae81ff">25</span>}]
</span></span><span style="display:flex;"><span>sorted_data <span style="color:#f92672">=</span> sorted(data, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> x: x[<span style="color:#e6db74">&#39;age&#39;</span>])
</span></span><span style="display:flex;"><span>print(sorted_data) <span style="color:#75715e"># 按age排序</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># filter() 使用 lambda</span>
</span></span><span style="display:flex;"><span>numbers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>even_numbers <span style="color:#f92672">=</span> list(filter(<span style="color:#66d9ef">lambda</span> x: x <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>, numbers))
</span></span><span style="display:flex;"><span>print(even_numbers) <span style="color:#75715e"># [2, 4, 6]</span>
</span></span></code></pre></div></li>
<li><strong>简单的回调函数</strong>: 需要一个简单的、一次性的函数来处理某个事件或逻辑时。</li>
<li><strong>简洁性</strong>: 当函数逻辑非常简单，并且只使用一次时，使用<code>lambda</code>可以使代码更简洁。</li>
</ul>
</li>
<li><strong>局限性</strong>: 只能是单行表达式，不能包含复杂的语句（如<code>if/else</code>分支、循环等）。</li>
</ul>
</li>
<li>
<p><strong>作用域（LEGB原则：Local, Enclosing, Global, Built-in）的理解。</strong>
Python解析变量名时，会按照特定的顺序查找变量，这个顺序就是LEGB原则：</p>
<ul>
<li><strong>L (Local)</strong>: 当前函数内部的作用域。在函数中定义的变量（形参、局部变量）。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">my_function</span>():
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> <span style="color:#75715e"># x是局部变量</span>
</span></span><span style="display:flex;"><span>    print(x)
</span></span><span style="display:flex;"><span>my_function()
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(x) # 这会报错，因为x不在全局作用域</span>
</span></span></code></pre></div></li>
<li><strong>E (Enclosing)</strong>: 外部嵌套函数的作用域。指在一个函数中定义了另一个函数（嵌套函数），内部函数可以访问外部函数的非全局变量。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">outer_function</span>():
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span> <span style="color:#75715e"># x是外部函数的局部变量</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner_function</span>():
</span></span><span style="display:flex;"><span>        print(x) <span style="color:#75715e"># inner_function访问outer_function的x</span>
</span></span><span style="display:flex;"><span>    inner_function()
</span></span><span style="display:flex;"><span>outer_function() <span style="color:#75715e"># 输出 20</span>
</span></span></code></pre></div></li>
<li><strong>G (Global)</strong>: 全局作用域。模块级别定义的变量，在整个文件中都可以访问。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>y <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span> <span style="color:#75715e"># y是全局变量</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">another_function</span>():
</span></span><span style="display:flex;"><span>    print(y)
</span></span><span style="display:flex;"><span>another_function() <span style="color:#75715e"># 输出 30</span>
</span></span></code></pre></div></li>
<li><strong>B (Built-in)</strong>: 内置作用域。Python内置的函数和常量，如<code>print()</code>, <code>len()</code>, <code>True</code>, <code>None</code>等。它们始终可用。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>print(len(<span style="color:#e6db74">&#34;hello&#34;</span>)) <span style="color:#75715e"># len是内置函数</span>
</span></span></code></pre></div></li>
</ul>
<p><strong>查找顺序</strong>: 当Python查找一个变量时，它会首先在Local作用域中查找，如果找不到，则在Enclosing作用域中查找，然后是Global作用域，最后是Built-in作用域。如果所有作用域都找不到，就会抛出<code>NameError</code>。</p>
</li>
<li>
<p><strong>闭包（closures）和装饰器（decorators）的原理和应用。</strong></p>
<ul>
<li><strong>闭包（Closures）</strong>:
<ul>
<li><strong>原理</strong>: 当一个<strong>内部函数</strong>引用了其<strong>外部（Enclosing）函数作用域</strong>中的变量（而不是全局变量），并且外部函数返回了这个内部函数时，这个内部函数就形成了闭包。即使外部函数已经执行完毕，其内部函数仍然能“记住”并访问外部函数的局部变量。</li>
<li><strong>应用</strong>:
<ul>
<li><strong>数据隐藏/封装</strong>: 保持某个状态，例如工厂函数。</li>
<li><strong>延迟计算</strong>: 在需要时才执行计算。</li>
<li><strong>函数工厂</strong>: 生成一系列行为相似但参数不同的函数。</li>
</ul>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">make_multiplier</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">multiplier</span>(n):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> x <span style="color:#f92672">*</span> n <span style="color:#75715e"># 内部函数引用了外部函数的x</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> multiplier <span style="color:#75715e"># 返回内部函数</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>times_5 <span style="color:#f92672">=</span> make_multiplier(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>times_3 <span style="color:#f92672">=</span> make_multiplier(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>print(times_5(<span style="color:#ae81ff">10</span>)) <span style="color:#75715e"># 50 (5 * 10)</span>
</span></span><span style="display:flex;"><span>print(times_3(<span style="color:#ae81ff">10</span>)) <span style="color:#75715e"># 30 (3 * 10)</span>
</span></span></code></pre></div></li>
<li><strong>装饰器（Decorators）</strong>:
<ul>
<li><strong>原理</strong>: 装饰器本质上是一个函数，它接受一个函数作为参数，并返回一个<strong>新的函数</strong>。它用于在不修改原函数代码的情况下，给原函数添加额外的功能（例如日志、权限校验、性能计时等）。Python使用<code>@</code>语法糖来应用装饰器。</li>
<li><strong>应用</strong>:
<ul>
<li><strong>日志记录</strong>: 在函数执行前后记录日志。</li>
<li><strong>权限验证</strong>: 检查用户是否有权限访问某个函数。</li>
<li><strong>性能分析</strong>: 测量函数执行时间。</li>
<li><strong>缓存</strong>: 缓存函数结果以提高性能。</li>
<li><strong>路由</strong>: Flask/Django等Web框架中用于定义URL路由。</li>
</ul>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">log_function_call</span>(func):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Calling function: </span><span style="color:#e6db74">{</span>func<span style="color:#f92672">.</span>__name__<span style="color:#e6db74">}</span><span style="color:#e6db74"> with args: </span><span style="color:#e6db74">{</span>args<span style="color:#e6db74">}</span><span style="color:#e6db74">, kwargs: </span><span style="color:#e6db74">{</span>kwargs<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Function </span><span style="color:#e6db74">{</span>func<span style="color:#f92672">.</span>__name__<span style="color:#e6db74">}</span><span style="color:#e6db74"> finished. Result: </span><span style="color:#e6db74">{</span>result<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wrapper
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@log_function_call</span> <span style="color:#75715e"># 等同于 my_add = log_function_call(my_add)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">my_add</span>(a, b):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(my_add(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 输出:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Calling function: my_add with args: (1, 2), kwargs: {}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function my_add finished. Result: 3</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="面向对象编程oop">
  面向对象编程（OOP）
  <a class="anchor" href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8boop">#</a>
</h4>
<ul>
<li>
<p><strong>Python中面向对象的基本概念：类、对象、属性、方法。</strong></p>
<ul>
<li><strong>类（Class）</strong>:
<ul>
<li>定义了一组<strong>属性（数据）和方法（行为）的蓝图或模板</strong>。</li>
<li>它描述了将要创建的对象的共同特征。</li>
<li>例如：<code>Car</code>类可以定义车的颜色、品牌（属性）和启动、停止（方法）。</li>
</ul>
</li>
<li><strong>对象（Object）/实例（Instance）</strong>:
<ul>
<li>根据类创建的<strong>具体实体</strong>。</li>
<li>每个对象都有自己的属性值，并且可以调用类中定义的方法。</li>
<li>例如：<code>my_car = Car(&quot;red&quot;, &quot;Tesla&quot;)</code>，<code>my_car</code>就是一个<code>Car</code>类的对象。</li>
</ul>
</li>
<li><strong>属性（Attribute）</strong>:
<ul>
<li>类中定义的<strong>数据成员</strong>，表示对象的特征或状态。</li>
<li>可以是类属性（所有实例共享）或实例属性（每个实例独有）。</li>
<li>例如：<code>Car</code>类中的<code>color</code>, <code>brand</code>。</li>
</ul>
</li>
<li><strong>方法（Method）</strong>:
<ul>
<li>类中定义的<strong>函数</strong>，表示对象的行为或操作。</li>
<li>方法必须至少有一个参数<code>self</code>，它指向当前对象实例。</li>
<li>例如：<code>Car</code>类中的<code>start()</code>, <code>stop()</code>。</li>
</ul>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Car</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 类属性 (所有实例共享)</span>
</span></span><span style="display:flex;"><span>    wheel_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, color, brand):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 实例属性 (每个实例独有)</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>color <span style="color:#f92672">=</span> color
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>brand <span style="color:#f92672">=</span> brand
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>is_running <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 方法</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">start</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>is_running:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;The </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>color<span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>brand<span style="color:#e6db74">}</span><span style="color:#e6db74"> is starting.&#34;</span>)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>is_running <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;The car is already running.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">stop</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>is_running:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;The </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>color<span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>brand<span style="color:#e6db74">}</span><span style="color:#e6db74"> is stopping.&#34;</span>)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>is_running <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;The car is already stopped.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>my_car <span style="color:#f92672">=</span> Car(<span style="color:#e6db74">&#34;blue&#34;</span>, <span style="color:#e6db74">&#34;BMW&#34;</span>) <span style="color:#75715e"># 创建对象/实例</span>
</span></span><span style="display:flex;"><span>your_car <span style="color:#f92672">=</span> Car(<span style="color:#e6db74">&#34;red&#34;</span>, <span style="color:#e6db74">&#34;Mercedes&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(my_car<span style="color:#f92672">.</span>color) <span style="color:#75715e"># 访问属性</span>
</span></span><span style="display:flex;"><span>my_car<span style="color:#f92672">.</span>start()      <span style="color:#75715e"># 调用方法</span>
</span></span><span style="display:flex;"><span>your_car<span style="color:#f92672">.</span>stop()
</span></span><span style="display:flex;"><span>print(Car<span style="color:#f92672">.</span>wheel_count) <span style="color:#75715e"># 访问类属性</span>
</span></span></code></pre></div></li>
<li>
<p><strong>继承、多态和封装的实现和理解。</strong>
这三者是OOP的<strong>三大特性</strong>。</p>
<ul>
<li><strong>继承（Inheritance）</strong>:
<ul>
<li><strong>定义</strong>: 允许一个类（子类/派生类）继承另一个类（父类/基类）的属性和方法。子类可以重用父类的代码，并在此基础上添加新的功能或修改旧功能。</li>
<li><strong>实现</strong>: 子类定义时，在括号中指定父类。</li>
<li><strong>优点</strong>: 代码重用性，减少冗余；建立清晰的层次结构。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Vehicle</span>: <span style="color:#75715e"># 父类</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, brand):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>brand <span style="color:#f92672">=</span> brand
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">accelerate</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>brand<span style="color:#e6db74">}</span><span style="color:#e6db74"> is accelerating.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ElectricCar</span>(Vehicle): <span style="color:#75715e"># 子类继承Vehicle</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, brand, battery_life):
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span><span style="color:#a6e22e">__init__</span>(brand) <span style="color:#75715e"># 调用父类的__init__</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>battery_life <span style="color:#f92672">=</span> battery_life
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">charge</span>(self): <span style="color:#75715e"># 子类特有的方法</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Charging the </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>brand<span style="color:#e6db74">}</span><span style="color:#e6db74"> electric car.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">accelerate</span>(self): <span style="color:#75715e"># 子类重写父类方法</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;The electric </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>brand<span style="color:#e6db74">}</span><span style="color:#e6db74"> is quietly accelerating.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tesla <span style="color:#f92672">=</span> ElectricCar(<span style="color:#e6db74">&#34;Tesla&#34;</span>, <span style="color:#e6db74">&#34;Long&#34;</span>)
</span></span><span style="display:flex;"><span>tesla<span style="color:#f92672">.</span>accelerate() <span style="color:#75715e"># 调用子类重写的方法</span>
</span></span><span style="display:flex;"><span>tesla<span style="color:#f92672">.</span>charge()
</span></span></code></pre></div></li>
<li><strong>多态（Polymorphism）</strong>:
<ul>
<li><strong>定义</strong>: 指不同类的对象，对同一消息（方法调用）做出不同的响应。即同一个方法名，在不同对象上表现出不同的行为。这依赖于继承和方法重写（Override）。</li>
<li><strong>实现</strong>: 子类重写父类方法，或者多个不相关的类实现相同的方法名。</li>
<li><strong>优点</strong>: 增加代码的灵活性和可扩展性，可以处理不同类型的对象而无需知道其具体类型。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">make_it_accelerate</span>(vehicle):
</span></span><span style="display:flex;"><span>    vehicle<span style="color:#f92672">.</span>accelerate() <span style="color:#75715e"># 这里的vehicle可以是Vehicle对象，也可以是ElectricCar对象</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>car_obj <span style="color:#f92672">=</span> Vehicle(<span style="color:#e6db74">&#34;Toyota&#34;</span>)
</span></span><span style="display:flex;"><span>electric_car_obj <span style="color:#f92672">=</span> ElectricCar(<span style="color:#e6db74">&#34;Nissan&#34;</span>, <span style="color:#e6db74">&#34;Short&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>make_it_accelerate(car_obj)         <span style="color:#75715e"># Toyota is accelerating.</span>
</span></span><span style="display:flex;"><span>make_it_accelerate(electric_car_obj) <span style="color:#75715e"># The electric Nissan is quietly accelerating.</span>
</span></span></code></pre></div></li>
<li><strong>封装（Encapsulation）</strong>:
<ul>
<li><strong>定义</strong>: 将数据（属性）和操作数据的方法（方法）捆绑在一起，形成一个独立的单元（类），并对外部隐藏内部实现的细节。只暴露必要的接口给外部，防止外部直接访问和修改对象内部状态，从而保证数据的安全性和完整性。</li>
<li><strong>实现</strong>:
<ul>
<li>Python没有严格的<code>private</code>关键字，但约定使用<strong>单下划线</strong>（<code>_</code>）表示受保护成员，<strong>双下划线</strong>（<code>__</code>）表示私有成员（会被名称修饰/manglling）。</li>
<li>通过提供公共的getter和setter方法来控制对属性的访问。</li>
</ul>
</li>
<li><strong>优点</strong>: 提高代码的安全性、可维护性和模块化。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BankAccount</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, balance):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>__balance <span style="color:#f92672">=</span> balance <span style="color:#75715e"># 双下划线表示&#34;私有&#34;属性 (名称修饰)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">deposit</span>(self, amount):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> amount <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>__balance <span style="color:#f92672">+=</span> amount
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Deposited </span><span style="color:#e6db74">{</span>amount<span style="color:#e6db74">}</span><span style="color:#e6db74">. New balance: </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>__balance<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;Deposit amount must be positive.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">withdraw</span>(self, amount):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;</span> amount <span style="color:#f92672">&lt;=</span> self<span style="color:#f92672">.</span>__balance:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>__balance <span style="color:#f92672">-=</span> amount
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Withdrew </span><span style="color:#e6db74">{</span>amount<span style="color:#e6db74">}</span><span style="color:#e6db74">. New balance: </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>__balance<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;Invalid withdrawal amount or insufficient balance.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_balance</span>(self): <span style="color:#75715e"># 公共方法来访问私有属性</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>__balance
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>account <span style="color:#f92672">=</span> BankAccount(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>account<span style="color:#f92672">.</span>deposit(<span style="color:#ae81ff">50</span>)
</span></span><span style="display:flex;"><span>account<span style="color:#f92672">.</span>withdraw(<span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(account.__balance) # 这会报错：AttributeError: &#39;BankAccount&#39; object has no attribute &#39;__balance&#39;</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e"># Python将其内部名称修改为 _BankAccount__balance</span>
</span></span><span style="display:flex;"><span>print(account<span style="color:#f92672">.</span>get_balance()) <span style="color:#75715e"># 通过公共方法访问</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>类方法（<code>@classmethod</code>）、静态方法（<code>@staticmethod</code>）和实例方法的区别。</strong>
这三种方法在类中的定义和调用方式不同，主要区别在于它们接收的第一个参数和应用场景。</p>
<ul>
<li>
<p><strong>实例方法（Instance Method）</strong>:</p>
<ul>
<li><strong>定义</strong>: 不需要特殊装饰器。</li>
<li><strong>第一个参数</strong>: 必须是<code>self</code>，指向<strong>实例对象本身</strong>。</li>
<li><strong>访问</strong>: 可以访问和修改实例的属性和方法，也可以访问类属性和类方法。</li>
<li><strong>调用</strong>: 通过<strong>实例对象</strong>调用。</li>
<li><strong>场景</strong>: 操作与特定实例状态相关的数据或行为。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">instance_method</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;这是实例方法，可以访问实例：</span><span style="color:#e6db74">{</span>self<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># print(self.instance_attr) # 假设有实例属性</span>
</span></span></code></pre></div></li>
<li>
<p><strong>类方法（Class Method）</strong>:</p>
<ul>
<li><strong>定义</strong>: 使用<code>@classmethod</code>装饰器。</li>
<li><strong>第一个参数</strong>: 必须是<code>cls</code>，指向<strong>类本身</strong>。</li>
<li><strong>访问</strong>: 可以访问和修改类属性，可以调用其他类方法，但<strong>不能直接访问实例属性或实例方法</strong>（除非通过<code>cls()</code>创建新实例）。</li>
<li><strong>调用</strong>: 可以通过<strong>类名</strong>调用，也可以通过实例对象调用（但不推荐，因为没有必要）。</li>
<li><strong>场景</strong>:
<ul>
<li>操作与类状态相关的数据或行为（如修改类属性）。</li>
<li>创建工厂方法，用于根据不同的参数创建类的不同实例。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>:
</span></span><span style="display:flex;"><span>    class_variable <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@classmethod</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">class_method</span>(cls, value):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;这是类方法，可以访问类：</span><span style="color:#e6db74">{</span>cls<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        cls<span style="color:#f92672">.</span>class_variable <span style="color:#f92672">=</span> value <span style="color:#75715e"># 修改类属性</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;类变量更新为：</span><span style="color:#e6db74">{</span>cls<span style="color:#f92672">.</span>class_variable<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MyClass<span style="color:#f92672">.</span>class_method(<span style="color:#ae81ff">10</span>) <span style="color:#75715e"># 通过类名调用</span>
</span></span><span style="display:flex;"><span>print(MyClass<span style="color:#f92672">.</span>class_variable) <span style="color:#75715e"># 10</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>静态方法（Static Method）</strong>:</p>
<ul>
<li><strong>定义</strong>: 使用<code>@staticmethod</code>装饰器。</li>
<li><strong>第一个参数</strong>: <strong>不需要</strong><code>self</code>或<code>cls</code>参数。</li>
<li><strong>访问</strong>: 既不能访问实例属性，也不能访问类属性（除非通过类名直接访问，但这与普通函数无异）。它与类或实例的状态<strong>无关</strong>。</li>
<li><strong>调用</strong>: 可以通过<strong>类名</strong>调用，也可以通过实例对象调用。</li>
<li><strong>场景</strong>:
<ul>
<li>当一个方法逻辑上属于类，但又不需要访问类或实例的任何属性时（例如，工具函数、辅助函数）。</li>
<li>将类相关的纯函数放在类中，提高代码的组织性。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@staticmethod</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">static_method</span>(x, y):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;这是静态方法，与实例和类无关&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(MyClass<span style="color:#f92672">.</span>static_method(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">3</span>)) <span style="color:#75715e"># 通过类名调用</span>
</span></span><span style="display:flex;"><span>obj <span style="color:#f92672">=</span> MyClass()
</span></span><span style="display:flex;"><span>print(obj<span style="color:#f92672">.</span>static_method(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>))   <span style="color:#75715e"># 通过实例调用 (不推荐)</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<p><strong>总结表格</strong>:</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特性</th>
          <th style="text-align: left">实例方法</th>
          <th style="text-align: left">类方法</th>
          <th style="text-align: left">静态方法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">第一个参数</td>
          <td style="text-align: left"><code>self</code> (实例)</td>
          <td style="text-align: left"><code>cls</code> (类)</td>
          <td style="text-align: left">无 (<code>self</code> 或 <code>cls</code>)</td>
      </tr>
      <tr>
          <td style="text-align: left">访问实例属性</td>
          <td style="text-align: left">是</td>
          <td style="text-align: left">否 (直接访问)</td>
          <td style="text-align: left">否</td>
      </tr>
      <tr>
          <td style="text-align: left">访问类属性</td>
          <td style="text-align: left">是</td>
          <td style="text-align: left">是</td>
          <td style="text-align: left">否 (直接访问类名)</td>
      </tr>
      <tr>
          <td style="text-align: left">调用方式</td>
          <td style="text-align: left">实例对象调用</td>
          <td style="text-align: left">类名或实例对象调用</td>
          <td style="text-align: left">类名或实例对象调用</td>
      </tr>
      <tr>
          <td style="text-align: left">典型场景</td>
          <td style="text-align: left">操作实例数据</td>
          <td style="text-align: left">创建工厂方法，操作类数据</td>
          <td style="text-align: left">工具函数，与类或实例无关</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>特殊方法（dunder methods，如<code>__init__</code>, <code>__str__</code>, <code>__len__</code>等）的用途。</strong></p>
<ul>
<li><strong>特殊方法（Special Methods）</strong>，也称为<strong>魔术方法（Magic Methods）或双下划线方法（Dunder Methods）</strong>，是Python中以双下划线开头和结尾的方法（例如<code>__method_name__</code>）。它们是Python内部实现的机制，允许我们定义自定义类如何响应内置操作或函数（如算术运算、迭代、属性访问、字符串表示等）。</li>
<li><strong>用途</strong>:
<ul>
<li><strong>自定义行为</strong>: 让自定义类的对象能够像内置类型一样使用，例如支持<code>+</code>运算符、<code>len()</code>函数、迭代等。</li>
<li><strong>实现协议</strong>: 实现特定的“协议”（如迭代器协议、上下文管理器协议），从而让类的对象能够与<code>for</code>循环、<code>with</code>语句等Python特性协同工作。</li>
<li><strong>更清晰的代码</strong>: 通过重载操作符，使代码更具表现力和可读性。</li>
</ul>
</li>
</ul>
<p><strong>常见特殊方法示例</strong>:</p>
<ul>
<li><strong><code>__init__(self, ...)</code></strong>: <strong>构造方法</strong>。
<ul>
<li><strong>用途</strong>: 在创建类的新实例时被自动调用。用于初始化实例的属性。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, x, y):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> x
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> y
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> Point(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>) <span style="color:#75715e"># 调用 __init__</span>
</span></span></code></pre></div></li>
<li><strong><code>__str__(self)</code></strong>: <strong>字符串表示（用户友好）</strong>。
<ul>
<li><strong>用途</strong>: 当使用<code>str()</code>函数或<code>print()</code>函数将对象转换为字符串时被调用。它应该返回一个用户可读的、对象的“非正式”字符串表示。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, x, y):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> x
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> y
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__str__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Point(</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>x<span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>y<span style="color:#e6db74">}</span><span style="color:#e6db74">)&#34;</span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> Point(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>print(p) <span style="color:#75715e"># Point(1, 2)</span>
</span></span></code></pre></div></li>
<li><strong><code>__repr__(self)</code></strong>: <strong>字符串表示（开发者友好）</strong>。
<ul>
<li><strong>用途</strong>: 当使用<code>repr()</code>函数或在交互式解释器中直接输入对象时被调用。它应该返回一个明确的、可重现对象的“正式”字符串表示，通常是能够重新创建该对象的字符串形式。如果<code>__str__</code>未定义，<code>print()</code>会回退到<code>__repr__</code>。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, x, y):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> x
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> y
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__repr__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Point(</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>x<span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>y<span style="color:#e6db74">}</span><span style="color:#e6db74">)&#34;</span> <span style="color:#75715e"># 可以重新创建对象的字符串</span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> Point(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>print(repr(p)) <span style="color:#75715e"># Point(1, 2)</span>
</span></span></code></pre></div></li>
<li><strong><code>__len__(self)</code></strong>: <strong>长度</strong>。
<ul>
<li><strong>用途</strong>: 当使用<code>len()</code>函数获取对象的长度时被调用。必须返回一个非负整数。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyList</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, data):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__len__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> len(self<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>my_list <span style="color:#f92672">=</span> MyList([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>])
</span></span><span style="display:flex;"><span>print(len(my_list)) <span style="color:#75715e"># 5</span>
</span></span></code></pre></div></li>
<li><strong><code>__add__(self, other)</code></strong>: <strong>加法运算符（<code>+</code>）</strong>。
<ul>
<li><strong>用途</strong>: 定义当对象使用<code>+</code>运算符时的行为。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Vector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, x, y):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> x
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> y
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__add__</span>(self, other):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Vector(self<span style="color:#f92672">.</span>x <span style="color:#f92672">+</span> other<span style="color:#f92672">.</span>x, self<span style="color:#f92672">.</span>y <span style="color:#f92672">+</span> other<span style="color:#f92672">.</span>y)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__repr__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Vector(</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>x<span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>y<span style="color:#e6db74">}</span><span style="color:#e6db74">)&#34;</span>
</span></span><span style="display:flex;"><span>v1 <span style="color:#f92672">=</span> Vector(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>v2 <span style="color:#f92672">=</span> Vector(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>v3 <span style="color:#f92672">=</span> v1 <span style="color:#f92672">+</span> v2
</span></span><span style="display:flex;"><span>print(v3) <span style="color:#75715e"># Vector(4, 6)</span>
</span></span></code></pre></div></li>
<li><strong><code>__getitem__(self, key)</code></strong>: <strong>索引访问（<code>[]</code>）</strong>。
<ul>
<li><strong>用途</strong>: 定义当对象使用索引（如列表或字典）访问元素时的行为。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyContainer</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, data):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__getitem__</span>(self, index):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>data[index]
</span></span><span style="display:flex;"><span>mc <span style="color:#f92672">=</span> MyContainer([<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>])
</span></span><span style="display:flex;"><span>print(mc[<span style="color:#ae81ff">0</span>]) <span style="color:#75715e"># 10</span>
</span></span><span style="display:flex;"><span>print(mc[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>]) <span style="color:#75715e"># [20, 30]</span>
</span></span></code></pre></div></li>
<li><strong><code>__iter__(self)</code>和<code>__next__(self)</code></strong>: <strong>迭代器协议</strong>。
<ul>
<li><strong>用途</strong>: 实现这两个方法可以使对象成为一个<strong>迭代器</strong>，从而可以使用<code>for</code>循环进行迭代。</li>
<li><code>__iter__</code>返回迭代器对象本身（通常是<code>self</code>）。</li>
<li><code>__next__</code>返回下一个元素，如果没有更多元素则抛出<code>StopIteration</code>。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyRange</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, start, end):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>current <span style="color:#f92672">=</span> start
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>end <span style="color:#f92672">=</span> end
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__iter__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__next__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>current <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>end:
</span></span><span style="display:flex;"><span>            num <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>current
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>current <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> num
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">StopIteration</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> MyRange(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>):
</span></span><span style="display:flex;"><span>    print(i) <span style="color:#75715e"># 1, 2, 3</span>
</span></span></code></pre></div></li>
</ul>
<p>还有很多其他特殊方法，例如用于比较（<code>__eq__</code>, <code>__lt__</code>）、布尔值判断（<code>__bool__</code>）、属性访问（<code>__getattr__</code>, <code>__setattr__</code>）等。</p>
</li>
</ul>
<h4 id="模块与包">
  模块与包
  <a class="anchor" href="#%e6%a8%a1%e5%9d%97%e4%b8%8e%e5%8c%85">#</a>
</h4>
<ul>
<li>
<p><strong><code>import</code>语句的工作原理。</strong>
当Python解释器遇到<code>import</code>语句时，它会执行以下步骤：</p>
<ol>
<li><strong>搜索模块</strong>: 解释器会按照特定的路径（由<code>sys.path</code>定义）搜索模块文件。这些路径包括：
<ul>
<li>当前目录。</li>
<li><code>PYTHONPATH</code>环境变量指定的目录。</li>
<li>Python安装目录下的标准库目录。</li>
<li>第三方库的<code>site-packages</code>目录。</li>
</ul>
</li>
<li><strong>编译（如果需要）</strong>: 如果找到的是<code>.py</code>文件，Python会检查其对应的<code>.pyc</code>（编译后的字节码）文件是否存在且是否最新。如果不存在或已过时，Python会编译<code>.py</code>文件并生成<code>.pyc</code>文件，以提高后续导入速度。</li>
<li><strong>执行模块代码</strong>: 首次导入模块时，Python会执行模块中的所有顶层代码（不在任何函数或类内部的代码）。这会定义模块中所有的函数、类和变量。</li>
<li><strong>创建模块对象</strong>: 执行完代码后，Python会创建一个模块对象，并将其存储在<code>sys.modules</code>字典中。<code>sys.modules</code>是一个字典，包含了已经导入的模块的缓存。</li>
<li><strong>在当前命名空间中绑定名称</strong>:
<ul>
<li><code>import module_name</code>: 将模块对象绑定到当前命名空间的<code>module_name</code>变量上。你可以通过<code>module_name.function()</code>来访问其内容。</li>
<li><code>from module_name import item</code>: 将模块中的<code>item</code>直接绑定到当前命名空间。你可以直接使用<code>item()</code>。</li>
<li><code>from module_name import *</code>: 将模块中所有非以下划线开头的公共名称都绑定到当前命名空间。<strong>不推荐使用</strong>，因为它可能导致命名冲突。</li>
</ul>
</li>
</ol>
<p><strong>重复导入</strong>: 如果一个模块已经被导入过，再次执行<code>import</code>语句时，Python会直接从<code>sys.modules</code>中获取已缓存的模块对象，而不会重新执行模块代码，这提高了效率并避免了重复定义。</p>
</li>
<li>
<p><strong>如何创建和使用模块及包？</strong></p>
<ul>
<li>
<p><strong>模块（Module）</strong>:</p>
<ul>
<li><strong>创建</strong>: 一个<code>.py</code>文件就是一个模块。你可以将相关的函数、类、变量等定义在其中。
例如，创建一个名为<code>my_module.py</code>的文件：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># my_module.py</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">greet</span>(name):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Hello, </span><span style="color:#e6db74">{</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">!&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PI <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14159</span>
</span></span></code></pre></div></li>
<li><strong>使用</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># in another_script.py</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> my_module
</span></span><span style="display:flex;"><span>print(my_module<span style="color:#f92672">.</span>greet(<span style="color:#e6db74">&#34;Alice&#34;</span>)) <span style="color:#75715e"># Hello, Alice!</span>
</span></span><span style="display:flex;"><span>print(my_module<span style="color:#f92672">.</span>PI)             <span style="color:#75715e"># 3.14159</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> my_module <span style="color:#f92672">import</span> greet, PI
</span></span><span style="display:flex;"><span>print(greet(<span style="color:#e6db74">&#34;Bob&#34;</span>))             <span style="color:#75715e"># Hello, Bob!</span>
</span></span><span style="display:flex;"><span>print(PI)                       <span style="color:#75715e"># 3.14159</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> my_module <span style="color:#f92672">import</span> greet <span style="color:#66d9ef">as</span> say_hi
</span></span><span style="display:flex;"><span>print(say_hi(<span style="color:#e6db74">&#34;Charlie&#34;</span>))        <span style="color:#75715e"># Hello, Charlie!</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>包（Package）</strong>:</p>
<ul>
<li><strong>概念</strong>: 包是一种组织模块的方式，它是一个包含其他模块和子包的目录。通过包，可以更好地管理大型项目，避免命名冲突。</li>
<li><strong>创建</strong>: 一个目录如果包含一个特殊的空文件<code>__init__.py</code>，就被视为一个Python包。
例如，创建一个名为<code>my_package</code>的包结构：
<pre tabindex="0"><code>my_package/
├── __init__.py
├── module_a.py
└── sub_package/
    ├── __init__.py
    └── module_b.py
</code></pre><code>my_package/module_a.py</code>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># module_a.py</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func_a</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Function A from module_a&#34;</span>)
</span></span></code></pre></div><code>my_package/sub_package/module_b.py</code>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># module_b.py</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func_b</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Function B from module_b&#34;</span>)
</span></span></code></pre></div></li>
<li><strong>使用</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># in a script outside my_package</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> my_package.module_a
</span></span><span style="display:flex;"><span>my_package<span style="color:#f92672">.</span>module_a<span style="color:#f92672">.</span>func_a() <span style="color:#75715e"># Function A from module_a</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> my_package.sub_package <span style="color:#f92672">import</span> module_b
</span></span><span style="display:flex;"><span>module_b<span style="color:#f92672">.</span>func_b() <span style="color:#75715e"># Function B from module_b</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> my_package.module_a <span style="color:#f92672">import</span> func_a
</span></span><span style="display:flex;"><span>func_a() <span style="color:#75715e"># Function A from module_a</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>__init__.py</code>文件的作用。</strong>
<code>__init__.py</code>文件在Python包中扮演着非常重要的角色：</p>
<ol>
<li><strong>标识包</strong>: 告诉Python解释器，包含它的目录是一个Python包，而不仅仅是一个普通的目录。即使文件内容为空，其存在也至关重要（Python 3.3+ 引入了隐式命名空间包，不再严格要求空<code>__init__.py</code>，但为了兼容性和明确性，通常还是会创建）。</li>
<li><strong>包初始化</strong>: 当包被导入时（例如<code>import my_package</code>），<code>__init__.py</code>文件中的代码会被执行。你可以利用它来：
<ul>
<li><strong>初始化包级别的数据</strong>。</li>
<li><strong>执行任何包导入时所需的设置或副作用</strong>。</li>
<li><strong>控制<code>from package import *</code>的行为</strong>：通过定义<code>__all__</code>列表，可以明确指定<code>*</code>导入时应导入哪些模块或名称。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># my_package/__init__.py</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Initializing my_package...&#34;</span>) <span style="color:#75715e"># 导入包时会打印</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> . <span style="color:#f92672">import</span> module_a <span style="color:#75715e"># 将module_a导入到包的命名空间</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> .sub_package <span style="color:#f92672">import</span> module_b <span style="color:#75715e"># 也可以导入子包中的模块</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>__all__ <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;module_a&#39;</span>] <span style="color:#75715e"># 定义from my_package import *时导入的内容</span>
</span></span></code></pre></div></li>
<li><strong>简化导入</strong>: 可以在<code>__init__.py</code>中导入子模块的特定函数或类，从而允许用户直接从包名导入这些元素，而无需指定完整的子模块路径。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># my_package/__init__.py</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> .module_a <span style="color:#f92672">import</span> func_a
</span></span></code></pre></div>然后用户可以这样导入：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> my_package <span style="color:#f92672">import</span> func_a
</span></span><span style="display:flex;"><span>func_a()
</span></span></code></pre></div></li>
</ol>
</li>
</ul>
<h3 id="2-高级特性与进阶概念答案">
  2. 高级特性与进阶概念答案
  <a class="anchor" href="#2-%e9%ab%98%e7%ba%a7%e7%89%b9%e6%80%a7%e4%b8%8e%e8%bf%9b%e9%98%b6%e6%a6%82%e5%bf%b5%e7%ad%94%e6%a1%88">#</a>
</h3>
<hr>
<h4 id="迭代器iterators与生成器generators">
  迭代器（Iterators）与生成器（Generators）
  <a class="anchor" href="#%e8%bf%ad%e4%bb%a3%e5%99%a8iterators%e4%b8%8e%e7%94%9f%e6%88%90%e5%99%a8generators">#</a>
</h4>
<ul>
<li>
<p><strong>它们是什么？有什么区别和优势？</strong></p>
<ul>
<li>
<p><strong>迭代器（Iterator）</strong>：</p>
<ul>
<li><strong>是什么</strong>：一个对象，它实现了<strong>迭代器协议</strong>，即拥有 <code>__iter__()</code> 和 <code>__next__()</code> 方法。
<ul>
<li><code>__iter__()</code> 方法返回迭代器对象本身。</li>
<li><code>__next__()</code> 方法返回序列中的下一个元素。当没有更多元素时，它会抛出 <code>StopIteration</code> 异常。</li>
</ul>
</li>
<li><strong>作用</strong>：它提供了一种按需访问序列元素的方式，而无需一次性将所有元素加载到内存中。</li>
<li><strong>优势</strong>：
<ul>
<li><strong>内存效率</strong>：一次只生成一个数据项，尤其适合处理大型或无限序列。</li>
<li><strong>惰性求值</strong>：只有在需要时才计算下一个值。</li>
</ul>
</li>
<li><strong>例子</strong>：列表、元组、字符串、字典等都是可迭代对象，它们都可以通过 <code>iter()</code> 函数获取一个迭代器。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>my_list <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>my_iterator <span style="color:#f92672">=</span> iter(my_list) <span style="color:#75715e"># 获取迭代器</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(next(my_iterator)) <span style="color:#75715e"># 1</span>
</span></span><span style="display:flex;"><span>print(next(my_iterator)) <span style="color:#75715e"># 2</span>
</span></span><span style="display:flex;"><span>print(next(my_iterator)) <span style="color:#75715e"># 3</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(next(my_iterator)) # 抛出 StopIteration</span>
</span></span></code></pre></div></li>
<li>
<p><strong>生成器（Generator）</strong>：</p>
<ul>
<li><strong>是什么</strong>：一种特殊的<strong>迭代器</strong>。它是一个函数，但不是通过 <code>return</code> 返回一个值，而是通过 <code>yield</code> 关键字<strong>暂停执行并返回一个值</strong>。当再次调用生成器时，它会从上次 <code>yield</code> 暂停的地方继续执行。</li>
<li><strong>作用</strong>：以更简洁的方式创建迭代器，特别适合生成大型或无限序列，因为它避免了创建完整的列表或其他数据结构。</li>
<li><strong>优势</strong>：
<ul>
<li><strong>简洁性</strong>：使用 <code>yield</code> 语法比手动实现 <code>__iter__()</code> 和 <code>__next__()</code> 方法要简单得多。</li>
<li><strong>内存效率</strong>：与迭代器相同，也是惰性生成，内存占用极小。</li>
<li><strong>无限序列</strong>：可以轻松地生成无限序列，因为它们不会一次性占用所有内存。</li>
</ul>
</li>
<li><strong>例子</strong>：</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">my_generator</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gen <span style="color:#f92672">=</span> my_generator() <span style="color:#75715e"># 调用生成器函数会返回一个生成器对象（迭代器）</span>
</span></span><span style="display:flex;"><span>print(next(gen)) <span style="color:#75715e"># 1</span>
</span></span><span style="display:flex;"><span>print(next(gen)) <span style="color:#75715e"># 2</span>
</span></span><span style="display:flex;"><span>print(next(gen)) <span style="color:#75715e"># 3</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(next(gen)) # 抛出 StopIteration</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 生成器推导式 (类似于列表推导式，但用括号)</span>
</span></span><span style="display:flex;"><span>gen_expr <span style="color:#f92672">=</span> (x <span style="color:#f92672">*</span> x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">5</span>))
</span></span><span style="display:flex;"><span>print(next(gen_expr)) <span style="color:#75715e"># 0</span>
</span></span><span style="display:flex;"><span>print(list(gen_expr)) <span style="color:#75715e"># [1, 4, 9, 16] (会耗尽生成器)</span>
</span></span></code></pre></div></li>
<li>
<p><strong>区别总结</strong>：</p>
<ul>
<li><strong>实现方式</strong>：迭代器是通过实现 <code>__iter__()</code> 和 <code>__next__()</code> 方法来创建的类对象；生成器是通过包含 <code>yield</code> 关键字的函数创建的。</li>
<li><strong>代码复杂性</strong>：生成器通常比手动实现的迭代器更简洁。</li>
<li><strong>本质</strong>：所有生成器都是迭代器，但不是所有迭代器都是生成器。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>yield</code> 关键字的作用。</strong></p>
<ul>
<li><code>yield</code> 关键字用于在<strong>生成器函数</strong>中。当 <code>yield</code> 语句被执行时，函数会<strong>暂停执行</strong>，并将 <code>yield</code> 后面的表达式的值作为结果返回给调用者。</li>
<li>与 <code>return</code> 不同的是，当函数被再次调用时（通过 <code>next()</code>），它会从上次 <code>yield</code> 语句暂停的地方<strong>继续执行</strong>，而不是从头开始。函数的状态（包括局部变量的值）在暂停期间会被保留。</li>
<li>这使得生成器能够<strong>惰性地生成值</strong>，而无需一次性构建整个序列。</li>
</ul>
</li>
<li>
<p><strong>如何实现自定义迭代器？</strong>
要实现自定义迭代器，需要创建一个类，并在这个类中实现迭代器协议的两个核心方法：<code>__iter__()</code> 和 <code>__next__()</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyRange</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, start, end):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>current <span style="color:#f92672">=</span> start
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>end <span style="color:#f92672">=</span> end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__iter__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        返回迭代器对象本身。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        对于MyRange类，其实例本身就是迭代器，所以返回self。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Calling __iter__&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__next__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        返回序列的下一个元素。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        如果没有更多元素，则抛出 StopIteration 异常。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Calling __next__&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>current <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>end:
</span></span><span style="display:flex;"><span>            num <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>current
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>current <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> num
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">StopIteration</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用自定义迭代器</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> MyRange(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>):
</span></span><span style="display:flex;"><span>    print(i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 或者手动调用</span>
</span></span><span style="display:flex;"><span>it <span style="color:#f92672">=</span> MyRange(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>print(next(it)) <span style="color:#75715e"># Calling __next__ -&gt; 1</span>
</span></span><span style="display:flex;"><span>print(next(it)) <span style="color:#75715e"># Calling __next__ -&gt; 2</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(next(it)) # Calling __next__ -&gt; StopIteration</span>
</span></span></code></pre></div></li>
</ul>
<h4 id="上下文管理器context-managers">
  上下文管理器（Context Managers）
  <a class="anchor" href="#%e4%b8%8a%e4%b8%8b%e6%96%87%e7%ae%a1%e7%90%86%e5%99%a8context-managers">#</a>
</h4>
<ul>
<li>
<p><strong><code>with</code> 语句的工作原理。</strong></p>
<ul>
<li><code>with</code> 语句用于简化资源管理，例如文件操作、数据库连接、锁等。它确保在进入和离开代码块时，自动执行资源的获取和释放操作，即使发生异常也能正确处理。</li>
<li><strong>工作原理</strong>：
<ol>
<li><code>with</code> 语句首先调用<strong>上下文管理器</strong>对象的 <code>__enter__()</code> 方法。</li>
<li><code>__enter__()</code> 方法的返回值（如果有）会被赋给 <code>as</code> 关键字后面的变量。</li>
<li>执行 <code>with</code> 块内部的代码。</li>
<li>无论 <code>with</code> 块中的代码是正常执行结束，还是因为异常退出，上下文管理器对象的 <code>__exit__()</code> 方法都会被调用。</li>
<li><code>__exit__(exc_type, exc_val, exc_tb)</code> 方法接收三个参数，分别表示异常类型、异常值和回溯信息。如果 <code>with</code> 块中没有发生异常，这三个参数都为 <code>None</code>。</li>
<li>如果 <code>__exit__()</code> 方法返回 <code>True</code>，则表示它已经处理了异常，异常不会再次传播。如果返回 <code>False</code> 或不返回值，则异常会继续传播。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong><code>__enter__</code> 和 <code>__exit__</code> 方法的作用。</strong></p>
<ul>
<li><strong><code>__enter__(self)</code></strong>:
<ul>
<li><strong>作用</strong>：在进入 <code>with</code> 语句块时被调用。</li>
<li><strong>返回值</strong>：这个方法的返回值（如果有的话）会被赋给 <code>with ... as var:</code> 中的 <code>var</code> 变量。通常用于返回需要操作的资源对象（如文件对象、数据库连接）。</li>
</ul>
</li>
<li><strong><code>__exit__(self, exc_type, exc_val, exc_tb)</code></strong>:
<ul>
<li><strong>作用</strong>：在退出 <code>with</code> 语句块时被调用，无论正常退出还是发生异常。</li>
<li><strong>参数</strong>:
<ul>
<li><code>exc_type</code>: 异常类型（例如 <code>TypeError</code>, <code>ValueError</code>），如果没有异常则为 <code>None</code>。</li>
<li><code>exc_val</code>: 异常值，如果没有异常则为 <code>None</code>。</li>
<li><code>exc_tb</code>: 异常的回溯信息，如果没有异常则为 <code>None</code>。</li>
</ul>
</li>
<li><strong>返回值</strong>:
<ul>
<li>如果 <code>__exit__</code> 返回 <strong><code>True</code></strong>，表示它已经成功处理了 <code>with</code> 块中发生的异常，该异常将<strong>不会向上层传播</strong>。</li>
<li>如果 <code>__exit__</code> 返回 <strong><code>False</code></strong>（或不返回任何值，因为默认返回 <code>None</code>，相当于 <code>False</code>），则表示它没有处理异常，异常会<strong>继续传播</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>如何创建自定义上下文管理器？（例如使用 <code>contextlib</code> 模块）</strong>
创建自定义上下文管理器有两种主要方式：</p>
<ol>
<li>
<p><strong>实现 <code>__enter__</code> 和 <code>__exit__</code> 方法的类</strong>：
这是最直接的方式，如上所述。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FileHandler</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, filename, mode):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>filename <span style="color:#f92672">=</span> filename
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>mode <span style="color:#f92672">=</span> mode
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>file <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__enter__</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Entering context: Opening </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>filename<span style="color:#e6db74">}</span><span style="color:#e6db74"> in </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>mode<span style="color:#e6db74">}</span><span style="color:#e6db74"> mode.&#34;</span>)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>file <span style="color:#f92672">=</span> open(self<span style="color:#f92672">.</span>filename, self<span style="color:#f92672">.</span>mode)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>file <span style="color:#75715e"># 返回文件对象，赋给 &#39;as&#39; 后面的变量</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__exit__</span>(self, exc_type, exc_val, exc_tb):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Exiting context: Closing </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>filename<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>file:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>file<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> exc_type:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;An exception occurred: </span><span style="color:#e6db74">{</span>exc_type<span style="color:#f92672">.</span>__name__<span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{</span>exc_val<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># return True # 如果返回True，异常将被抑制</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span> <span style="color:#75715e"># 异常会继续传播</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用自定义上下文管理器</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> FileHandler(<span style="color:#e6db74">&#34;my_file.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;Hello from context manager!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># raise ValueError(&#34;Something went wrong!&#34;) # 尝试抛出异常</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> FileHandler(<span style="color:#e6db74">&#34;my_file.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    content <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;File content: </span><span style="color:#e6db74">{</span>content<span style="color:#f92672">.</span>strip()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div></li>
<li>
<p><strong>使用 <code>contextlib</code> 模块的 <code>@contextmanager</code> 装饰器</strong>：
这是一个更简洁、更Pythonic的方式，特别是当你的上下文逻辑可以通过生成器函数来表达时。</p>
<ul>
<li>它将一个生成器函数转换为一个上下文管理器。</li>
<li>生成器函数在 <code>yield</code> 之前的部分对应 <code>__enter__</code> 的逻辑。</li>
<li><code>yield</code> 返回的值就是 <code>__enter__</code> 的返回值。</li>
<li><code>yield</code> 之后的部分（包括 <code>finally</code> 或 <code>except</code> 块）对应 <code>__exit__</code> 的逻辑。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> contextlib <span style="color:#f92672">import</span> contextmanager
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@contextmanager</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">open_file_context</span>(filename, mode):
</span></span><span style="display:flex;"><span>    file <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        file <span style="color:#f92672">=</span> open(filename, mode)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Entering context (generator): Opening </span><span style="color:#e6db74">{</span>filename<span style="color:#e6db74">}</span><span style="color:#e6db74"> in </span><span style="color:#e6db74">{</span>mode<span style="color:#e6db74">}</span><span style="color:#e6db74"> mode.&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">yield</span> file <span style="color:#75715e"># yield 的值会赋给 &#39;as&#39; 后面的变量</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;An exception occurred in context: </span><span style="color:#e6db74">{</span>type(e)<span style="color:#f92672">.</span>__name__<span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 异常处理：这里不重新抛出，默认就是不传播，或者可以return True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">finally</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> file:
</span></span><span style="display:flex;"><span>            file<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Exiting context (generator): Closing </span><span style="color:#e6db74">{</span>filename<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 @contextmanager 装饰器创建的上下文管理器</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open_file_context(<span style="color:#e6db74">&#34;another_file.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;Hello from generator context manager!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># raise TypeError(&#34;Another error!&#34;) # 尝试抛出异常</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open_file_context(<span style="color:#e6db74">&#34;another_file.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    content <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;File content: </span><span style="color:#e6db74">{</span>content<span style="color:#f92672">.</span>strip()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p><strong>选择哪种方式？</strong></p>
<ul>
<li>如果上下文管理器的逻辑<strong>简单</strong>，且能用<strong>单次进入/退出</strong>的生成器函数描述，<code>@contextmanager</code> 通常更简洁和推荐。</li>
<li>如果需要更复杂的初始化逻辑，或者需要管理多个内部状态，或者需要更精细地控制异常处理，那么实现类（<code>__enter__</code> 和 <code>__exit__</code>）可能更清晰。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="异常处理">
  异常处理
  <a class="anchor" href="#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86">#</a>
</h4>
<ul>
<li>
<p><strong><code>try/except/finally/else</code> 语句的用法。</strong>
这组语句用于在程序运行时处理错误（异常），以防止程序崩溃，并提供优雅的错误恢复机制。</p>
<ul>
<li><strong><code>try</code></strong>: 包含可能引发异常的代码块。</li>
<li><strong><code>except</code></strong>: 用于捕获和处理 <code>try</code> 块中发生的特定类型或所有类型的异常。可以有多个 <code>except</code> 块来处理不同类型的异常。
<ul>
<li><code>except ExceptionType as var:</code>：捕获特定类型的异常，并将其赋值给 <code>var</code>。</li>
<li><code>except:</code>：捕获所有未被前面 <code>except</code> 捕获的异常（不推荐，因为它会捕获所有错误，包括系统错误，使调试困难）。</li>
</ul>
</li>
<li><strong><code>else</code></strong>: （可选）如果 <code>try</code> 块中的代码<strong>没有引发任何异常</strong>，则执行 <code>else</code> 块中的代码。</li>
<li><strong><code>finally</code></strong>: （可选）无论 <code>try</code> 块中是否发生异常，<code>finally</code> 块中的代码<strong>总会执行</strong>。通常用于执行清理操作（如关闭文件、释放资源）。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">divide</span>(a, b):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> a <span style="color:#f92672">/</span> b
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">ZeroDivisionError</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Error: Cannot divide by zero!&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span> <span style="color:#75715e"># 或者重新抛出异常，或者返回特定值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">TypeError</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Error: Invalid argument type! Please provide numbers.&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e: <span style="color:#75715e"># 捕获所有其他异常</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;An unexpected error occurred: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 如果try块没有异常，则执行这里</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Division successful!&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">finally</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 无论是否发生异常，都会执行这里</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Division attempt finished.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(divide(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;-&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>print(divide(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;-&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>print(divide(<span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;a&#34;</span>))
</span></span></code></pre></div></li>
<li>
<p><strong>如何自定义异常？</strong></p>
<ul>
<li>自定义异常通常通过<strong>继承</strong>Python内置的 <code>Exception</code> 类（或其子类，如 <code>ValueError</code>, <code>TypeError</code> 等）来创建。</li>
<li>继承 <code>Exception</code> 类能确保你的自定义异常能够被标准的异常处理机制捕获。</li>
<li>你可以为自定义异常添加自定义的属性和方法，以提供更详细的错误信息。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InvalidInputError</span>(<span style="color:#a6e22e">Exception</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    自定义异常：表示输入不合法。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, message<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Invalid input provided.&#34;</span>, value<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>message <span style="color:#f92672">=</span> message
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>value <span style="color:#f92672">=</span> value
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span><span style="color:#a6e22e">__init__</span>(self<span style="color:#f92672">.</span>message) <span style="color:#75715e"># 调用父类的构造方法</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__str__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>value <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>message<span style="color:#e6db74">}</span><span style="color:#e6db74"> (Received: </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>value<span style="color:#e6db74">}</span><span style="color:#e6db74">)&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>message
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">process_data</span>(data):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> isinstance(data, (int, float)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> InvalidInputError(<span style="color:#e6db74">&#34;Data must be a number.&#34;</span>, data)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> data <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>(<span style="color:#e6db74">&#34;Data cannot be negative.&#34;</span>) <span style="color:#75715e"># 使用内置异常</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Processing data: </span><span style="color:#e6db74">{</span>data<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>    process_data(<span style="color:#e6db74">&#34;hello&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">except</span> InvalidInputError <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Caught custom error: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">except</span> <span style="color:#a6e22e">ValueError</span> <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Caught ValueError: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Caught generic error: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>    process_data(<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">except</span> InvalidInputError <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Caught custom error: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">except</span> <span style="color:#a6e22e">ValueError</span> <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Caught ValueError: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Caught generic error: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div></li>
</ul>
<h4 id="并发编程">
  并发编程
  <a class="anchor" href="#%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b">#</a>
</h4>
<ul>
<li>
<p><strong>多线程（threading）与多进程（multiprocessing）的区别。</strong>
Python中实现并发主要有两种方式：多线程和多进程。</p>
<ul>
<li>
<p><strong>多线程（<code>threading</code> 模块）</strong>:</p>
<ul>
<li><strong>定义</strong>：在同一个进程中创建多个线程。所有线程共享同一个进程的内存空间，包括全局变量。</li>
<li><strong>并发性</strong>：在CPU密集型任务中，由于 <strong>全局解释器锁（GIL）</strong> 的存在，Python多线程无法真正实现并行计算（即同时执行多个CPU操作），而是表现为<strong>并发</strong>（通过时间片轮转快速切换，看似同时执行）。在IO密集型任务中，GIL会释放，因此多线程可以有效提高效率。</li>
<li><strong>资源共享</strong>：线程之间共享内存，数据通信方便，但需要加锁（<code>Lock</code>、<code>Semaphore</code>等）来避免竞态条件和数据不一致。</li>
<li><strong>创建开销</strong>：创建和管理线程的开销相对较小。</li>
<li><strong>调试</strong>：由于共享内存和GIL，多线程调试可能比较复杂。</li>
<li><strong>适用场景</strong>：IO密集型任务（网络请求、文件读写、数据库操作），因为在等待IO时GIL会被释放，其他线程可以运行。</li>
</ul>
</li>
<li>
<p><strong>多进程（<code>multiprocessing</code> 模块）</strong>:</p>
<ul>
<li><strong>定义</strong>：创建多个独立的进程。每个进程都有自己独立的内存空间，互不影响。</li>
<li><strong>并发性</strong>：每个进程都有独立的Python解释器和独立的GIL。因此，多进程可以实现真正的<strong>并行计算</strong>，充分利用多核CPU的性能。</li>
<li><strong>资源共享</strong>：进程之间不共享内存。数据通信需要通过特定的机制（如队列 <code>Queue</code>、管道 <code>Pipe</code>、共享内存 <code>Value/Array</code>）进行。</li>
<li><strong>创建开销</strong>：创建和管理进程的开销相对较大（因为需要复制整个进程的内存空间）。</li>
<li><strong>调试</strong>：相对简单，因为进程间隔离，一个进程的崩溃通常不会影响其他进程。</li>
<li><strong>适用场景</strong>：CPU密集型任务（大量计算、图像处理、数据分析），因为可以绕过GIL，实现真正的并行。</li>
</ul>
</li>
</ul>
<p><strong>总结表格</strong>:</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特性</th>
          <th style="text-align: left">多线程（Threading）</th>
          <th style="text-align: left">多进程（Multiprocessing）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>本质</strong></td>
          <td style="text-align: left">同一进程内的不同执行流</td>
          <td style="text-align: left">独立的进程</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>内存空间</strong></td>
          <td style="text-align: left">共享同一进程内存</td>
          <td style="text-align: left">各自独立的内存空间</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>GIL影响</strong></td>
          <td style="text-align: left">受GIL限制，无法真正并行（CPU密集型）</td>
          <td style="text-align: left">每个进程有自己的GIL，可实现真正的并行（CPU密集型）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>数据共享</strong></td>
          <td style="text-align: left">直接共享，需加锁同步</td>
          <td style="text-align: left">不共享，需进程间通信机制</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>创建开销</strong></td>
          <td style="text-align: left">较小</td>
          <td style="text-align: left">较大</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>稳定性</strong></td>
          <td style="text-align: left">一个线程崩溃可能影响整个进程</td>
          <td style="text-align: left">一个进程崩溃通常不影响其他进程</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>调试难度</strong></td>
          <td style="text-align: left">较高 (竞态条件、死锁)</td>
          <td style="text-align: left">相对较低</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>适用场景</strong></td>
          <td style="text-align: left">IO密集型任务（网络、文件I/O、数据库）</td>
          <td style="text-align: left">CPU密集型任务（科学计算、数据处理）</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>全局解释器锁（GIL）是什么？它对Python多线程有什么影响？</strong></p>
<ul>
<li>
<p><strong>GIL (Global Interpreter Lock)</strong>：</p>
<ul>
<li><strong>是什么</strong>：GIL 是Python解释器（Cpython是主要的实现）的一个<strong>互斥锁</strong>。它确保在任何给定时刻，只有一个线程可以执行Python字节码。</li>
<li><strong>为什么存在</strong>：GIL 的主要原因是为了简化 CPython 解释器的内存管理。CPython 的垃圾回收机制不是线程安全的，为了避免多线程同时修改共享数据结构导致竞态条件和崩溃，GIL 被引入作为保护机制。</li>
<li><strong>并非Python语言的特性</strong>：需要注意的是，GIL 是CPython解释器的特性，而不是Python语言规范的一部分。其他Python实现（如Jython、IronPython）可能没有GIL。</li>
</ul>
</li>
<li>
<p><strong>对Python多线程的影响</strong>：</p>
<ol>
<li><strong>CPU密集型任务无法并行</strong>：
<ul>
<li>对于执行大量计算而很少等待外部I/O的CPU密集型任务，即使你有多个CPU核心和多个线程，由于GIL的存在，实际上只有一个线程在运行Python字节码。其他线程处于等待GIL释放的状态。</li>
<li>这导致Python多线程无法充分利用多核CPU的优势来实现真正的并行计算。多线程在CPU密集型场景下甚至可能因为线程切换的开销而比单线程更慢。</li>
</ul>
</li>
<li><strong>IO密集型任务可以并发</strong>：
<ul>
<li>对于需要大量等待外部I/O（如网络请求、文件读写、数据库查询）的IO密集型任务，GIL会在等待I/O操作完成时<strong>主动释放</strong>。</li>
<li>这意味着当一个线程因为I/O操作而阻塞时，另一个线程可以获取GIL并执行Python字节码。这样，多个线程可以交替执行，从而实现并发，提高整体效率。</li>
</ul>
</li>
<li><strong>并发而非并行</strong>：
<ul>
<li>GIL使得Python多线程在宏观上看起来是并发的（多个任务交替进行），但在微观上，它们仍然是串行执行Python字节码的（同一时刻只有一个线程在运行）。</li>
<li><strong>绕过GIL的方法</strong>：
<ul>
<li>使用<strong>多进程</strong> (<code>multiprocessing</code>)：每个进程都有自己的Python解释器和GIL，因此可以并行执行。</li>
<li>使用<strong>C扩展模块</strong>：用C/C++编写的扩展模块可以在执行非Python代码时释放GIL。许多高性能库（如NumPy）就是这样做的。</li>
<li>使用<strong>异步I/O</strong> (<code>asyncio</code>)：通过协程实现单线程并发，避免了线程切换的开销和GIL的限制。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>协程（asyncio）的基本概念和使用场景。</strong></p>
<ul>
<li>
<p><strong>协程（Coroutines）</strong>：</p>
<ul>
<li><strong>是什么</strong>：协程是一种用户态的轻量级线程，它在单个线程内实现并发。与线程由操作系统调度不同，协程的调度是由程序自身控制的（即“协作式多任务”）。</li>
<li><strong>特点</strong>：
<ul>
<li><strong>非抢占式</strong>：协程不会被操作系统强制中断。它们必须显式地通过 <code>await</code> 或 <code>yield from</code> 语句将控制权交还给事件循环。</li>
<li><strong>上下文切换开销小</strong>：协程的上下文切换比线程或进程的切换开销小得多，因为它们不需要保存和恢复整个线程的寄存器上下文。</li>
<li><strong>避免GIL限制</strong>：由于协程运行在单一线程中，它们完全不受GIL的限制，可以在IO密集型任务中获得极高的性能。</li>
</ul>
</li>
<li><strong>Python实现</strong>：Python 3.5+ 引入了 <code>async/await</code> 语法糖来更优雅地编写协程，并通过 <code>asyncio</code> 库提供了事件循环、任务调度等基础设施。</li>
<li><strong>核心概念</strong>:
<ul>
<li><strong><code>async def</code></strong>: 定义一个协程函数。</li>
<li><strong><code>await</code></strong>: 用于暂停当前协程的执行，等待另一个“awaitable”对象（如另一个协程、一个Future或一个Task）完成，并将控制权交还给事件循环。</li>
<li><strong>事件循环（Event Loop）</strong>: <code>asyncio</code> 的核心，负责调度和管理协程的执行。当一个协程 <code>await</code> 另一个操作时，事件循环会切换到其他准备就绪的协程。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>使用场景</strong>：</p>
<ul>
<li><strong>IO密集型操作</strong>：这是协程最主要的优势和适用场景。当程序需要等待大量I/O操作（如网络请求、数据库查询、文件I/O）时，使用协程可以显著提高效率。例如，同时发送数百个HTTP请求，传统的同步方式会依次等待，而协程可以在等待一个请求响应时去处理其他请求。</li>
<li><strong>Web服务器和API服务</strong>：<code>asyncio</code> 及其上层的框架（如 FastAPI, Starlette）非常适合构建高性能的Web服务器，因为它们可以高效地处理大量并发连接。</li>
<li><strong>网络爬虫</strong>：进行大量的并发网络请求，提高爬取效率。</li>
<li><strong>消息队列消费者</strong>：等待和处理来自消息队列的消息。</li>
<li><strong>长轮询（Long Polling）</strong>：实时通信应用。</li>
</ul>
</li>
<li>
<p><strong>例子</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> asyncio
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fetch_data</span>(delay, data):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Start fetching </span><span style="color:#e6db74">{</span>data<span style="color:#e6db74">}</span><span style="color:#e6db74"> (delay: </span><span style="color:#e6db74">{</span>delay<span style="color:#e6db74">}</span><span style="color:#e6db74">s)...&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> asyncio<span style="color:#f92672">.</span>sleep(delay) <span style="color:#75715e"># 模拟I/O操作，await会释放控制权给事件循环</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Finished fetching </span><span style="color:#e6db74">{</span>data<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Data: </span><span style="color:#e6db74">{</span>data<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>    start_time <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 创建多个协程任务</span>
</span></span><span style="display:flex;"><span>    task1 <span style="color:#f92672">=</span> asyncio<span style="color:#f92672">.</span>create_task(fetch_data(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;User Info&#34;</span>))
</span></span><span style="display:flex;"><span>    task2 <span style="color:#f92672">=</span> asyncio<span style="color:#f92672">.</span>create_task(fetch_data(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Product List&#34;</span>))
</span></span><span style="display:flex;"><span>    task3 <span style="color:#f92672">=</span> asyncio<span style="color:#f92672">.</span>create_task(fetch_data(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;Order History&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 同时等待所有任务完成</span>
</span></span><span style="display:flex;"><span>    results <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> asyncio<span style="color:#f92672">.</span>gather(task1, task2, task3)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">All tasks completed!&#34;</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Results: </span><span style="color:#e6db74">{</span>results<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    end_time <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Total time: </span><span style="color:#e6db74">{</span>end_time <span style="color:#f92672">-</span> start_time<span style="color:#e6db74">:</span><span style="color:#e6db74">.2f</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> seconds&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 运行事件循环</span>
</span></span><span style="display:flex;"><span>    asyncio<span style="color:#f92672">.</span>run(main())
</span></span></code></pre></div><p>上述代码中，三个 <code>fetch_data</code> 协程虽然有不同的延迟，但它们会并发执行。当一个协程 <code>await asyncio.sleep()</code> 时，事件循环会切换到另一个协程，而不是等待当前协程的睡眠时间结束。最终总耗时将取决于最长的那个延迟（约3秒），而不是所有延迟之和（2+1+3=6秒）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="内存管理与垃圾回收">
  内存管理与垃圾回收
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e4%b8%8e%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6">#</a>
</h4>
<ul>
<li>
<p><strong>Python的内存管理机制。</strong>
Python的内存管理是由其<strong>私有堆空间</strong>（Private Heap Space）来完成的。所有Python对象和数据结构都存储在这个私有堆中。解释器负责管理这个堆，程序员通常不需要手动管理内存。</p>
<p>Python内存管理机制主要包括：</p>
<ol>
<li><strong>引用计数（Reference Counting）</strong>：这是Python最主要的垃圾回收机制。</li>
<li><strong>垃圾回收器（Garbage Collector）</strong>：用于处理循环引用（Reference Cycles）。</li>
<li><strong>内存池（Memory Pool）</strong>：对小对象进行优化分配。</li>
</ol>
</li>
<li>
<p><strong>引用计数（reference counting）和循环引用（circular references）。</strong></p>
<ul>
<li>
<p><strong>引用计数（Reference Counting）</strong>：</p>
<ul>
<li><strong>原理</strong>：每个Python对象都维护一个引用计数器，记录有多少个变量或对象引用了它。</li>
<li><strong>工作方式</strong>：
<ul>
<li>当一个对象被引用时（例如，将其赋值给一个变量，或将其作为元素添加到列表中），其引用计数器会<strong>增加</strong>。</li>
<li>当一个对象的引用不再存在时（例如，变量超出作用域，或从列表中删除），其引用计数器会<strong>减少</strong>。</li>
<li>当一个对象的引用计数器降为<strong>零</strong>时，说明没有任何变量再引用它，该对象就会被Python解释器<strong>立即回收</strong>其占用的内存。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li><strong>实时性</strong>：内存可以立即被释放，减少内存碎片，提高内存利用率。</li>
<li><strong>简单高效</strong>：对于大多数情况非常有效。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>无法解决循环引用问题</strong>。</li>
<li>每次引用计数变化都需要额外操作，有轻微开销。</li>
</ul>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>print(sys<span style="color:#f92672">.</span>getrefcount(a)) <span style="color:#75715e"># 2 (a本身引用一次，getrefcount函数内部引用一次)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b <span style="color:#f92672">=</span> a <span style="color:#75715e"># b也引用了列表</span>
</span></span><span style="display:flex;"><span>print(sys<span style="color:#f92672">.</span>getrefcount(a)) <span style="color:#75715e"># 3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">del</span> b <span style="color:#75715e"># b不再引用列表</span>
</span></span><span style="display:flex;"><span>print(sys<span style="color:#f92672">.</span>getrefcount(a)) <span style="color:#75715e"># 2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 列表引用计数降为1 (如果不是被getrefcount引用，就是1)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 如果不再有任何引用，列表就会被回收</span>
</span></span></code></pre></div></li>
<li>
<p><strong>循环引用（Circular References）</strong>：</p>
<ul>
<li><strong>问题所在</strong>：当两个或多个对象相互引用，形成一个引用闭环时，即使外部已经没有对这些对象的引用，它们的引用计数永远不会降为零。因此，引用计数机制无法回收这部分内存，导致内存泄漏。</li>
<li><strong>例子</strong>：</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, value):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>value <span style="color:#f92672">=</span> value
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span> <span style="color:#75715e"># 指向下一个Node</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>node1 <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>node2 <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>node1<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> node2 <span style="color:#75715e"># node1引用node2</span>
</span></span><span style="display:flex;"><span>node2<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> node1 <span style="color:#75715e"># node2引用node1，形成循环引用</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 此时，即使 del node1 和 del node2</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># node1 和 node2 的引用计数仍然不为零 (因为它们内部相互引用)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 它们将不会被引用计数机制回收</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">del</span> node1
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">del</span> node2
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 内存仍被占用</span>
</span></span></code></pre></div></li>
<li>
<p><strong>Python如何解决循环引用</strong>：</p>
<ul>
<li>为了解决循环引用导致的内存泄漏，Python引入了<strong>分代垃圾回收器（Generational Garbage Collector）</strong>。</li>
<li><strong>垃圾回收器的工作方式</strong>：
<ul>
<li>它会定期运行，检测那些引用计数不为零但实际上已不可达（从根对象无法访问）的循环引用对象。</li>
<li>它将对象分为三代：新创建的对象属于第0代。如果它们在垃圾回收周期中存活下来，就会升级到第1代；再存活就升级到第2代。</li>
<li>垃圾回收器在第0代运行最频繁，在第1代和第2代运行频率逐渐降低，因为通常认为越老的对象越稳定，越不可能成为垃圾。</li>
<li>当垃圾回收器识别出循环引用时，它会打破这些循环，使对象的引用计数降为零，从而允许引用计数机制回收内存。</li>
</ul>
</li>
<li>可以使用 <code>gc</code> 模块来手动控制或检查垃圾回收器。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> gc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gc<span style="color:#f92672">.</span>collect() <span style="color:#75715e"># 手动触发垃圾回收</span>
</span></span><span style="display:flex;"><span>gc<span style="color:#f92672">.</span>set_threshold(<span style="color:#ae81ff">700</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>) <span style="color:#75715e"># 设置垃圾回收的阈值 (对象分配数、第0代存活数、第1代存活数)</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="3-python库与框架答案">
  3. Python库与框架答案
  <a class="anchor" href="#3-python%e5%ba%93%e4%b8%8e%e6%a1%86%e6%9e%b6%e7%ad%94%e6%a1%88">#</a>
</h3>
<hr>
<h4 id="常用标准库">
  常用标准库
  <a class="anchor" href="#%e5%b8%b8%e7%94%a8%e6%a0%87%e5%87%86%e5%ba%93">#</a>
</h4>
<ul>
<li><strong><code>os</code>、<code>sys</code>、<code>datetime</code>、<code>json</code>、<code>re</code>、<code>collections</code>等。</strong>
<ul>
<li>
<p><strong><code>os</code> 模块</strong>:</p>
<ul>
<li><strong>作用</strong>: 提供与操作系统交互的功能。</li>
<li><strong>常见用法</strong>:
<ul>
<li>文件和目录操作：<code>os.path.join()</code>, <code>os.listdir()</code>, <code>os.mkdir()</code>, <code>os.remove()</code>, <code>os.rmdir()</code>, <code>os.rename()</code>。</li>
<li>环境变量：<code>os.environ</code>。</li>
<li>执行系统命令：<code>os.system()</code>, <code>os.popen()</code>。</li>
<li>获取当前工作目录：<code>os.getcwd()</code>。</li>
<li>改变当前工作目录：<code>os.chdir()</code>。</li>
</ul>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(os.getcwd())</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># os.mkdir(&#34;test_dir&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(os.listdir(&#34;.&#34;))</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># os.rmdir(&#34;test_dir&#34;)</span>
</span></span></code></pre></div></li>
<li>
<p><strong><code>sys</code> 模块</strong>:</p>
<ul>
<li><strong>作用</strong>: 提供对Python解释器及其环境的访问。</li>
<li><strong>常见用法</strong>:
<ul>
<li>命令行参数：<code>sys.argv</code>。</li>
<li>退出程序：<code>sys.exit()</code>。</li>
<li>获取Python版本信息：<code>sys.version</code>。</li>
<li>模块搜索路径：<code>sys.path</code>。</li>
<li>标准输入/输出/错误流：<code>sys.stdin</code>, <code>sys.stdout</code>, <code>sys.stderr</code>。</li>
</ul>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(sys.argv) # 命令行参数列表</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(sys.version)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(sys.path)</span>
</span></span></code></pre></div></li>
<li>
<p><strong><code>datetime</code> 模块</strong>:</p>
<ul>
<li><strong>作用</strong>: 用于处理日期和时间。</li>
<li><strong>常见用法</strong>:
<ul>
<li>获取当前日期和时间：<code>datetime.datetime.now()</code>。</li>
<li>创建日期/时间对象：<code>datetime.date()</code>, <code>datetime.time()</code>, <code>datetime.datetime()</code>。</li>
<li>时间间隔：<code>datetime.timedelta()</code>。</li>
<li>格式化日期时间：<code>strftime()</code> (格式化为字符串), <code>strptime()</code> (从字符串解析)。</li>
</ul>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> datetime
</span></span><span style="display:flex;"><span>now <span style="color:#f92672">=</span> datetime<span style="color:#f92672">.</span>datetime<span style="color:#f92672">.</span>now()
</span></span><span style="display:flex;"><span>print(now)
</span></span><span style="display:flex;"><span>print(now<span style="color:#f92672">.</span>strftime(<span style="color:#e6db74">&#34;%Y-%m-</span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> %H:%M:%S&#34;</span>))
</span></span><span style="display:flex;"><span>future_date <span style="color:#f92672">=</span> now <span style="color:#f92672">+</span> datetime<span style="color:#f92672">.</span>timedelta(days<span style="color:#f92672">=</span><span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>print(future_date)
</span></span></code></pre></div></li>
<li>
<p><strong><code>json</code> 模块</strong>:</p>
<ul>
<li><strong>作用</strong>: 用于处理JSON（JavaScript Object Notation）数据，实现Python对象与JSON字符串之间的转换。</li>
<li><strong>常见用法</strong>:
<ul>
<li>Python对象转JSON字符串：<code>json.dumps()</code>。</li>
<li>JSON字符串转Python对象：<code>json.loads()</code>。</li>
<li>Python对象写入JSON文件：<code>json.dump()</code>。</li>
<li>从JSON文件读取Python对象：<code>json.load()</code>。</li>
</ul>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> json
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;name&#39;</span>: <span style="color:#e6db74">&#39;Alice&#39;</span>, <span style="color:#e6db74">&#39;age&#39;</span>: <span style="color:#ae81ff">30</span>, <span style="color:#e6db74">&#39;isStudent&#39;</span>: <span style="color:#66d9ef">False</span>}
</span></span><span style="display:flex;"><span>json_string <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>dumps(data, indent<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>) <span style="color:#75715e"># indent用于美化输出</span>
</span></span><span style="display:flex;"><span>print(json_string)
</span></span><span style="display:flex;"><span>parsed_data <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(json_string)
</span></span><span style="display:flex;"><span>print(parsed_data[<span style="color:#e6db74">&#39;name&#39;</span>])
</span></span></code></pre></div></li>
<li>
<p><strong><code>re</code> 模块</strong>:</p>
<ul>
<li><strong>作用</strong>: 提供正则表达式操作，用于字符串的模式匹配和查找、替换等。</li>
<li><strong>常见用法</strong>:
<ul>
<li>匹配：<code>re.match()</code> (从开头匹配), <code>re.search()</code> (扫描整个字符串匹配)。</li>
<li>查找所有匹配项：<code>re.findall()</code>。</li>
<li>替换：<code>re.sub()</code>。</li>
<li>分割：<code>re.split()</code>。</li>
<li>编译正则表达式：<code>re.compile()</code> (提高重复使用的效率)。</li>
</ul>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> re
</span></span><span style="display:flex;"><span>text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;My phone number is 123-456-7890.&#34;</span>
</span></span><span style="display:flex;"><span>pattern <span style="color:#f92672">=</span> <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;\d</span><span style="color:#e6db74">{3}</span><span style="color:#e6db74">-\d</span><span style="color:#e6db74">{3}</span><span style="color:#e6db74">-\d</span><span style="color:#e6db74">{4}</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># 匹配电话号码</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">match</span> <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>search(pattern, text)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#66d9ef">match</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Found phone number: </span><span style="color:#e6db74">{</span>match<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">0</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div></li>
<li>
<p><strong><code>collections</code> 模块</strong>:</p>
<ul>
<li><strong>作用</strong>: 提供了对内置数据类型（如列表、字典、元组）的增强和替代。</li>
<li><strong>常见用法</strong>:
<ul>
<li><strong><code>defaultdict</code></strong>: 字典的子类，当访问一个不存在的键时，会自动生成一个默认值，而不是抛出<code>KeyError</code>。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict
</span></span><span style="display:flex;"><span>s <span style="color:#f92672">=</span> [(<span style="color:#e6db74">&#39;yellow&#39;</span>, <span style="color:#ae81ff">1</span>), (<span style="color:#e6db74">&#39;blue&#39;</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#e6db74">&#39;yellow&#39;</span>, <span style="color:#ae81ff">3</span>), (<span style="color:#e6db74">&#39;blue&#39;</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#e6db74">&#39;red&#39;</span>, <span style="color:#ae81ff">1</span>)]
</span></span><span style="display:flex;"><span>d <span style="color:#f92672">=</span> defaultdict(list) <span style="color:#75715e"># 默认值是空列表</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> s:
</span></span><span style="display:flex;"><span>    d[k]<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>print(d) <span style="color:#75715e"># defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;yellow&#39;: [1, 3], &#39;blue&#39;: [2, 4], &#39;red&#39;: [1]})</span>
</span></span></code></pre></div></li>
<li><strong><code>Counter</code></strong>: 字典的子类，用于计数可哈希对象。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> Counter
</span></span><span style="display:flex;"><span>words <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;apple&#39;</span>, <span style="color:#e6db74">&#39;banana&#39;</span>, <span style="color:#e6db74">&#39;apple&#39;</span>, <span style="color:#e6db74">&#39;orange&#39;</span>, <span style="color:#e6db74">&#39;banana&#39;</span>, <span style="color:#e6db74">&#39;apple&#39;</span>]
</span></span><span style="display:flex;"><span>word_counts <span style="color:#f92672">=</span> Counter(words)
</span></span><span style="display:flex;"><span>print(word_counts) <span style="color:#75715e"># Counter({&#39;apple&#39;: 3, &#39;banana&#39;: 2, &#39;orange&#39;: 1})</span>
</span></span><span style="display:flex;"><span>print(word_counts<span style="color:#f92672">.</span>most_common(<span style="color:#ae81ff">2</span>)) <span style="color:#75715e"># [(&#39;apple&#39;, 3), (&#39;banana&#39;, 2)]</span>
</span></span></code></pre></div></li>
<li><strong><code>namedtuple</code></strong>: 创建带有命名字段的元组子类，提高代码可读性。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> namedtuple
</span></span><span style="display:flex;"><span>Point <span style="color:#f92672">=</span> namedtuple(<span style="color:#e6db74">&#39;Point&#39;</span>, [<span style="color:#e6db74">&#39;x&#39;</span>, <span style="color:#e6db74">&#39;y&#39;</span>])
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> Point(<span style="color:#ae81ff">11</span>, y<span style="color:#f92672">=</span><span style="color:#ae81ff">22</span>)
</span></span><span style="display:flex;"><span>print(p<span style="color:#f92672">.</span>x, p<span style="color:#f92672">.</span>y) <span style="color:#75715e"># 11 22</span>
</span></span></code></pre></div></li>
<li><strong><code>deque</code> (双端队列)</strong>: 列表的线程安全替代品，支持从两端快速添加和删除元素。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span>d <span style="color:#f92672">=</span> deque([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>])
</span></span><span style="display:flex;"><span>d<span style="color:#f92672">.</span>appendleft(<span style="color:#ae81ff">0</span>) <span style="color:#75715e"># [0, 1, 2, 3]</span>
</span></span><span style="display:flex;"><span>d<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">4</span>)     <span style="color:#75715e"># [0, 1, 2, 3, 4]</span>
</span></span><span style="display:flex;"><span>d<span style="color:#f92672">.</span>popleft()     <span style="color:#75715e"># 0, deque([1, 2, 3, 4])</span>
</span></span><span style="display:flex;"><span>d<span style="color:#f92672">.</span>pop()         <span style="color:#75715e"># 4, deque([1, 2, 3])</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="web开发">
  Web开发
  <a class="anchor" href="#web%e5%bc%80%e5%8f%91">#</a>
</h4>
<ul>
<li><strong>如果你是Web开发岗，可能会问及Django、Flask等框架的使用经验，以及RESTful API、ORM等概念。</strong>
<ul>
<li>
<p><strong>Django</strong>:</p>
<ul>
<li><strong>特点</strong>: “大而全”的Web框架，提供了ORM、管理后台、模板系统、表单处理、会话管理等开箱即用的功能。</li>
<li><strong>理念</strong>: “Batteries included”（内置电池），适合快速开发大型、复杂的Web应用。</li>
<li><strong>MVC/MTV模式</strong>: Django遵循MTV（Model-Template-View）模式，与传统的MVC类似。
<ul>
<li><strong>Model</strong>: 处理数据逻辑，通常通过ORM与数据库交互。</li>
<li><strong>Template</strong>: 处理用户界面，负责渲染HTML。</li>
<li><strong>View</strong>: 处理业务逻辑，接收请求，调用Model，选择Template并返回响应。</li>
</ul>
</li>
<li><strong>ORM (Object-Relational Mapping)</strong>: Django内置强大的ORM，允许开发者使用Python对象来操作数据库，而无需编写SQL语句。</li>
<li><strong>URL路由</strong>: 通过<code>urls.py</code>文件定义URL模式到视图函数的映射。</li>
<li><strong>管理后台</strong>: 自动生成强大的管理界面，方便管理数据库数据。</li>
</ul>
</li>
<li>
<p><strong>Flask</strong>:</p>
<ul>
<li><strong>特点</strong>: “小而精”的微框架，核心功能简洁，高度可扩展。</li>
<li><strong>理念</strong>: “Do one thing and do it well”，不强制使用特定组件，允许开发者自由选择数据库、模板引擎等。</li>
<li><strong>核心组件</strong>: 路由、请求/响应对象、模板渲染（Jinja2）。</li>
<li><strong>扩展</strong>: 通过各种社区开发的扩展（如Flask-SQLAlchemy, Flask-Login, Flask-RESTful）来添加功能。</li>
<li><strong>适用场景</strong>: 小型项目、API服务、快速原型开发。</li>
</ul>
</li>
<li>
<p><strong>RESTful API</strong>:</p>
<ul>
<li><strong>概念</strong>: 一种设计网络应用程序接口（API）的架构风格，基于HTTP协议。它将所有事物都视为资源，并通过HTTP方法（GET, POST, PUT, DELETE等）对资源进行操作。</li>
<li><strong>核心原则</strong>:
<ul>
<li><strong>资源（Resource）</strong>: API中的每个URI代表一种资源（如<code>/users</code>, <code>/products/123</code>）。</li>
<li><strong>统一接口（Uniform Interface）</strong>: 使用标准的HTTP方法（GET获取、POST创建、PUT/PATCH更新、DELETE删除）来操作资源。</li>
<li><strong>无状态（Stateless）</strong>: 服务器不保存客户端的会话信息。每次请求都必须包含所有必要的信息。</li>
<li><strong>可缓存（Cacheable）</strong>: 客户端可以缓存响应，提高性能。</li>
<li><strong>分层系统（Layered System）</strong>: 客户端无需知道它连接的是最终服务器还是中间代理。</li>
</ul>
</li>
<li><strong>优点</strong>: 简单、易于理解和实现，跨平台兼容性好，适合前后端分离开发。</li>
</ul>
</li>
<li>
<p><strong>ORM (Object-Relational Mapping)</strong>:</p>
<ul>
<li><strong>概念</strong>: 一种编程技术，用于在面向对象编程语言（如Python）和关系型数据库之间建立映射。它允许开发者使用面向对象的方式（操作Python对象）来操作数据库，而无需直接编写SQL语句。</li>
<li><strong>工作原理</strong>: ORM库（如SQLAlchemy, Django ORM）将数据库表映射为Python类，将表的行映射为类的实例（对象），将表的字段映射为对象的属性。</li>
<li><strong>优点</strong>:
<ul>
<li><strong>简化数据库操作</strong>: 开发者无需学习复杂的SQL语法，只需使用Python代码。</li>
<li><strong>提高开发效率</strong>: 减少了编写和维护SQL的工作量。</li>
<li><strong>数据库无关性</strong>: 许多ORM支持多种数据库后端，切换数据库时代码改动较小。</li>
<li><strong>安全性</strong>: 通常内置SQL注入防护。</li>
</ul>
</li>
<li><strong>缺点</strong>:
<ul>
<li><strong>性能开销</strong>: 对于非常复杂的查询，ORM生成的SQL可能不如手动优化的SQL高效。</li>
<li><strong>学习曲线</strong>: 掌握ORM的复杂特性也需要时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据科学机器学习">
  数据科学/机器学习
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e7%a7%91%e5%ad%a6%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0">#</a>
</h4>
<ul>
<li><strong>对于数据科学岗，会考察NumPy、Pandas、Matplotlib、Scikit-learn等库。</strong>
<ul>
<li>
<p><strong>NumPy (Numerical Python)</strong>:</p>
<ul>
<li><strong>作用</strong>: Python中用于科学计算的核心库，提供了高性能的多维数组对象（<code>ndarray</code>）以及用于处理这些数组的工具。</li>
<li><strong>特点</strong>:
<ul>
<li><strong><code>ndarray</code></strong>: 快速、高效的数组操作，比Python内置列表在处理大量数值数据时性能优越。</li>
<li><strong>向量化操作</strong>: 支持对整个数组进行数学运算，无需显式循环，大大提高计算速度。</li>
<li><strong>广播（Broadcasting）</strong>: 允许不同形状的数组进行算术运算。</li>
</ul>
</li>
<li><strong>常见用法</strong>: 数组创建、索引、切片、数学运算、线性代数、傅里叶变换等。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>arr <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>]])
</span></span><span style="display:flex;"><span>print(arr <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) <span style="color:#75715e"># 向量化操作</span>
</span></span><span style="display:flex;"><span>print(arr<span style="color:#f92672">.</span>shape) <span style="color:#75715e"># (2, 3)</span>
</span></span></code></pre></div></li>
<li>
<p><strong>Pandas</strong>:</p>
<ul>
<li><strong>作用</strong>: 基于NumPy构建的数据分析库，提供了高性能、易于使用的数据结构和数据分析工具。</li>
<li><strong>核心数据结构</strong>:
<ul>
<li><strong><code>Series</code></strong>: 一维带标签数组，可以看作是带索引的NumPy数组。</li>
<li><strong><code>DataFrame</code></strong>: 二维带标签数据结构，可以看作是表格，每列可以是不同的数据类型，类似于电子表格或SQL表。</li>
</ul>
</li>
<li><strong>常见用法</strong>: 数据加载（CSV, Excel, SQL）、数据清洗、数据转换、数据聚合、数据合并、时间序列分析等。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> pandas <span style="color:#66d9ef">as</span> pd
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;Name&#39;</span>: [<span style="color:#e6db74">&#39;Alice&#39;</span>, <span style="color:#e6db74">&#39;Bob&#39;</span>, <span style="color:#e6db74">&#39;Charlie&#39;</span>], <span style="color:#e6db74">&#39;Age&#39;</span>: [<span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">35</span>]}
</span></span><span style="display:flex;"><span>df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(data)
</span></span><span style="display:flex;"><span>print(df)
</span></span><span style="display:flex;"><span>print(df[df[<span style="color:#e6db74">&#39;Age&#39;</span>] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">28</span>]) <span style="color:#75715e"># 数据筛选</span>
</span></span></code></pre></div></li>
<li>
<p><strong>Matplotlib</strong>:</p>
<ul>
<li><strong>作用</strong>: Python中最流行的绘图库，用于创建静态、动态和交互式的可视化图表。</li>
<li><strong>特点</strong>: 功能强大、高度可定制，支持各种图表类型（折线图、散点图、柱状图、饼图等）。</li>
<li><strong>常见用法</strong>: <code>pyplot</code> 模块提供类似MATLAB的绘图接口。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>y <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(x, y)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;X-axis&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Y-axis&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Simple Plot&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div></li>
<li>
<p><strong>Scikit-learn</strong>:</p>
<ul>
<li><strong>作用</strong>: Python中最全面、最流行的机器学习库，提供了各种监督学习和无监督学习算法，以及模型选择、预处理等工具。</li>
<li><strong>特点</strong>: 统一的API设计，易于使用和学习。</li>
<li><strong>常见算法/功能</strong>:
<ul>
<li><strong>分类</strong>: 逻辑回归、支持向量机（SVM）、决策树、随机森林、K近邻（KNN）。</li>
<li><strong>回归</strong>: 线性回归、岭回归、Lasso回归。</li>
<li><strong>聚类</strong>: K-Means、DBSCAN。</li>
<li><strong>降维</strong>: PCA。</li>
<li><strong>模型选择</strong>: 交叉验证、网格搜索。</li>
<li><strong>预处理</strong>: 特征缩放（标准化、归一化）、缺失值处理。</li>
</ul>
</li>
<li><strong>工作流程</strong>: 通常包括数据预处理、模型训练、模型评估、模型预测。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.linear_model <span style="color:#f92672">import</span> LinearRegression
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.model_selection <span style="color:#f92672">import</span> train_test_split
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.metrics <span style="color:#f92672">import</span> mean_squared_error
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 示例数据</span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">4</span>], [<span style="color:#ae81ff">5</span>]])
</span></span><span style="display:flex;"><span>y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 划分训练集和测试集</span>
</span></span><span style="display:flex;"><span>X_train, X_test, y_train, y_test <span style="color:#f92672">=</span> train_test_split(X, y, test_size<span style="color:#f92672">=</span><span style="color:#ae81ff">0.2</span>, random_state<span style="color:#f92672">=</span><span style="color:#ae81ff">42</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 创建并训练模型</span>
</span></span><span style="display:flex;"><span>model <span style="color:#f92672">=</span> LinearRegression()
</span></span><span style="display:flex;"><span>model<span style="color:#f92672">.</span>fit(X_train, y_train)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 预测</span>
</span></span><span style="display:flex;"><span>y_pred <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>predict(X_test)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Predicted: </span><span style="color:#e6db74">{</span>y_pred<span style="color:#e6db74">}</span><span style="color:#e6db74">, Actual: </span><span style="color:#e6db74">{</span>y_test<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;MSE: </span><span style="color:#e6db74">{</span>mean_squared_error(y_test, y_pred)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="数据库">
  数据库
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93">#</a>
</h4>
<ul>
<li>
<p><strong>如何使用Python连接数据库（例如：<code>sqlite3</code>、<code>psycopg2</code>、<code>SQLAlchemy</code>）？</strong>
Python连接数据库通常遵循<strong>DB-API 2.0</strong>（Python Database API Specification v2.0）标准，这使得不同数据库的连接方式具有相似的接口。</p>
<ol>
<li>
<p><strong><code>sqlite3</code> (内置)</strong>:</p>
<ul>
<li><strong>特点</strong>: Python标准库的一部分，无需额外安装。它是一个轻量级的、文件型的数据库，适合小型项目或作为应用程序的本地存储。</li>
<li><strong>连接步骤</strong>:
<ol>
<li>导入 <code>sqlite3</code> 模块。</li>
<li>使用 <code>sqlite3.connect()</code> 连接到数据库文件（如果文件不存在，会自动创建）。</li>
<li>创建游标对象 <code>cursor()</code>。</li>
<li>执行SQL语句 <code>execute()</code>。</li>
<li>提交更改 <code>commit()</code>。</li>
<li>关闭连接 <code>close()</code>。</li>
</ol>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sqlite3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>conn <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span> <span style="color:#75715e"># 初始化连接为None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>    conn <span style="color:#f92672">=</span> sqlite3<span style="color:#f92672">.</span>connect(<span style="color:#e6db74">&#39;example.db&#39;</span>) <span style="color:#75715e"># 连接到数据库文件</span>
</span></span><span style="display:flex;"><span>    cursor <span style="color:#f92672">=</span> conn<span style="color:#f92672">.</span>cursor()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 创建表</span>
</span></span><span style="display:flex;"><span>    cursor<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        CREATE TABLE IF NOT EXISTS users (
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            id INTEGER PRIMARY KEY,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            name TEXT NOT NULL,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            age INTEGER
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        )
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 插入数据</span>
</span></span><span style="display:flex;"><span>    cursor<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#34;INSERT INTO users (name, age) VALUES (?, ?)&#34;</span>, (<span style="color:#e6db74">&#34;Alice&#34;</span>, <span style="color:#ae81ff">30</span>))
</span></span><span style="display:flex;"><span>    cursor<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#34;INSERT INTO users (name, age) VALUES (?, ?)&#34;</span>, (<span style="color:#e6db74">&#34;Bob&#34;</span>, <span style="color:#ae81ff">25</span>))
</span></span><span style="display:flex;"><span>    conn<span style="color:#f92672">.</span>commit() <span style="color:#75715e"># 提交更改</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 查询数据</span>
</span></span><span style="display:flex;"><span>    cursor<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#34;SELECT * FROM users WHERE age &gt; ?&#34;</span>, (<span style="color:#ae81ff">28</span>,))
</span></span><span style="display:flex;"><span>    rows <span style="color:#f92672">=</span> cursor<span style="color:#f92672">.</span>fetchall()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> rows:
</span></span><span style="display:flex;"><span>        print(row) <span style="color:#75715e"># (1, &#39;Alice&#39;, 30)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">except</span> sqlite3<span style="color:#f92672">.</span>Error <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Database error: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">finally</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> conn:
</span></span><span style="display:flex;"><span>        conn<span style="color:#f92672">.</span>close() <span style="color:#75715e"># 关闭连接</span>
</span></span></code></pre></div></li>
<li>
<p><strong><code>psycopg2</code> (PostgreSQL)</strong>:</p>
<ul>
<li><strong>特点</strong>: 用于连接PostgreSQL数据库的流行适配器。需要通过<code>pip install psycopg2-binary</code>安装。</li>
<li><strong>连接步骤</strong>: 类似<code>sqlite3</code>，但连接字符串和异常类型不同。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> psycopg2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 假设PostgreSQL运行在本地，用户名为postgres，无密码，数据库名为mydatabase</span>
</span></span><span style="display:flex;"><span>db_config <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;host&#34;</span>: <span style="color:#e6db74">&#34;localhost&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;database&#34;</span>: <span style="color:#e6db74">&#34;mydatabase&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;user&#34;</span>: <span style="color:#e6db74">&#34;postgres&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;password&#34;</span>: <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>conn <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>    conn <span style="color:#f92672">=</span> psycopg2<span style="color:#f92672">.</span>connect(<span style="color:#f92672">**</span>db_config)
</span></span><span style="display:flex;"><span>    cursor <span style="color:#f92672">=</span> conn<span style="color:#f92672">.</span>cursor()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 创建表 (如果不存在)</span>
</span></span><span style="display:flex;"><span>    cursor<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        CREATE TABLE IF NOT EXISTS products (
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            id SERIAL PRIMARY KEY,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            name VARCHAR(255) NOT NULL,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            price DECIMAL(10, 2)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        )
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>    conn<span style="color:#f92672">.</span>commit()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 插入数据</span>
</span></span><span style="display:flex;"><span>    cursor<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#34;INSERT INTO products (name, price) VALUES (</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">)&#34;</span>, (<span style="color:#e6db74">&#34;Laptop&#34;</span>, <span style="color:#ae81ff">1200.50</span>))
</span></span><span style="display:flex;"><span>    conn<span style="color:#f92672">.</span>commit()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 查询数据</span>
</span></span><span style="display:flex;"><span>    cursor<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#34;SELECT * FROM products&#34;</span>)
</span></span><span style="display:flex;"><span>    rows <span style="color:#f92672">=</span> cursor<span style="color:#f92672">.</span>fetchall()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> rows:
</span></span><span style="display:flex;"><span>        print(row)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">except</span> psycopg2<span style="color:#f92672">.</span>Error <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;PostgreSQL error: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">finally</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> conn:
</span></span><span style="display:flex;"><span>        conn<span style="color:#f92672">.</span>close()
</span></span></code></pre></div></li>
<li>
<p><strong><code>SQLAlchemy</code> (ORM)</strong>:</p>
<ul>
<li><strong>特点</strong>: Python中最强大和灵活的ORM和数据库工具包。它提供了两种主要的使用方式：
<ul>
<li><strong>ORM (Object Relational Mapper)</strong>：将Python类映射到数据库表，通过操作Python对象来操作数据库。</li>
<li><strong>Core (SQL Expression Language)</strong>：允许你以Pythonic的方式构建SQL表达式，但仍然是基于SQL的。</li>
</ul>
</li>
<li><strong>优点</strong>: 抽象了底层数据库的差异，提供了更高级别的抽象，支持多种数据库，功能强大。</li>
<li><strong>需要安装</strong>: <code>pip install sqlalchemy</code>，以及对应数据库的驱动（如<code>psycopg2</code> for PostgreSQL, <code>mysqlclient</code> for MySQL）。</li>
<li><strong>ORM模式示例</strong>:</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> sqlalchemy <span style="color:#f92672">import</span> create_engine, Column, Integer, String, Float
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sqlalchemy.orm <span style="color:#f92672">import</span> sessionmaker
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sqlalchemy.ext.declarative <span style="color:#f92672">import</span> declarative_base
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. 定义数据库连接</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用SQLite内存数据库作为示例</span>
</span></span><span style="display:flex;"><span>engine <span style="color:#f92672">=</span> create_engine(<span style="color:#e6db74">&#39;sqlite:///:memory:&#39;</span>) <span style="color:#75715e"># 或 &#39;postgresql://user:pass@host:port/dbname&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 声明基类</span>
</span></span><span style="display:flex;"><span>Base <span style="color:#f92672">=</span> declarative_base()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. 定义模型 (映射到数据库表)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">User</span>(Base):
</span></span><span style="display:flex;"><span>    __tablename__ <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;users&#39;</span>
</span></span><span style="display:flex;"><span>    id <span style="color:#f92672">=</span> Column(Integer, primary_key<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> Column(String)
</span></span><span style="display:flex;"><span>    email <span style="color:#f92672">=</span> Column(String)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__repr__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;&lt;User(id=</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>id<span style="color:#e6db74">}</span><span style="color:#e6db74">, name=&#39;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;, email=&#39;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>email<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;)&gt;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. 创建表</span>
</span></span><span style="display:flex;"><span>Base<span style="color:#f92672">.</span>metadata<span style="color:#f92672">.</span>create_all(engine)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. 创建会话</span>
</span></span><span style="display:flex;"><span>Session <span style="color:#f92672">=</span> sessionmaker(bind<span style="color:#f92672">=</span>engine)
</span></span><span style="display:flex;"><span>session <span style="color:#f92672">=</span> Session()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 6. 添加数据</span>
</span></span><span style="display:flex;"><span>user1 <span style="color:#f92672">=</span> User(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Alice&#39;</span>, email<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;alice@example.com&#39;</span>)
</span></span><span style="display:flex;"><span>user2 <span style="color:#f92672">=</span> User(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Bob&#39;</span>, email<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;bob@example.com&#39;</span>)
</span></span><span style="display:flex;"><span>session<span style="color:#f92672">.</span>add_all([user1, user2])
</span></span><span style="display:flex;"><span>session<span style="color:#f92672">.</span>commit() <span style="color:#75715e"># 提交事务</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 7. 查询数据</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查询所有用户</span>
</span></span><span style="display:flex;"><span>all_users <span style="color:#f92672">=</span> session<span style="color:#f92672">.</span>query(User)<span style="color:#f92672">.</span>all()
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;All users:&#34;</span>, all_users)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 按条件查询</span>
</span></span><span style="display:flex;"><span>alice <span style="color:#f92672">=</span> session<span style="color:#f92672">.</span>query(User)<span style="color:#f92672">.</span>filter_by(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Alice&#39;</span>)<span style="color:#f92672">.</span>first()
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Alice:&#34;</span>, alice)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 8. 更新数据</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> alice:
</span></span><span style="display:flex;"><span>    alice<span style="color:#f92672">.</span>email <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;alice.new@example.com&#39;</span>
</span></span><span style="display:flex;"><span>    session<span style="color:#f92672">.</span>commit()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Updated Alice:&#34;</span>, session<span style="color:#f92672">.</span>query(User)<span style="color:#f92672">.</span>filter_by(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Alice&#39;</span>)<span style="color:#f92672">.</span>first())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 9. 删除数据</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># session.delete(user2)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># session.commit()</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(&#34;Users after deletion:&#34;, session.query(User).all())</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 10. 关闭会话</span>
</span></span><span style="display:flex;"><span>session<span style="color:#f92672">.</span>close()
</span></span></code></pre></div></li>
</ol>
</li>
</ul>
<h3 id="4-算法与数据结构答案">
  4. 算法与数据结构答案
  <a class="anchor" href="#4-%e7%ae%97%e6%b3%95%e4%b8%8e%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%ad%94%e6%a1%88">#</a>
</h3>
<hr>
<h4 id="常见数据结构">
  常见数据结构
  <a class="anchor" href="#%e5%b8%b8%e8%a7%81%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h4>
<ul>
<li><strong>数组（列表）、链表、栈、队列、树、图、哈希表（字典）等。</strong>
<ul>
<li>
<p><strong>数组（Python中的列表 <code>list</code>）</strong>:</p>
<ul>
<li><strong>特点</strong>: 元素在内存中是<strong>连续存储</strong>的，通过索引直接访问，访问速度快。Python的列表是动态数组，可以自动扩容/缩容。</li>
<li><strong>操作</strong>:
<ul>
<li><strong>查找（按索引）</strong>: O(1)</li>
<li><strong>插入/删除（末尾）</strong>: O(1) (均摊)</li>
<li><strong>插入/删除（开头/中间）</strong>: O(N) (需要移动后续元素)</li>
</ul>
</li>
<li><strong>适用场景</strong>: 需要快速随机访问元素，元素数量变化不频繁。</li>
</ul>
</li>
<li>
<p><strong>链表（Python中无内置，需自定义或使用第三方库）</strong>:</p>
<ul>
<li><strong>特点</strong>: 元素在内存中<strong>不连续存储</strong>，每个元素（节点）包含数据和指向下一个（或上一个）节点的指针。</li>
<li><strong>操作</strong>:
<ul>
<li><strong>查找（按值）</strong>: O(N)</li>
<li><strong>插入/删除（开头/中间）</strong>: O(1) (只需修改指针)</li>
<li><strong>访问（按索引）</strong>: O(N)</li>
</ul>
</li>
<li><strong>适用场景</strong>: 频繁进行插入和删除操作，对随机访问性能要求不高。</li>
</ul>
</li>
<li>
<p><strong>栈（Stack）</strong>:</p>
<ul>
<li><strong>特点</strong>: <strong>LIFO (Last In, First Out)</strong>，后进先出。只允许在栈顶进行插入（push）和删除（pop）操作。</li>
<li><strong>Python实现</strong>: 通常使用列表的 <code>append()</code> 和 <code>pop()</code> 方法模拟。</li>
<li><strong>适用场景</strong>: 函数调用栈、表达式求值、浏览器历史记录（后退）、撤销/重做功能。</li>
</ul>
</li>
<li>
<p><strong>队列（Queue）</strong>:</p>
<ul>
<li><strong>特点</strong>: <strong>FIFO (First In, First Out)</strong>，先进先出。只允许在队尾插入（enqueue）和队头删除（dequeue）操作。</li>
<li><strong>Python实现</strong>: 通常使用 <code>collections.deque</code> 或 <code>queue</code> 模块。</li>
<li><strong>适用场景</strong>: 任务调度、消息队列、广度优先搜索（BFS）。</li>
</ul>
</li>
<li>
<p><strong>树（Tree）</strong>:</p>
<ul>
<li><strong>特点</strong>: 非线性数据结构，由节点和边组成，有一个根节点，每个节点可以有零个或多个子节点。</li>
<li><strong>常见类型</strong>: 二叉树、二叉搜索树（BST）、平衡二叉树（AVL、红黑树）、B树等。</li>
<li><strong>操作</strong>: 插入、删除、查找、遍历（前序、中序、后序）。</li>
<li><strong>适用场景</strong>: 文件系统、数据库索引、组织层次结构、XML/HTML解析。</li>
</ul>
</li>
<li>
<p><strong>图（Graph）</strong>:</p>
<ul>
<li><strong>特点</strong>: 由顶点（节点）和边组成，边可以有方向（有向图）或无方向（无向图），可以有权重。</li>
<li><strong>表示方法</strong>: 邻接矩阵、邻接表。</li>
<li><strong>操作</strong>: 遍历（深度优先搜索DFS、广度优先搜索BFS）、查找最短路径（Dijkstra、Floyd-Warshall）、最小生成树（Prim、Kruskal）。</li>
<li><strong>适用场景</strong>: 社交网络、地图导航、网络拓扑、推荐系统。</li>
</ul>
</li>
<li>
<p><strong>哈希表（Python中的字典 <code>dict</code>）</strong>:</p>
<ul>
<li><strong>特点</strong>: 通过<strong>哈希函数</strong>将键映射到存储位置，实现快速查找。键是唯一的，值可以是任意类型。</li>
<li><strong>操作</strong>:
<ul>
<li><strong>插入、删除、查找</strong>: 平均 O(1)，最坏 O(N) (哈希冲突严重时)。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 快速查找、去重、缓存、计数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="常见算法">
  常见算法
  <a class="anchor" href="#%e5%b8%b8%e8%a7%81%e7%ae%97%e6%b3%95">#</a>
</h4>
<ul>
<li>
<p><strong>排序算法（冒泡、选择、插入、快速、归并等）。</strong></p>
<ul>
<li>
<p><strong>冒泡排序（Bubble Sort）</strong>:</p>
<ul>
<li><strong>原理</strong>: 重复遍历列表，比较相邻元素，如果顺序错误就交换，直到没有元素可以交换为止。</li>
<li><strong>时间复杂度</strong>: 最好O(N)，平均O(N²)，最坏O(N²)。</li>
<li><strong>空间复杂度</strong>: O(1)。</li>
<li><strong>稳定性</strong>: 稳定。</li>
<li><strong>特点</strong>: 简单易懂，效率低下。</li>
</ul>
</li>
<li>
<p><strong>选择排序（Selection Sort）</strong>:</p>
<ul>
<li><strong>原理</strong>: 每次遍历从未排序部分找到最小（或最大）元素，放到已排序部分的末尾。</li>
<li><strong>时间复杂度</strong>: 始终O(N²)。</li>
<li><strong>空间复杂度</strong>: O(1)。</li>
<li><strong>稳定性</strong>: 不稳定。</li>
<li><strong>特点</strong>: 每次交换只移动一个元素，交换次数最少。</li>
</ul>
</li>
<li>
<p><strong>插入排序（Insertion Sort）</strong>:</p>
<ul>
<li><strong>原理</strong>: 每次取一个未排序元素，插入到已排序部分的正确位置。</li>
<li><strong>时间复杂度</strong>: 最好O(N)，平均O(N²)，最坏O(N²)。</li>
<li><strong>空间复杂度</strong>: O(1)。</li>
<li><strong>稳定性</strong>: 稳定。</li>
<li><strong>特点</strong>: 对于部分有序的列表效率较高，小规模数据表现良好。</li>
</ul>
</li>
<li>
<p><strong>快速排序（Quick Sort）</strong>:</p>
<ul>
<li><strong>原理</strong>: 分治法。选择一个“基准”（pivot）元素，将列表分为两部分：小于基准的元素放在左边，大于基准的元素放在右边，然后对左右两部分递归地进行快速排序。</li>
<li><strong>时间复杂度</strong>: 最好O(N log N)，平均O(N log N)，最坏O(N²) (取决于基准选择)。</li>
<li><strong>空间复杂度</strong>: O(log N) (递归栈空间)。</li>
<li><strong>稳定性</strong>: 不稳定。</li>
<li><strong>特点</strong>: 大多数情况下性能优秀，是实践中常用的排序算法。</li>
</ul>
</li>
<li>
<p><strong>归并排序（Merge Sort）</strong>:</p>
<ul>
<li><strong>原理</strong>: 分治法。将列表递归地分成两半，直到每个子列表只有一个元素（自然有序），然后将有序的子列表合并（归并）起来。</li>
<li><strong>时间复杂度</strong>: 始终O(N log N)。</li>
<li><strong>空间复杂度</strong>: O(N) (需要额外空间进行合并)。</li>
<li><strong>稳定性</strong>: 稳定。</li>
<li><strong>特点</strong>: 性能稳定，适合处理大数据量，常用于外部排序。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>查找算法（线性查找、二分查找）。</strong></p>
<ul>
<li>
<p><strong>线性查找（Linear Search）</strong>:</p>
<ul>
<li><strong>原理</strong>: 从列表的第一个元素开始，逐个比较，直到找到目标元素或遍历完整个列表。</li>
<li><strong>时间复杂度</strong>: 最好O(1)，平均O(N)，最坏O(N)。</li>
<li><strong>适用场景</strong>: 列表无序，或列表规模较小。</li>
</ul>
</li>
<li>
<p><strong>二分查找（Binary Search）</strong>:</p>
<ul>
<li><strong>原理</strong>: 适用于<strong>有序列表</strong>。每次比较中间元素与目标值，如果相等则找到；如果目标值小于中间元素，则在左半部分继续查找；如果目标值大于中间元素，则在右半部分继续查找。每次将搜索范围缩小一半。</li>
<li><strong>时间复杂度</strong>: O(log N)。</li>
<li><strong>适用场景</strong>: 列表有序，且需要高效查找。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>递归与迭代。</strong></p>
<ul>
<li>
<p><strong>递归（Recursion）</strong>:</p>
<ul>
<li><strong>定义</strong>: 一个函数直接或间接调用自身。</li>
<li><strong>组成部分</strong>:
<ul>
<li><strong>基线条件（Base Case）</strong>: 终止递归的条件，避免无限循环。</li>
<li><strong>递归调用（Recursive Call）</strong>: 函数调用自身，问题规模缩小。</li>
</ul>
</li>
<li><strong>优点</strong>: 代码简洁、逻辑清晰，尤其适合解决具有分形结构的问题（如树的遍历、阶乘、斐波那契数列）。</li>
<li><strong>缺点</strong>:
<ul>
<li><strong>栈溢出</strong>: 递归深度过大可能导致栈溢出（Python默认递归深度有限制）。</li>
<li><strong>性能开销</strong>: 每次函数调用都会产生额外的栈帧开销。</li>
<li><strong>难以调试</strong>: 跟踪递归过程可能比较复杂。</li>
</ul>
</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">factorial_recursive</span>(n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>: <span style="color:#75715e"># 基线条件</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> n <span style="color:#f92672">*</span> factorial_recursive(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e"># 递归调用</span>
</span></span><span style="display:flex;"><span>print(factorial_recursive(<span style="color:#ae81ff">5</span>)) <span style="color:#75715e"># 120</span>
</span></span></code></pre></div></li>
<li>
<p><strong>迭代（Iteration）</strong>:</p>
<ul>
<li><strong>定义</strong>: 使用循环（<code>for</code> 或 <code>while</code>）重复执行代码块，通过变量的更新来逐步逼近问题的解。</li>
<li><strong>优点</strong>:
<ul>
<li><strong>性能优越</strong>: 通常比递归更高效，没有函数调用栈的开销。</li>
<li><strong>避免栈溢出</strong>: 不会受递归深度限制。</li>
<li><strong>易于调试</strong>: 流程更直观。</li>
</ul>
</li>
<li><strong>缺点</strong>: 对于某些问题，迭代的逻辑可能比递归更复杂，代码可读性可能下降。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">factorial_iterative</span>(n):
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">*=</span> i
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>print(factorial_iterative(<span style="color:#ae81ff">5</span>)) <span style="color:#75715e"># 120</span>
</span></span></code></pre></div></li>
<li>
<p><strong>选择</strong>: 对于大多数情况，迭代是更推荐的选择，因为它更高效且不易出错。但对于某些问题（如树的遍历），递归的逻辑可能更自然和直观。</p>
</li>
</ul>
</li>
<li>
<p><strong>动态规划、贪心算法等。</strong></p>
<ul>
<li>
<p><strong>动态规划（Dynamic Programming, DP）</strong>:</p>
<ul>
<li><strong>原理</strong>: 解决复杂问题的一种方法，它将问题分解为相互重叠的子问题，并通过存储子问题的解来避免重复计算。</li>
<li><strong>核心思想</strong>:
<ul>
<li><strong>最优子结构</strong>: 问题的最优解包含其子问题的最优解。</li>
<li><strong>重叠子问题</strong>: 解决问题的过程中，会多次遇到相同的子问题。</li>
</ul>
</li>
<li><strong>实现方式</strong>: 通常使用**自底向上（Bottom-up）<strong>的迭代方式（填充DP表）或</strong>自顶向下（Top-down）**的递归加记忆化（Memoization）方式。</li>
<li><strong>适用场景</strong>: 最短路径、背包问题、最长公共子序列、斐波那契数列（优化）。</li>
<li><strong>例子（斐波那契数列）</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fib_dp</span>(n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> n
</span></span><span style="display:flex;"><span>    dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        dp[i] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dp[n]
</span></span><span style="display:flex;"><span>print(fib_dp(<span style="color:#ae81ff">10</span>)) <span style="color:#75715e"># 55</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>贪心算法（Greedy Algorithm）</strong>:</p>
<ul>
<li><strong>原理</strong>: 在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的。</li>
<li><strong>核心思想</strong>: 局部最优解能够导致全局最优解。</li>
<li><strong>特点</strong>:
<ul>
<li>不考虑未来的影响，只看当前最优。</li>
<li>并非所有问题都适用贪心算法，只有当问题具有<strong>贪心选择性质</strong>和<strong>最优子结构性质</strong>时，贪心算法才能得到全局最优解。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 找零问题、活动选择问题、霍夫曼编码、最小生成树（Prim、Kruskal）。</li>
<li><strong>例子（找零问题，假设有1, 5, 10, 25面值的硬币）</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_change</span>(amount, coins<span style="color:#f92672">=</span>[<span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>]):
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> coin <span style="color:#f92672">in</span> coins:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> amount <span style="color:#f92672">&gt;=</span> coin:
</span></span><span style="display:flex;"><span>            count <span style="color:#f92672">=</span> amount <span style="color:#f92672">//</span> coin
</span></span><span style="display:flex;"><span>            result[coin] <span style="color:#f92672">=</span> count
</span></span><span style="display:flex;"><span>            amount <span style="color:#f92672">%=</span> coin
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>print(find_change(<span style="color:#ae81ff">63</span>)) <span style="color:#75715e"># {25: 2, 10: 1, 5: 0, 1: 3} -&gt; 2个25, 1个10, 3个1</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="编程题">
  编程题
  <a class="anchor" href="#%e7%bc%96%e7%a8%8b%e9%a2%98">#</a>
</h4>
<ul>
<li>
<p><strong>字符串操作、数组操作、树的遍历、图的搜索等。</strong></p>
<ul>
<li>
<p><strong>字符串操作</strong>:</p>
<ul>
<li><strong>反转字符串</strong>: <code>s[::-1]</code></li>
<li><strong>判断回文</strong>: <code>s == s[::-1]</code></li>
<li><strong>查找子串</strong>: <code>s.find()</code>, <code>s.index()</code>, <code>in</code> 运算符</li>
<li><strong>替换</strong>: <code>s.replace()</code></li>
<li><strong>分割/连接</strong>: <code>s.split()</code>, <code>&quot;&quot;.join(list_of_strings)</code></li>
<li><strong>大小写转换</strong>: <code>s.lower()</code>, <code>s.upper()</code></li>
<li><strong>去除空白</strong>: <code>s.strip()</code>, <code>s.lstrip()</code>, <code>s.rstrip()</code></li>
<li><strong>判断类型</strong>: <code>s.isalpha()</code>, <code>s.isdigit()</code>, <code>s.isalnum()</code></li>
<li><strong>字符串格式化</strong>: f-string, <code>format()</code></li>
<li><strong>例：统计字符出现次数</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> Counter
</span></span><span style="display:flex;"><span>text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span>
</span></span><span style="display:flex;"><span>counts <span style="color:#f92672">=</span> Counter(text)
</span></span><span style="display:flex;"><span>print(counts)
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>数组（列表）操作</strong>:</p>
<ul>
<li><strong>增删改查</strong>: <code>append()</code>, <code>insert()</code>, <code>pop()</code>, <code>remove()</code>, 索引访问 <code>[]</code></li>
<li><strong>排序</strong>: <code>list.sort()</code>, <code>sorted()</code></li>
<li><strong>切片</strong>: <code>my_list[start:end:step]</code></li>
<li><strong>列表推导式</strong>: 高效创建新列表</li>
<li><strong>例：两数之和（LeetCode经典题）</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">two_sum</span>(nums, target):
</span></span><span style="display:flex;"><span>    num_map <span style="color:#f92672">=</span> {} <span style="color:#75715e"># 值 -&gt; 索引</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i, num <span style="color:#f92672">in</span> enumerate(nums):
</span></span><span style="display:flex;"><span>        complement <span style="color:#f92672">=</span> target <span style="color:#f92672">-</span> num
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> complement <span style="color:#f92672">in</span> num_map:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> [num_map[complement], i]
</span></span><span style="display:flex;"><span>        num_map[num] <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> []
</span></span><span style="display:flex;"><span>print(two_sum([<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">15</span>], <span style="color:#ae81ff">9</span>)) <span style="color:#75715e"># [0, 1]</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>树的遍历（以二叉树为例）</strong>:</p>
<ul>
<li><strong>节点定义</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TreeNode</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, val<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>val <span style="color:#f92672">=</span> val
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span></code></pre></div></li>
<li><strong>前序遍历（Pre-order Traversal）</strong>: 根 -&gt; 左 -&gt; 右
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">preorder_traversal</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span>append(root<span style="color:#f92672">.</span>val)
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span>extend(preorder_traversal(root<span style="color:#f92672">.</span>left))
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span>extend(preorder_traversal(root<span style="color:#f92672">.</span>right))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span></code></pre></div></li>
<li><strong>中序遍历（In-order Traversal）</strong>: 左 -&gt; 根 -&gt; 右 (对于BST，得到有序序列)
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorder_traversal</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span>extend(inorder_traversal(root<span style="color:#f92672">.</span>left))
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span>append(root<span style="color:#f92672">.</span>val)
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span>extend(inorder_traversal(root<span style="color:#f92672">.</span>right))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span></code></pre></div></li>
<li><strong>后序遍历（Post-order Traversal）</strong>: 左 -&gt; 右 -&gt; 根
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">postorder_traversal</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span>extend(postorder_traversal(root<span style="color:#f92672">.</span>left))
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span>extend(postorder_traversal(root<span style="color:#f92672">.</span>right))
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span>append(root<span style="color:#f92672">.</span>val)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span></code></pre></div></li>
<li><strong>层序遍历（Level-order Traversal / BFS）</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">levelorder_traversal</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    queue <span style="color:#f92672">=</span> deque([root])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> queue:
</span></span><span style="display:flex;"><span>        node <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span>        result<span style="color:#f92672">.</span>append(node<span style="color:#f92672">.</span>val)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>left:
</span></span><span style="display:flex;"><span>            queue<span style="color:#f92672">.</span>append(node<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>right:
</span></span><span style="display:flex;"><span>            queue<span style="color:#f92672">.</span>append(node<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>图的搜索（以邻接表表示的无向图为例）</strong>:</p>
<ul>
<li><strong>邻接表表示</strong>: <code>graph = { 'A': ['B', 'C'], 'B': ['A', 'D'], ... }</code></li>
<li><strong>深度优先搜索（DFS）</strong>:
<ul>
<li><strong>原理</strong>: 尽可能深地探索图的分支，直到不能再深入为止，然后回溯。</li>
<li><strong>实现</strong>: 通常使用递归或栈。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(graph, start_node, visited<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> visited <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        visited <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>    visited<span style="color:#f92672">.</span>add(start_node)
</span></span><span style="display:flex;"><span>    print(start_node, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34; &#34;</span>) <span style="color:#75715e"># 访问节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> neighbor <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>get(start_node, []):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> neighbor <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> visited:
</span></span><span style="display:flex;"><span>            dfs(graph, neighbor, visited)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># graph = {&#39;A&#39;: [&#39;B&#39;, &#39;C&#39;], &#39;B&#39;: [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;], &#39;C&#39;: [&#39;A&#39;, &#39;F&#39;], &#39;D&#39;: [&#39;B&#39;], &#39;E&#39;: [&#39;B&#39;, &#39;F&#39;], &#39;F&#39;: [&#39;C&#39;, &#39;E&#39;]}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># dfs(graph, &#39;A&#39;) # A B D E F C</span>
</span></span></code></pre></div></li>
<li><strong>广度优先搜索（BFS）</strong>:
<ul>
<li><strong>原理</strong>: 从起始节点开始，逐层向外探索所有邻居节点，然后是邻居的邻居，以此类推。</li>
<li><strong>实现</strong>: 通常使用队列。</li>
</ul>
<!-- end list -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bfs</span>(graph, start_node):
</span></span><span style="display:flex;"><span>    visited <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>    queue <span style="color:#f92672">=</span> deque([start_node])
</span></span><span style="display:flex;"><span>    visited<span style="color:#f92672">.</span>add(start_node)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> queue:
</span></span><span style="display:flex;"><span>        node <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span>        print(node, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34; &#34;</span>) <span style="color:#75715e"># 访问节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> neighbor <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>get(node, []):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> neighbor <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> visited:
</span></span><span style="display:flex;"><span>                visited<span style="color:#f92672">.</span>add(neighbor)
</span></span><span style="display:flex;"><span>                queue<span style="color:#f92672">.</span>append(neighbor)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># bfs(graph, &#39;A&#39;) # A B C D E F</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>通常会要求你写出可运行的代码，并分析时间复杂度和空间复杂度。</strong></p>
<ul>
<li>
<p><strong>时间复杂度（Time Complexity）</strong>:</p>
<ul>
<li>衡量算法运行时间与输入规模的关系。</li>
<li>使用大O表示法（Big O notation）表示，例如O(1), O(log N), O(N), O(N log N), O(N²), O(2^N), O(N!)。</li>
<li>只关注算法执行次数的增长趋势，忽略常数项和低阶项。</li>
<li><strong>分析方法</strong>: 找出代码中执行次数最多的操作，计算其执行次数与输入规模N的关系。
<ul>
<li>循环: 单层循环通常O(N)，嵌套循环O(N²)。</li>
<li>递归: 考虑递归深度和每次递归操作的复杂度。</li>
<li>哈希表操作: 平均O(1)。</li>
<li>排序: 根据具体算法而定。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>空间复杂度（Space Complexity）</strong>:</p>
<ul>
<li>衡量算法运行所需存储空间与输入规模的关系。</li>
<li>同样使用大O表示法。</li>
<li>只关注额外使用的空间（不包括输入本身占用的空间）。</li>
<li><strong>分析方法</strong>: 找出算法中使用的额外数据结构（如栈、队列、哈希表、额外数组）的大小与输入规模N的关系。
<ul>
<li>O(1): 常数空间，不随输入规模变化。</li>
<li>O(N): 线性空间，与输入规模成正比。</li>
<li>O(log N): 对数空间，如二分查找的递归栈。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>示例分析（二分查找）</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">binary_search</span>(arr, target):
</span></span><span style="display:flex;"><span>    left, right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, len(arr) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e"># O(1)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> left <span style="color:#f92672">&lt;=</span> right: <span style="color:#75715e"># 循环次数：每次搜索范围减半，log N 次</span>
</span></span><span style="display:flex;"><span>        mid <span style="color:#f92672">=</span> (left <span style="color:#f92672">+</span> right) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> <span style="color:#75715e"># O(1)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> arr[mid] <span style="color:#f92672">==</span> target: <span style="color:#75715e"># O(1)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> mid
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> arr[mid] <span style="color:#f92672">&lt;</span> target: <span style="color:#75715e"># O(1)</span>
</span></span><span style="display:flex;"><span>            left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>: <span style="color:#75715e"># O(1)</span>
</span></span><span style="display:flex;"><span>            right <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><ul>
<li><strong>时间复杂度</strong>: 循环体内的操作都是O(1)，循环次数是<code>log N</code>。所以总时间复杂度是 <strong>O(log N)</strong>。</li>
<li><strong>空间复杂度</strong>: 只使用了几个变量（<code>left</code>, <code>right</code>, <code>mid</code>, <code>target</code>），这些变量的数量不随输入数组大小N的变化而变化。所以空间复杂度是 <strong>O(1)</strong>。</li>
</ul>
</li>
</ul>
<hr>
<p>这是第三部分的答案。最后一部分是关于<strong>项目经验与实践</strong>。</p>
<h3 id="5-项目经验与实践答案">
  5. 项目经验与实践答案
  <a class="anchor" href="#5-%e9%a1%b9%e7%9b%ae%e7%bb%8f%e9%aa%8c%e4%b8%8e%e5%ae%9e%e8%b7%b5%e7%ad%94%e6%a1%88">#</a>
</h3>
<hr>
<p>这部分问题没有标准答案，因为它们是关于你个人经历和能力的问题。我将提供一些指导原则和建议，帮助你准备这些问题的回答。</p>
<h4 id="项目经历与实践">
  项目经历与实践
  <a class="anchor" href="#%e9%a1%b9%e7%9b%ae%e7%bb%8f%e5%8e%86%e4%b8%8e%e5%ae%9e%e8%b7%b5">#</a>
</h4>
<ul>
<li>
<p><strong>项目经历：介绍你在项目中扮演的角色、遇到的挑战以及如何解决的。</strong></p>
<ul>
<li><strong>准备要点</strong>:
<ol>
<li><strong>选择相关项目</strong>: 挑选与面试岗位最相关、最能体现你技能的项目。</li>
<li><strong>STAR法则</strong>: 结构化你的回答，使用STAR法则（Situation, Task, Action, Result）。
<ul>
<li><strong>Situation (情境)</strong>: 描述项目的背景和目标。
<ul>
<li><em>例如</em>: “我参与了一个开发在线电商平台的项目，负责后端API的开发。”</li>
</ul>
</li>
<li><strong>Task (任务)</strong>: 描述你在项目中具体负责的任务和职责。
<ul>
<li><em>例如</em>: “我的任务是设计和实现商品管理模块的RESTful API，包括商品的增删改查和库存管理。”</li>
</ul>
</li>
<li><strong>Action (行动)</strong>: 详细说明你为了完成任务所采取的具体行动、技术选择和遇到的困难。
<ul>
<li><em>例如</em>: “在开发过程中，我们遇到了高并发下库存扣减的原子性问题。我研究了多种解决方案，最终决定采用数据库事务和悲观锁（或乐观锁）结合的方式来保证数据一致性。我还引入了消息队列来异步处理订单，减轻了数据库压力。”</li>
</ul>
</li>
<li><strong>Result (结果)</strong>: 描述你行动的结果和影响，量化你的贡献（如果可能）。
<ul>
<li><em>例如</em>: “通过这些优化，我们成功地将商品库存的并发处理能力提升了30%，并且系统在高负载下的稳定性得到了显著提高。我的代码通过了代码审查，并成功上线。”</li>
</ul>
</li>
</ul>
</li>
<li><strong>突出你的贡献</strong>: 强调你在团队中的角色以及你个人对项目的价值。</li>
<li><strong>技术细节</strong>: 提及你在项目中使用的具体Python技术、库、框架、数据库等。</li>
<li><strong>学习与成长</strong>: 即使项目中有失败或不足，也要说明你从中吸取了什么教训，学到了什么。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>调试与测试：你如何调试Python代码？了解单元测试、集成测试吗？</strong></p>
<ul>
<li>
<p><strong>调试Python代码</strong>:</p>
<ul>
<li><strong><code>print()</code> 语句</strong>: 最简单直接的方式，用于输出变量值、检查代码执行流程。</li>
<li><strong>Python内置调试器 <code>pdb</code></strong>:
<ul>
<li><code>import pdb; pdb.set_trace()</code>: 在代码中设置断点。</li>
<li>常用命令: <code>n</code> (next，下一步), <code>s</code> (step，进入函数), <code>c</code> (continue，继续执行), <code>p var</code> (print变量), <code>l</code> (list，查看代码)。</li>
</ul>
</li>
<li><strong>IDE集成调试器</strong>: PyCharm、VS Code等IDE都提供了强大的图形化调试工具，可以设置断点、单步执行、查看变量、调用堆栈等。</li>
<li><strong>日志（Logging）</strong>: 使用 <code>logging</code> 模块记录程序运行时的信息、警告和错误，比 <code>print()</code> 更灵活和强大，可以在生产环境中持续运行。</li>
<li><strong>异常处理</strong>: 利用 <code>try-except</code> 块捕获和处理异常，了解错误类型和回溯信息。</li>
</ul>
</li>
<li>
<p><strong>单元测试（Unit Testing）</strong>:</p>
<ul>
<li><strong>概念</strong>: 对软件中最小的可测试单元（通常是函数、方法或类）进行独立测试，验证其行为是否符合预期。</li>
<li><strong>目的</strong>: 确保每个组件单独工作正常，快速发现代码中的缺陷。</li>
<li><strong>Python工具</strong>: <code>unittest</code> (Python标准库), <code>pytest</code> (更流行、功能更强大)。</li>
<li><strong>特点</strong>: 独立性强，测试粒度小，运行速度快。</li>
</ul>
</li>
<li>
<p><strong>集成测试（Integration Testing）</strong>:</p>
<ul>
<li><strong>概念</strong>: 将多个已通过单元测试的模块组合在一起，测试它们之间的接口和交互是否正确。</li>
<li><strong>目的</strong>: 验证不同模块协同工作时是否产生预期结果，发现模块间接口问题。</li>
<li><strong>特点</strong>: 测试粒度比单元测试大，通常需要模拟外部依赖（如数据库、API服务）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>代码风格：了解PEP 8规范吗？</strong></p>
<ul>
<li><strong>PEP 8是什么？</strong>
<ul>
<li>PEP 8 是 Python 官方的<strong>代码风格指南</strong>（Python Enhancement Proposal 8）。</li>
<li>它提供了一套关于如何编写清晰、一致、易读的Python代码的建议和约定。</li>
<li><strong>目的</strong>: 提高Python代码的可读性，从而提高代码的维护性。当所有人都遵循相同的风格时，阅读和理解他人的代码会变得更容易。</li>
</ul>
</li>
<li><strong>PEP 8 包含哪些内容？</strong>
<ul>
<li><strong>命名约定</strong>: 变量、函数、类、模块、常量等的命名规则（如<code>snake_case</code>用于函数和变量，<code>CamelCase</code>用于类）。</li>
<li><strong>缩进</strong>: 统一使用4个空格进行缩进。</li>
<li><strong>行长度</strong>: 每行代码不超过79个字符（或88个字符，对于某些工具如Black）。</li>
<li><strong>空行</strong>: 在函数、类定义之间使用空行进行分隔，提高可读性。</li>
<li><strong>导入</strong>: 导入语句应放在文件顶部，按标准库、第三方库、本地模块的顺序分组，并按字母顺序排序。</li>
<li><strong>注释</strong>: 编写清晰、简洁的注释。</li>
<li><strong>空格</strong>: 在运算符、逗号等周围使用适当的空格。</li>
</ul>
</li>
<li><strong>你如何遵循PEP 8？</strong>
<ul>
<li><strong>手动遵循</strong>: 在编写代码时有意识地遵循这些规范。</li>
<li><strong>使用代码格式化工具</strong>: <code>Black</code> (不妥协的格式化程序), <code>autopep8</code>, <code>yapf</code> 等工具可以自动格式化代码以符合PEP 8。</li>
<li><strong>使用Linter</strong>: <code>Flake8</code>, <code>Pylint</code> 等工具可以检查代码是否符合PEP 8以及其他潜在的代码质量问题，并在IDE中给出提示。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>版本控制：Git的基本操作和工作流程。</strong></p>
<ul>
<li>
<p><strong>Git是什么？</strong></p>
<ul>
<li>Git 是一个<strong>分布式版本控制系统</strong>（Distributed Version Control System, DVCS）。</li>
<li>它用于跟踪文件和代码的更改，协调多人在同一项目上的工作，并允许回溯到任何历史版本。</li>
</ul>
</li>
<li>
<p><strong>Git基本操作</strong>:</p>
<ul>
<li><strong><code>git init</code></strong>: 在当前目录初始化一个新的Git仓库。</li>
<li><strong><code>git clone [url]</code></strong>: 克隆一个远程仓库到本地。</li>
<li><strong><code>git add &lt;file&gt;</code> / <code>git add .</code></strong>: 将文件添加到暂存区（Staging Area）。</li>
<li><strong><code>git commit -m &quot;commit message&quot;</code></strong>: 将暂存区的文件提交到本地仓库，并附带一条提交消息。</li>
<li><strong><code>git status</code></strong>: 查看工作区和暂存区的状态。</li>
<li><strong><code>git diff</code></strong>: 查看文件修改的差异。</li>
<li><strong><code>git log</code></strong>: 查看提交历史。</li>
<li><strong><code>git branch</code></strong>: 查看、创建、删除分支。</li>
<li><strong><code>git checkout &lt;branch_name&gt;</code> / <code>git switch &lt;branch_name&gt;</code></strong>: 切换分支。</li>
<li><strong><code>git merge &lt;branch_name&gt;</code></strong>: 合并指定分支到当前分支。</li>
<li><strong><code>git pull</code></strong>: 从远程仓库拉取（fetch并merge）最新代码。</li>
<li><strong><code>git push</code></strong>: 将本地提交推送到远程仓库。</li>
<li><strong><code>git remote</code></strong>: 管理远程仓库。</li>
<li><strong><code>git reset</code> / <code>git revert</code></strong>: 回滚版本。</li>
<li><strong><code>git stash</code></strong>: 暂时保存当前工作区修改，以便切换分支。</li>
</ul>
</li>
<li>
<p><strong>Git工作流程（常见如Git Flow或GitHub Flow）</strong>:</p>
<ul>
<li>
<p><strong>GitHub Flow (更简单)</strong>:</p>
<ol>
<li><strong><code>main</code> 分支是可部署的</strong>：所有代码都从 <code>main</code> 分支开始。</li>
<li><strong>创建新分支</strong>: 从 <code>main</code> 分支创建一个新的特性分支（feature branch），命名清晰。
<ul>
<li><code>git checkout -b feature/my-new-feature</code></li>
</ul>
</li>
<li><strong>开发与提交</strong>: 在特性分支上进行开发，并频繁提交代码。
<ul>
<li><code>git add .</code></li>
<li><code>git commit -m &quot;feat: implement new feature X&quot;</code></li>
</ul>
</li>
<li><strong>推送到远程</strong>: 将特性分支推送到远程仓库。
<ul>
<li><code>git push origin feature/my-new-feature</code></li>
</ul>
</li>
<li><strong>创建Pull Request (PR)</strong>: 在GitHub/GitLab等平台上创建PR，请求将特性分支合并到 <code>main</code>。</li>
<li><strong>代码审查</strong>: 团队成员审查代码，提出修改意见。</li>
<li><strong>合并与部署</strong>: PR通过审查后，合并到 <code>main</code> 分支，通常会自动触发部署。</li>
<li><strong>删除分支</strong>: 合并后可以删除特性分支。</li>
</ol>
</li>
<li>
<p><strong>Git Flow (更复杂，适用于大型项目)</strong>:</p>
<ul>
<li>引入了 <code>develop</code> 分支（开发主线）、<code>feature</code> 分支（特性开发）、<code>release</code> 分支（发布准备）、<code>hotfix</code> 分支（紧急修复）等，有更严格的生命周期管理。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>解决冲突</strong>: 当多人修改同一文件同一行时，Git无法自动合并，会产生冲突。需要手动编辑冲突文件，解决冲突后重新提交。</p>
</li>
</ul>
</li>
</ul>
<hr>
</div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>



<div class="busuanzi-footer">
  <p>© 2025 Powered By <a href="https://themes.gohugo.io/">Hugo</a> & 
    <a href="https://github.com/alex-shpak/hugo-book">Hugo-book</a> Contact: <a href="mailto:j.duan@foxmail.com">j.duan@foxmail.com</a></p> 
  <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span id="busuanzi_container_site_uv">
    本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>
</div>
 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<style>
    .no-marker::marker {
        content: none;
    }
</style>
<li class="no-marker"><a href="#Python%20%e5%9f%ba%e7%a1%80">Python 基础</a></li>
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#1-python基础知识答案">1. Python基础知识答案</a></li>
            <li><a href="#2-高级特性与进阶概念答案">2. 高级特性与进阶概念答案</a></li>
            <li><a href="#3-python库与框架答案">3. Python库与框架答案</a></li>
            <li><a href="#4-算法与数据结构答案">4. 算法与数据结构答案</a></li>
            <li><a href="#5-项目经验与实践答案">5. 项目经验与实践答案</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












